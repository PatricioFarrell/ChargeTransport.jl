<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>van Roosbroeck system · ChargeTransport.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../general/">ChargeTransport.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../general/">ChargeTransport.jl – Simulating charge transport in semiconductors</a></li><li><a class="tocitem" href="../backgroundinfo/">Mathematical drift-diffusion models</a></li><li><span class="tocitem">How to get started</span><ul><li><a class="tocitem" href="../GeneralInformation/">Code overview</a></li><li class="is-active"><a class="tocitem" href>van Roosbroeck system</a><ul class="internal"><li><a class="tocitem" href="#Example-1:-Stationary-1D-problem-(region-doping)"><span>Example 1: Stationary 1D problem (region doping)</span></a></li><li><a class="tocitem" href="#Example-2:-Stationary-1D-problem-(nodal-doping)"><span>Example 2: Stationary 1D problem (nodal doping)</span></a></li></ul></li><li><a class="tocitem" href="../PSC/">Perovskite solar cell</a></li></ul></li><li><a class="tocitem" href="../allindex/">Types, Constructors and Methods</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/Ex101_PIN/">GaAs diode (1D).</a></li><li><a class="tocitem" href="../examples/Ex102_PIN_nodal_doping/">GaAs diode with spatially varying doping (1D).</a></li><li><a class="tocitem" href="../examples/Ex103_PSC/">PSC device without mobile ions (1D).</a></li><li><a class="tocitem" href="../examples/Ex104_PSC_gradedFlux_Schottky_contacts/">PSC device with graded interfaces &amp; Schottky contacts (1D).</a></li><li><a class="tocitem" href="../examples/Ex105_PSC_gradedFlux/">PSC device with graded interfaces &amp; Ohmic contacts (1D).</a></li><li><a class="tocitem" href="../examples/Ex106_PSC_withIons_IVMeasurement/">PSC device with ions and linear I-V scan protocol (1D).</a></li><li><a class="tocitem" href="../examples/Ex107_PSC_withIons_sinusoidalVoltage/">PSC device with sinusoidal applied voltage (1D).</a></li><li><a class="tocitem" href="../examples/Ex108_PSC_BeerLambert_Generation/">PSC device with Beer-Lambert generation rate (1D).</a></li><li><a class="tocitem" href="../examples/Ex108_PSC_uniform_Generation/">PSC device with uniform generation rate (1D).</a></li><li><a class="tocitem" href="../examples/Ex109_Traps/">GaAs diode: transient with traps (1D).</a></li><li><a class="tocitem" href="../examples/Ex110_PSC_surface_recombination/">PSC device with surface recombination (1D).</a></li><li><a class="tocitem" href="../examples/Ex201_PSC_tensorGrid/">PSC device on 2D domain (Tensor grid).</a></li><li><a class="tocitem" href="../examples/Grid_3D/">Example code for a 3D grid.</a></li><li><a class="tocitem" href="../examples/Non_RectangularGrid_2D/">Example code for a 2D non rectangular grid.</a></li><li><a class="tocitem" href="../examples/PSC_2D_unstructuredGrid/">PSC device on 2D domain (unstructured grid).</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to get started</a></li><li class="is-active"><a href>van Roosbroeck system</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>van Roosbroeck system</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PatricioFarrell/ChargeTransport.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="van-Roosbroeck-system"><a class="docs-heading-anchor" href="#van-Roosbroeck-system">van Roosbroeck system</a><a id="van-Roosbroeck-system-1"></a><a class="docs-heading-anchor-permalink" href="#van-Roosbroeck-system" title="Permalink"></a></h1><p>In both of the following examples, we solve the van Roosbroeck equations, a system of partial differential equations which describe current flow in a bipolar multi layer device:</p><p class="math-container">\[\begin{aligned}
	- \nabla \cdot (\varepsilon_s \nabla \psi) &amp;= q \Big( (p(\psi, \varphi_p) - N_A ) - (n(\psi, \varphi_n) - N_D) \Big),\\
	q \partial_t n(\psi, \varphi_n) -\nabla \cdot \mathbf{j}_n &amp;= -qR(n,p), \\
	q \partial_t p(\psi, \varphi_p) + \nabla \cdot \mathbf{j}_p &amp;= -qR(n,p).
\end{aligned}\]</p><p>Ohmic contacts will be used as boundary conditions. We will proceed as follows</p><p>Step 1: Initialize grid</p><p>Step 2: Initialize physical model</p><p>Step 3: Solve the problem in equilibrium</p><p>Step 4: Solve the problem for an applied bias</p><h2 id="Example-1:-Stationary-1D-problem-(region-doping)"><a class="docs-heading-anchor" href="#Example-1:-Stationary-1D-problem-(region-doping)">Example 1: Stationary 1D problem (region doping)</a><a id="Example-1:-Stationary-1D-problem-(region-doping)-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Stationary-1D-problem-(region-doping)" title="Permalink"></a></h2><p>We consider a three-layer GaAs p-i-n device in one dimension. We will explain <a href="https://github.com/PatricioFarrell/ChargeTransport.jl/blob/master/examples/Ex101_PIN.jl">the PIN example</a> in greater detail.</p><h3 id="Step-1:-Initialize-grid"><a class="docs-heading-anchor" href="#Step-1:-Initialize-grid">Step 1: Initialize grid</a><a id="Step-1:-Initialize-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Initialize-grid" title="Permalink"></a></h3><p>We have three layers and two external boundaries. We would like to solve the van Roosbroeck system on a uniform mesh with local grid refinement. We declare subregions and external boundaries.</p><pre><code class="language-julia hljs"># region numbers
regionAcceptor          = 1          # p doped region
regionIntrinsic         = 2          # intrinsic region
regionDonor             = 3          # n doped region
regions                 = [regionAcceptor, regionIntrinsic, regionDonor]
numberOfRegions         = length(regions)

# boundary region numbers
bregionAcceptor         = 1
bregionDonor            = 2
bregions                = [bregionAcceptor, bregionDonor]
numberOfBoundaryRegions = length(bregions)

# grid
refinementfactor        = 2^(n-1)
h_pdoping               = 2 * μm
h_intrinsic             = 2 * μm
h_ndoping               = 2 * μm
coord                   = initialize_pin_grid(refinementfactor,
                                             h_pdoping,
                                             h_intrinsic,
                                             h_ndoping)

grid                    = simplexgrid(coord)

# ExtendableGrids.cellmask! assigns region numbers
cellmask!(grid, [0.0 * μm],[h_pdoping], regionAcceptor)
cellmask!(grid, [h_pdoping],[h_pdoping + h_intrinsic], regionIntrinsic)
cellmask!(grid, [h_pdoping + h_intrinsic],[h_pdoping + h_intrinsic + h_ndoping], regionDonor)</code></pre><h3 id="Step-2:-Initialize-physical-model"><a class="docs-heading-anchor" href="#Step-2:-Initialize-physical-model">Step 2: Initialize physical model</a><a id="Step-2:-Initialize-physical-model-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Initialize-physical-model" title="Permalink"></a></h3><p>Next, we choose relevant physical models such as the underlying statistics function or the recombination model. Additional options are stated in the comments. Furthermore, we define the charge carrier indices. The index for the electrostatic potential is set automatically to <code>numberOfCarriers + 1</code>.</p><pre><code class="language-julia hljs"># Set indices for the quasi Fermi potentials
iphin                  = 1    # electrons
iphip                  = 2    # holes
numberOfCarriers       = 2

# Initialize Data instance
data                   = Data(grid, numberOfCarriers)

# Solve the stationary problem instead of the transient one
data.modelType         = Stationary

# Choose statistical relation between density and qF potential
# options: Boltzmann, FermiDiracOneHalfBednarczyk,
#          FermiDiracOneHalfTeSCA FermiDiracMinusOne, Blakemore
data.F                .= Boltzmann

# Enable/Disable recombination processes, the default is stationary SRH recombination.
data.bulkRecombination = set_bulk_recombination(;iphin = iphin, iphip = iphip,
                                                 bulk_recomb_Auger = true,
                                                 bulk_recomb_radiative = true,
                                                 bulk_recomb_SRH = true)

# choose boundary models
# exterior boundaries: OhmicContact and SchottkyContact
# interior boundaries: InterfaceModelNone, InterfaceModelSurfaceReco.
data.boundaryType[bregionAcceptor] = OhmicContact
data.boundaryType[bregionDonor]    = OhmicContact

# choose flux discretization scheme: ScharfetterGummel ScharfetterGummelGraded,
# ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG
data.fluxApproximation             = ExcessChemicalPotential</code></pre><p>Next, we fill in pre-defined or externally read in parameter values.</p><pre><code class="language-julia hljs"># params contains all necessary physical parameters
params                                              = Params(grid, numberOfCarriers)
params.temperature                                  = T
params.UT                                           = (kB * params.temperature) / q
params.chargeNumbers[iphin]                         = -1
params.chargeNumbers[iphip]                         =  1

for ibreg in 1:numberOfBoundaryRegions   # boundary region data

    params.bDensityOfStates[iphin, ibreg]           = Nc
    params.bDensityOfStates[iphip, ibreg]           = Nv
    params.bBandEdgeEnergy[iphin, ibreg]            = Ec
    params.bBandEdgeEnergy[iphip, ibreg]            = Ev
end

for ireg in 1:numberOfRegions           # interior region data

    params.dielectricConstant[ireg]                 = εr

    # effective DOS, band-edge energy and mobilities
    params.densityOfStates[iphin, ireg]             = Nc
    params.densityOfStates[iphip, ireg]             = Nv
    params.bandEdgeEnergy[iphin, ireg]              = Ec
    params.bandEdgeEnergy[iphip, ireg]              = Ev
    params.mobility[iphin, ireg]                    = mun
    params.mobility[iphip, ireg]                    = mup

    # recombination parameters
    params.recombinationRadiative[ireg]             = Radiative
    params.recombinationSRHLifetime[iphin, ireg]    = SRH_LifeTime
    params.recombinationSRHLifetime[iphip, ireg]    = SRH_LifeTime
    params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity
    params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity
    params.recombinationAuger[iphin, ireg]          = Auger
    params.recombinationAuger[iphip, ireg]          = Auger

end

# interior doping
params.doping[iphin, regionDonor]                   = Nd
params.doping[iphin, regionIntrinsic]               = ni
params.doping[iphip, regionIntrinsic]               = 0.0
params.doping[iphip, regionAcceptor]                = Na

# boundary doping
params.bDoping[iphin, bregionDonor]                 = Nd
params.bDoping[iphip, bregionAcceptor]              = Na

# Initialize a ChargeTransport struct
data.params   = params
ctsys         = System(grid, data, unknown_storage=unknown_storage)</code></pre><p>We use ohmic contacts and set the applied voltage to zero in equilibrium.</p><pre><code class="language-julia hljs">set_contact!(ctsys, bregionAcceptor, Δu = 0.0)
set_contact!(ctsys, bregionDonor,    Δu = 0.0)</code></pre><h3 id="Step-3:-Solve-the-problem-in-equilibrium"><a class="docs-heading-anchor" href="#Step-3:-Solve-the-problem-in-equilibrium">Step 3: Solve the problem in equilibrium</a><a id="Step-3:-Solve-the-problem-in-equilibrium-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Solve-the-problem-in-equilibrium" title="Permalink"></a></h3><p>Solve the equilibrium. Note that <code>control</code> refers to the Newton control parameters given in <code>VoronoiFVM</code>.</p><pre><code class="language-julia hljs">solution      = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)
initialGuess .= solution</code></pre><h3 id="Step-4:-Solve-the-problem-for-an-applied-bias"><a class="docs-heading-anchor" href="#Step-4:-Solve-the-problem-for-an-applied-bias">Step 4: Solve the problem for an applied bias</a><a id="Step-4:-Solve-the-problem-for-an-applied-bias-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Solve-the-problem-for-an-applied-bias" title="Permalink"></a></h3><p>Starting from the equilibrium solution, we increase the applied voltage. Note that it is important to set <code>OutOfEqulibrium</code>.</p><pre><code class="language-julia hljs">data.calculationType = OutOfEquilibrium
maxBias              = voltageAcceptor # bias at acceptor boundary
biasValues           = range(0, stop = maxBias, length = 32)

for Δu in biasValues
    set_contact!(ctsys, bregionAcceptor, Δu = Δu) # non equilibrium bc
    solve!(solution, initialGuess, ctsys, control = control, tstep = Inf)
    initialGuess .= solution
end</code></pre><h3 id="Step-5:-Postprocessing"><a class="docs-heading-anchor" href="#Step-5:-Postprocessing">Step 5: Postprocessing</a><a id="Step-5:-Postprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-Postprocessing" title="Permalink"></a></h3><p>By adding the following line to the previous loop</p><pre><code class="language-julia hljs">current = get_current_val(ctsys, solution)</code></pre><p>we have the possibility to calculate the total current.</p><p>Moreover, there are several different plotting routines, see <a href="https://github.com/PatricioFarrell/ChargeTransport.jl/blob/master/src/ct_plotting.jl">ct_plotting.jl</a>.</p><h2 id="Example-2:-Stationary-1D-problem-(nodal-doping)"><a class="docs-heading-anchor" href="#Example-2:-Stationary-1D-problem-(nodal-doping)">Example 2: Stationary 1D problem (nodal doping)</a><a id="Example-2:-Stationary-1D-problem-(nodal-doping)-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Stationary-1D-problem-(nodal-doping)" title="Permalink"></a></h2><p>Now, instead of using regionwise doping it is possible to apply a nodal doping. (This is indeed also possible for other physical parameters, see the description of <a href="https://github.com/PatricioFarrell/ChargeTransport.jl/blob/ab0684293845859fb142ea69d786a88b597a8b67/src/ct_system.jl#L426">ParamsNodal</a>.) For this, go to previous Step 2, where you build your parameter set and adjust the doping initialization (code snippet is from <a href="https://github.com/PatricioFarrell/ChargeTransport.jl/blob/master/examples/Ex102_PIN_nodal_doping.jl">this example</a>)</p><pre><code class="language-julia hljs">paramsnodal = ParamsNodal(grid, numberOfCarriers)

# initialize the space dependent doping
NDoping = 1.0e17  / cm^3; κ = 500.0
for icoord = 1:numberOfNodes
    t1 = tanh( (0.1 - coord[icoord]/μm) *κ )
    t2 = 1.0 + tanh( (coord[icoord]/μm - 0.2) * κ )
    paramsnodal.doping[icoord] = NDoping * 0.5 * ( 1.0  +  t1  - t2 )
end

data.paramsnodal  = paramsnodal</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../GeneralInformation/">« Code overview</a><a class="docs-footer-nextpage" href="../PSC/">Perovskite solar cell »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Friday 6 May 2022 17:13">Friday 6 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
