<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>van Roosbroeck system · ChargeTransport.jl</title><meta name="title" content="van Roosbroeck system · ChargeTransport.jl"/><meta property="og:title" content="van Roosbroeck system · ChargeTransport.jl"/><meta property="twitter:title" content="van Roosbroeck system · ChargeTransport.jl"/><meta name="description" content="Documentation for ChargeTransport.jl."/><meta property="og:description" content="Documentation for ChargeTransport.jl."/><meta property="twitter:description" content="Documentation for ChargeTransport.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../general/">ChargeTransport.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../general/">ChargeTransport.jl – Simulating charge transport in semiconductors</a></li><li><a class="tocitem" href="../backgroundinfo/">Mathematical drift-diffusion models</a></li><li><span class="tocitem">How to get started</span><ul><li><a class="tocitem" href="../GeneralInformation/">Code overview</a></li><li class="is-active"><a class="tocitem" href>van Roosbroeck system</a><ul class="internal"><li><a class="tocitem" href="#Example-1:-Stationary-1D-problem-(region-doping)"><span>Example 1: Stationary 1D problem (region doping)</span></a></li><li><a class="tocitem" href="#Example-2:-Stationary-1D-problem-(nodal-doping)"><span>Example 2: Stationary 1D problem (nodal doping)</span></a></li></ul></li><li><a class="tocitem" href="../PSC/">Perovskite solar cell</a></li></ul></li><li><a class="tocitem" href="../allindex/">Types, Constructors and Methods</a></li><li><span class="tocitem">Pluto Notebooks</span><ul><li><a class="tocitem" href="../nbhtml/PSC_example/">PSC example</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/Ex101_PIN/">GaAs diode (1D).</a></li><li><a class="tocitem" href="../examples/Ex102_PIN_nodal_doping/">GaAs diode with spatially varying doping (1D).</a></li><li><a class="tocitem" href="../examples/Ex103_PSC_IVMeasurement/">PSC device with ions and different I-V scan protocols (1D).</a></li><li><a class="tocitem" href="../examples/Ex104_PSC_Photogeneration/">PSC device with photogeneration rate (1D).</a></li><li><a class="tocitem" href="../examples/Ex105_PSC_gradedFlux/">Three-layer PSC device with graded interfaces &amp; Ohmic contacts (1D).</a></li><li><a class="tocitem" href="../examples/Ex106_PSC_SurfaceRecombination/">PSC device with surface recombination (1D).</a></li><li><a class="tocitem" href="../examples/Ex107_MoS2_withIons_BarrierLowering/">MoS2 with moving defects and Schottky Barrier Lowering.</a></li><li><a class="tocitem" href="../examples/Ex108_CIGS_WithTraps/">CIGS: stationary with traps and Schottky contacts.</a></li><li><a class="tocitem" href="../examples/Ex109_Traps/">GaAs diode: transient with traps (1D).</a></li><li><a class="tocitem" href="../examples/Ex201_PSC_tensorGrid/">PSC device on 2D domain (Tensor grid).</a></li><li><a class="tocitem" href="../examples/Grid_3D/">Example code for a 3D grid.</a></li><li><a class="tocitem" href="../examples/Non_RectangularGrid_2D/">Example code for a 2D non rectangular grid.</a></li><li><a class="tocitem" href="../examples/PSC_2D_unstructuredGrid/">PSC device on 2D domain (unstructured grid).</a></li><li><a class="tocitem" href="../examples/PSC_3D/">Illustrative example of a three dimensional simulation.</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to get started</a></li><li class="is-active"><a href>van Roosbroeck system</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>van Roosbroeck system</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/PatricioFarrell/ChargeTransport.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="van-Roosbroeck-system"><a class="docs-heading-anchor" href="#van-Roosbroeck-system">van Roosbroeck system</a><a id="van-Roosbroeck-system-1"></a><a class="docs-heading-anchor-permalink" href="#van-Roosbroeck-system" title="Permalink"></a></h1><p>In both of the following examples, we solve the van Roosbroeck equations, a system of partial differential equations which describe current flow in a bipolar multi layer device:</p><p class="math-container">\[\begin{aligned}
	- \nabla \cdot (\varepsilon_s \nabla \psi) &amp;= q \Big( (p(\psi, \varphi_p) - C_p ) - (n(\psi, \varphi_n) - C_n) \Big),\\
	q \partial_t n(\psi, \varphi_n) -\nabla \cdot \mathbf{j}_n &amp;= -qR(n,p), \\
	q \partial_t p(\psi, \varphi_p) + \nabla \cdot \mathbf{j}_p &amp;= -qR(n,p).
\end{aligned}\]</p><p>Ohmic contacts will be used as boundary conditions. We will proceed as follows</p><p>Step 1: Initialize grid</p><p>Step 2: Initialize physical model</p><p>Step 3: Solve the problem in equilibrium</p><p>Step 4: Solve the problem for an applied bias</p><h2 id="Example-1:-Stationary-1D-problem-(region-doping)"><a class="docs-heading-anchor" href="#Example-1:-Stationary-1D-problem-(region-doping)">Example 1: Stationary 1D problem (region doping)</a><a id="Example-1:-Stationary-1D-problem-(region-doping)-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Stationary-1D-problem-(region-doping)" title="Permalink"></a></h2><p>We consider a three-layer GaAs p-i-n device in one dimension. We will explain <a href="https://github.com/PatricioFarrell/ChargeTransport.jl/blob/master/examples/Ex101_PIN.jl">the PIN example</a> in greater detail.</p><h3 id="Step-1:-Initialize-grid"><a class="docs-heading-anchor" href="#Step-1:-Initialize-grid">Step 1: Initialize grid</a><a id="Step-1:-Initialize-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Initialize-grid" title="Permalink"></a></h3><p>We have three layers and two external boundaries. We would like to solve the van Roosbroeck system on a uniform mesh with local grid refinement. We declare subregions and external boundaries.</p><pre><code class="language-julia hljs">## region numbers
regionAcceptor   = 1          # p doped region
regionIntrinsic  = 2          # intrinsic region
regionDonor      = 3          # n doped region
regions          = [regionAcceptor, regionIntrinsic, regionDonor]
numberOfRegions  = length(regions)

## boundary region numbers
# Note that by convention we have 1 for the left boundary and 2 for the right boundary. If
# adding additional interior boundaries, continue with 3, 4, ...
bregionAcceptor  = 1
bregionDonor     = 2
bregionJunction1 = 3
bregionJunction2 = 4

## grid
refinementfactor = 2^(n-1)
h_pdoping        = 2.0    * μm
h_intrinsic      = 2.0    * μm
h_ndoping        = 2.0    * μm
h_total          = h_pdoping + h_intrinsic + h_ndoping
w_device         = 0.5    * μm  # width of device
z_device         = 1.0e-4 * cm  # depth of device
coord            = initialize_pin_grid(refinementfactor,
                                        h_pdoping,
                                        h_intrinsic,
                                        h_ndoping)

grid             = simplexgrid(coord)

## cellmask! for defining the subregions and assigning region number
cellmask!(grid, [0.0 * μm],                [h_pdoping],                           regionAcceptor)  # p-doped region = 1
cellmask!(grid, [h_pdoping],               [h_pdoping + h_intrinsic],             regionIntrinsic) # intrinsic region = 2
cellmask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic + h_ndoping], regionDonor)     # n-doped region = 3

## bfacemask! for setting different boundary regions. At exterior boundaries they are automatically set by
## ExtendableGridsjl. Thus, there the following two lines are actually unneccesarry, but are only written for completeness.
bfacemask!(grid, [0.0],                     [0.0],                     bregionAcceptor)     # outer left boundary
bfacemask!(grid, [h_total],                 [h_total],                 bregionDonor)  # outer right boundary
bfacemask!(grid, [h_pdoping],               [h_pdoping],               bregionJunction1) # first  inner interface
bfacemask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic], bregionJunction2) # second inner interface</code></pre><h3 id="Step-2:-Initialize-physical-model"><a class="docs-heading-anchor" href="#Step-2:-Initialize-physical-model">Step 2: Initialize physical model</a><a id="Step-2:-Initialize-physical-model-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Initialize-physical-model" title="Permalink"></a></h3><p>Next, we choose relevant physical models such as the underlying statistics function or the recombination model. Additional options are stated in the comments. Furthermore, we define the charge carrier indices. The index for the electrostatic potential is set automatically to <code>numberOfCarriers + 1</code>.</p><pre><code class="language-julia hljs"># Set indices for the quasi Fermi potentials
iphin                  = 1    # electrons
iphip                  = 2    # holes
numberOfCarriers       = 2

# Initialize Data instance
data                   = Data(grid, numberOfCarriers)

# Solve the stationary problem instead of the transient one
data.modelType         = Stationary

# Choose statistical relation between density and qF potential
# options: Boltzmann, FermiDiracOneHalfBednarczyk,
#          FermiDiracOneHalfTeSCA FermiDiracMinusOne, Blakemore
data.F                .= Boltzmann

# Enable/Disable recombination processes, the default is stationary SRH recombination.
data.bulkRecombination = set_bulk_recombination(;iphin = iphin, iphip = iphip,
                                                 bulk_recomb_Auger = true,
                                                 bulk_recomb_radiative = true,
                                                 bulk_recomb_SRH = true)

# choose boundary models
# exterior boundaries: OhmicContact and SchottkyContact
# interior boundaries: InterfaceModelNone, InterfaceModelSurfaceReco.
data.boundaryType[bregionAcceptor] = OhmicContact
data.boundaryType[bregionDonor]    = OhmicContact

# choose flux discretization scheme: ScharfetterGummel ScharfetterGummelGraded,
# ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG
data.fluxApproximation            .= ExcessChemicalPotential</code></pre><p>Next, we fill in pre-defined or externally read in parameter values.</p><pre><code class="language-julia hljs"># params contains all necessary physical parameters
params                                              = Params(grid, numberOfCarriers)
params.temperature                                  = T
params.UT                                           = (kB * params.temperature) / q
params.chargeNumbers[iphin]                         = -1
params.chargeNumbers[iphip]                         =  1

for ireg in 1:numberOfRegions           # region data

    params.dielectricConstant[ireg]                 = εr  * ε0

    # effective DOS, band-edge energy and mobilities
    params.densityOfStates[iphin, ireg]             = Nc
    params.densityOfStates[iphip, ireg]             = Nv
    params.bandEdgeEnergy[iphin, ireg]              = Ec
    params.bandEdgeEnergy[iphip, ireg]              = Ev
    params.mobility[iphin, ireg]                    = mun
    params.mobility[iphip, ireg]                    = mup

    # recombination parameters
    params.recombinationRadiative[ireg]             = Radiative
    params.recombinationSRHLifetime[iphin, ireg]    = SRH_LifeTime
    params.recombinationSRHLifetime[iphip, ireg]    = SRH_LifeTime
    params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity
    params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity
    params.recombinationAuger[iphin, ireg]          = Auger
    params.recombinationAuger[iphip, ireg]          = Auger

end

# doping
params.doping[iphin, regionDonor]                   = Nd
params.doping[iphin, regionIntrinsic]               = ni
params.doping[iphip, regionIntrinsic]               = 0.0
params.doping[iphip, regionAcceptor]                = Na

# Initialize a ChargeTransport struct
data.params   = params
ctsys         = System(grid, data, unknown_storage=unknown_storage)</code></pre><h3 id="Step-3:-Solve-the-problem-in-equilibrium"><a class="docs-heading-anchor" href="#Step-3:-Solve-the-problem-in-equilibrium">Step 3: Solve the problem in equilibrium</a><a id="Step-3:-Solve-the-problem-in-equilibrium-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Solve-the-problem-in-equilibrium" title="Permalink"></a></h3><p>Solve the equilibrium. Note that <code>control</code> refers to the SolverControl parameters given in <code>VoronoiFVM</code>.</p><pre><code class="language-julia hljs">solution = equilibrium_solve!(ctsys, control = control)
inival   = solution</code></pre><h3 id="Step-4:-Solve-the-problem-for-an-applied-bias"><a class="docs-heading-anchor" href="#Step-4:-Solve-the-problem-for-an-applied-bias">Step 4: Solve the problem for an applied bias</a><a id="Step-4:-Solve-the-problem-for-an-applied-bias-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Solve-the-problem-for-an-applied-bias" title="Permalink"></a></h3><p>Starting from the equilibrium solution, we increase the applied voltage.</p><pre><code class="language-julia hljs">maxBias    = voltageAcceptor # bias at acceptor boundary
biasValues = range(0, stop = maxBias, length = 32)

for Δu in biasValues
    set_contact!(ctsys, bregionAcceptor, Δu = Δu) # non equilibrium bc
    solution  = solve(ctsys; inival = inival, control = control)
    inival   .= solution
end</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To be consistent with the latest changes of VoronoiFVM, please do not use the solve!() function anymore. Otherwise, you will get deprecation warnings.</p></div></div><h3 id="Step-5:-Postprocessing"><a class="docs-heading-anchor" href="#Step-5:-Postprocessing">Step 5: Postprocessing</a><a id="Step-5:-Postprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-Postprocessing" title="Permalink"></a></h3><p>By adding the following line to the previous loop</p><pre><code class="language-julia hljs">current = get_current_val(ctsys, solution)</code></pre><p>we have the possibility to calculate the total current.</p><p>Moreover, there are several different plotting routines, see <a href="https://github.com/PatricioFarrell/ChargeTransport.jl/blob/master/src/ct_plotting.jl">ct_plotting.jl</a>.</p><h2 id="Example-2:-Stationary-1D-problem-(nodal-doping)"><a class="docs-heading-anchor" href="#Example-2:-Stationary-1D-problem-(nodal-doping)">Example 2: Stationary 1D problem (nodal doping)</a><a id="Example-2:-Stationary-1D-problem-(nodal-doping)-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Stationary-1D-problem-(nodal-doping)" title="Permalink"></a></h2><p>Now, instead of using regionwise doping it is possible to apply a nodal doping. (This is indeed also possible for other physical parameters, see the description of <a href="https://github.com/PatricioFarrell/ChargeTransport.jl/blob/ab0684293845859fb142ea69d786a88b597a8b67/src/ct_system.jl#L426">ParamsNodal</a>.) For this, go to previous Step 2, where you build your parameter set and adjust the doping initialization (code snippet is from <a href="https://github.com/PatricioFarrell/ChargeTransport.jl/blob/master/examples/Ex102_PIN_nodal_doping.jl">this example</a>)</p><pre><code class="language-julia hljs">paramsnodal = ParamsNodal(grid, numberOfCarriers)

# initialize the space dependent doping
NDoping = 1.0e17  / cm^3; κ = 500.0
for icoord = 1:numberOfNodes
    t1 = tanh( (0.1 - coord[icoord]/μm) *κ )
    t2 = 1.0 + tanh( (coord[icoord]/μm - 0.2) * κ )
    paramsnodal.doping[icoord] = NDoping * 0.5 * ( 1.0  +  t1  - t2 )
end

data.paramsnodal  = paramsnodal</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../GeneralInformation/">« Code overview</a><a class="docs-footer-nextpage" href="../PSC/">Perovskite solar cell »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 4 December 2023 14:41">Monday 4 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
