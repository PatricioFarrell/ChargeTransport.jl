<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Electronic Charge Carriers · ChargeTransportInSolids.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../general/">ChargeTransportInSolids.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../general/">ChargeTransportInSolids.jl – A drift-diffusion solver</a></li><li><a class="tocitem" href="../../backgroundinfo/">Mathematical Description of the Problem</a></li><li><span class="tocitem">Some Applications</span><ul><li><a class="tocitem" href="../../GeneralInformation/">General Information on Code Structure</a></li><li class="is-active"><a class="tocitem" href>Electronic Charge Carriers</a><ul class="internal"><li><a class="tocitem" href="#Example-1:-Solving-the-Stationary-1D-Problem"><span>Example 1: Solving the Stationary 1D Problem</span></a></li><li><a class="tocitem" href="#Example-2:-Adding-a-Nodal-Dependent-Doping"><span>Example 2: Adding a Nodal Dependent Doping</span></a></li></ul></li><li><a class="tocitem" href="../PSC/">Electronic and Ionic Charge Carriers</a></li></ul></li><li><a class="tocitem" href="../../allindex/">Overview on Types and Constructors</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Some Applications</a></li><li class="is-active"><a href>Electronic Charge Carriers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Electronic Charge Carriers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Electronic-Charge-Carriers"><a class="docs-heading-anchor" href="#Electronic-Charge-Carriers">Electronic Charge Carriers</a><a id="Electronic-Charge-Carriers-1"></a><a class="docs-heading-anchor-permalink" href="#Electronic-Charge-Carriers" title="Permalink"></a></h1><p>In both of the following examples we solve a system of partial differential equations for the description of the current flow in a bipolar three layer device (also called van Roosbroeck system)</p><p class="math-container">\[\begin{aligned}
	- \nabla \cdot (\varepsilon_s \nabla \psi) &amp;= q \Big( (p(\psi, \varphi_p) - N_A ) - (n(\psi, \varphi_n) - N_D) \Big),\\
	q \partial_t n(\psi, \varphi_n) -\nabla \cdot \mathbf{j}_n &amp;= -qR(n,p), \\
	q \partial_t p(\psi, \varphi_p) + \nabla \cdot \mathbf{j}_p &amp;= -qR(n,p)
\end{aligned}\]</p><p>for a given applied voltage. The procedure will be the following</p><ol><li>Initialize grid information</li><li>Initialize model information</li><li>Solve the problem in equilibrium</li><li>Solve the problem for an applied bias </li></ol><h2 id="Example-1:-Solving-the-Stationary-1D-Problem"><a class="docs-heading-anchor" href="#Example-1:-Solving-the-Stationary-1D-Problem">Example 1: Solving the Stationary 1D Problem</a><a id="Example-1:-Solving-the-Stationary-1D-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Solving-the-Stationary-1D-Problem" title="Permalink"></a></h2><p>We consider a three layer GaAs p-i-n device in one dimension. Here, we discuss <a href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl/blob/master/examples/Example101_PIN.jl">Example101_PIN</a>.</p><h3 id="Step-1:-Declare-grid-information"><a class="docs-heading-anchor" href="#Step-1:-Declare-grid-information">Step 1: Declare grid information</a><a id="Step-1:-Declare-grid-information-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Declare-grid-information" title="Permalink"></a></h3><p>We have three layers and two external boundaries. We want to solve the system of equations on a uniform mesh with a local grid refinement. Within this part we assign the indices of subregions and boundaries and declare from where to where the subregions are defined.</p><pre><code class="language-julia hljs"># region numbers
regionAcceptor          = 1          # p doped region
regionIntrinsic         = 2          # intrinsic region
regionDonor             = 3          # n doped region
regions                 = [regionAcceptor, regionIntrinsic, regionDonor]
numberOfRegions         = length(regions)

# boundary region numbers
bregionAcceptor         = 1
bregionDonor            = 2
bregions                = [bregionAcceptor, bregionDonor]
numberOfBoundaryRegions = length(bregions)

# grid
refinementfactor        = 2^(n-1)
h_pdoping               = 2 * μm
h_intrinsic             = 2 * μm
h_ndoping               = 2 * μm
coord                   = initialize_pin_grid(refinementfactor,
                                             h_pdoping,
                                             h_intrinsic,
                                             h_ndoping)

grid                    = simplexgrid(coord)

# ExtendableGrids.cellmask! for defining the subregions and assigning region number
cellmask!(grid, [0.0 * μm],[h_pdoping], regionAcceptor)
cellmask!(grid, [h_pdoping],[h_pdoping + h_intrinsic], regionIntrinsic)
cellmask!(grid, [h_pdoping + h_intrinsic],[h_pdoping + h_intrinsic + h_ndoping], regionDonor)</code></pre><h3 id="Step-2:-Declare-model-information"><a class="docs-heading-anchor" href="#Step-2:-Declare-model-information">Step 2: Declare model information</a><a id="Step-2:-Declare-model-information-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Declare-model-information" title="Permalink"></a></h3><p>In this step, the indices of charge carriers need to be assigned. Automatically, the index numberOfCarriers  $ + 1 $ is set for the electric potential. Additionally, we can choose here between several other model information e.g. such as the underlying statistics function or the recombination model. The possible choices are denoted above the respective variable.</p><pre><code class="language-julia hljs"># set indices of the quasi Fermi potentials
iphin                    = 1 # electron quasi Fermi potential
iphip                    = 2 # hole quasi Fermi potential
numberOfCarriers         = 2

# initialize ChargeTransportData instance and fill in data
data                     = ChargeTransportData(grid, numberOfCarriers)

# Following variable declares, if we want to solve stationary or transient problem
data.model_type          = model_stationary

# Following choices are possible for F: Boltzmann, FermiDiracOneHalfBednarczyk,
# FermiDiracOneHalfTeSCA FermiDiracMinusOne, Blakemore
data.F                  .= Boltzmann

# Here, we need to specify which numbers are associated with electron and hole quasi Fermi
# potential. Further, the desired recombination processes can be chosen here. By default
# we use the stationary model for the SRH recombination.
data.bulk_recombination  = set_bulk_recombination(;iphin = iphin, iphip = iphip, 
                                                   bulk_recomb_Auger = true,
                                                   bulk_recomb_radiative = true,
                                                   bulk_recomb_SRH = true)

# Following choices are possible for boundary model: For contacts currently only ohmic_contact
# and schottky_contact are possible. For inner boundaries we have interface_model_none,
# interface_model_surface_recombination.
data.boundary_type[bregionAcceptor] = ohmic_contact                       
data.boundary_type[bregionDonor]    = ohmic_contact   
    
# Following choices are possible for the flux_discretization scheme: scharfetter_gummel,
# scharfetter_gummel_graded, excess_chemical_potential, excess_chemical_potential_graded,
# diffusion_enhanced, generalized_sg
data.flux_approximation             = excess_chemical_potential</code></pre><p>Lastly, you are filling in your previously defined or externally read in parameter values.</p><pre><code class="language-julia hljs"># Params is a struct which contains all necessary physical parameters. If one wants to
# simulate space-dependent variable, one additionally needs to generate a ParamsNodal
# struct, see Example102.
params                                              = ChargeTransportParams(grid,
                                                                            numberOfCarriers)

params.temperature                                  = T
params.UT                                           = (kB * params.temperature) / q
params.chargeNumbers[iphin]                         = -1
params.chargeNumbers[iphip]                         =  1

for ibreg in 1:numberOfBoundaryRegions   # boundary region data

    params.bDensityOfStates[iphin, ibreg]           = Nc
    params.bDensityOfStates[iphip, ibreg]           = Nv
    params.bBandEdgeEnergy[iphin, ibreg]            = Ec
    params.bBandEdgeEnergy[iphip, ibreg]            = Ev
end

for ireg in 1:numberOfRegions           # interior region data

    params.dielectricConstant[ireg]                 = εr

    # effective DOS, band-edge energy and mobilities
    params.densityOfStates[iphin, ireg]             = Nc
    params.densityOfStates[iphip, ireg]             = Nv
    params.bandEdgeEnergy[iphin, ireg]              = Ec
    params.bandEdgeEnergy[iphip, ireg]              = Ev
    params.mobility[iphin, ireg]                    = mun
    params.mobility[iphip, ireg]                    = mup

    # recombination parameters
    params.recombinationRadiative[ireg]             = Radiative
    params.recombinationSRHLifetime[iphin, ireg]    = SRH_LifeTime
    params.recombinationSRHLifetime[iphip, ireg]    = SRH_LifeTime
    params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity
    params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity
    params.recombinationAuger[iphin, ireg]          = Auger
    params.recombinationAuger[iphip, ireg]          = Auger

end

# interior doping
params.doping[iphin, regionDonor]                   = Nd   
params.doping[iphin, regionIntrinsic]               = ni    
params.doping[iphip, regionIntrinsic]               = 0.0     
params.doping[iphip, regionAcceptor]                = Na

# boundary doping
params.bDoping[iphin, bregionDonor]                 = Nd     
params.bDoping[iphip, bregionAcceptor]              = Na 

# Region dependent params is now a substruct of data which is again a substruct of the
# system and will be parsed in next step.
data.params                                         = params

# in the last step, we initialize our system with previous data which is likewise dependent
# on the parameters. Important that this is in the end, otherwise our VoronoiFVMSys is
# not dependent on the data we initialized but rather on default data.
ctsys                                               = ChargeTransportSystem(grid, data, 
                                                            unknown_storage=unknown_storage)</code></pre><p>For this system we apply ohmic contacts. For the equilibrium calculations the applied voltage is zero.</p><pre><code class="language-julia hljs">set_ohmic_contact!(ctsys, bregionAcceptor, 0.0)
set_ohmic_contact!(ctsys, bregionDonor, 0.0)</code></pre><h3 id="Step-3:-Solve-for-equilibrium-solution"><a class="docs-heading-anchor" href="#Step-3:-Solve-for-equilibrium-solution">Step 3: Solve for equilibrium solution</a><a id="Step-3:-Solve-for-equilibrium-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Solve-for-equilibrium-solution" title="Permalink"></a></h3><p>With this call, the equilibrium solution will be calculated. Note that control refers to the Newton control parameters and is a struct within VoronoiFVM.</p><pre><code class="language-julia hljs">solution         = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)
initialGuess    .= solution </code></pre><h3 id="Step-4:-Solve-the-stationary-model-with-varying-applied-voltage"><a class="docs-heading-anchor" href="#Step-4:-Solve-the-stationary-model-with-varying-applied-voltage">Step 4: Solve the stationary model with varying applied voltage</a><a id="Step-4:-Solve-the-stationary-model-with-varying-applied-voltage-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Solve-the-stationary-model-with-varying-applied-voltage" title="Permalink"></a></h3><p>Now, we increase the applied voltage, which is incorporated to the model by the quasi Fermi potential boundary conditions, and solve the underlying problem for each new set of boundary conditions. Note that it is important to mark that we are now in outOfEqulibrium calculations.</p><pre><code class="language-julia hljs">ctsys.data.calculation_type  = outOfEquilibrium
maxBias                      = voltageAcceptor # bias goes until the given contactVoltage at acceptor boundary
biasValues                   = range(0, stop = maxBias, length = 32)

for Δu in biasValues

    # set non equilibrium boundary conditions
    set_ohmic_contact!(ctsys, bregionAcceptor, Δu)

    solve!(solution, initialGuess, ctsys, control = control, tstep = Inf)

    initialGuess .= solution

end # bias loop</code></pre><h3 id="Step-5:-Postprocessing"><a class="docs-heading-anchor" href="#Step-5:-Postprocessing">Step 5: Postprocessing</a><a id="Step-5:-Postprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-Postprocessing" title="Permalink"></a></h3><p>By adding the following line to the previous loop</p><pre><code class="language-julia hljs"># get I-V data
current = get_current_val(ctsys, solution)</code></pre><p>we have the possibility to calculate the total current.</p><p>Further, there are several different plotting routines which help to assess the quality of the numerical solution, see <a href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl/blob/master/src/ct_plotting.jl">ct_plotting.jl</a>.</p><h2 id="Example-2:-Adding-a-Nodal-Dependent-Doping"><a class="docs-heading-anchor" href="#Example-2:-Adding-a-Nodal-Dependent-Doping">Example 2: Adding a Nodal Dependent Doping</a><a id="Example-2:-Adding-a-Nodal-Dependent-Doping-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Adding-a-Nodal-Dependent-Doping" title="Permalink"></a></h2><p>Now, instead of applying a region dependent doping it is possible to apply a nodal dependent one. (This is indeed also possible for other quantities, see the description of <a href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl/blob/ab0684293845859fb142ea69d786a88b597a8b67/src/ct_system.jl#L426">ChargeTransportParamsNodal</a>.) For this, go to previous Step 2, where you build your parameter set and adjust the doping initialization (code snippet from <a href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl/blob/master/examples/Example102_PIN_nodal_doping.jl">Example102_PIN_nodal_doping.jl</a>)</p><pre><code class="language-julia hljs">paramsnodal  = ChargeTransportParamsNodal(grid, numberOfCarriers)

# initialize the space dependent doping
NDoping           =   1.0e17  / cm^3
κ = 500.0
for icoord = 1:numberOfNodes
    paramsnodal.doping[icoord] = NDoping * 0.5 * ( 1.0  +  tanh( (0.1 - coord[icoord]/μm) *κ )  - ( 1.0 + tanh( (coord[icoord]/μm - 0.2) * κ )) )
end

# parse the substruct containg the nodal dependent parameters to the struct data
data.paramsnodal  = paramsnodal</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../GeneralInformation/">« General Information on Code Structure</a><a class="docs-footer-nextpage" href="../PSC/">Electronic and Ionic Charge Carriers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 2 December 2021 17:21">Thursday 2 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
