<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Electronic and Ionic Charge Carriers · ChargeTransportInSolids.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../general/">ChargeTransportInSolids.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../general/">ChargeTransportInSolids.jl – A drift-diffusion solver</a></li><li><a class="tocitem" href="../../backgroundinfo/">Mathematical Description of the Problem</a></li><li><span class="tocitem">Some Applications</span><ul><li><a class="tocitem" href="../../GeneralInformation/">General Information on Code Structure</a></li><li><a class="tocitem" href="../GaAs/">Electronic Charge Carriers</a></li><li class="is-active"><a class="tocitem" href>Electronic and Ionic Charge Carriers</a><ul class="internal"><li><a class="tocitem" href="#Example-1:-Solving-the-Stationary-Problem-with-Graded-Interfaces"><span>Example 1: Solving the Stationary Problem with Graded Interfaces</span></a></li><li><a class="tocitem" href="#Example-2:-A-Linear-I-V-Measurement-Scan-Protocol"><span>Example 2: A Linear I-V Measurement Scan Protocol</span></a></li><li><a class="tocitem" href="#Example-3:-Perovskite-Solar-Cell-under-I-V-Scan-Protocol-and-Illumination"><span>Example 3: Perovskite Solar Cell under I-V Scan Protocol and Illumination</span></a></li><li><a class="tocitem" href="#Example-4:-Solving-a-2D-Problem"><span>Example 4: Solving a 2D Problem</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../allindex/">Overview on Types and Constructors</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Some Applications</a></li><li class="is-active"><a href>Electronic and Ionic Charge Carriers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Electronic and Ionic Charge Carriers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Electronic-and-Ionic-Charge-Carriers"><a class="docs-heading-anchor" href="#Electronic-and-Ionic-Charge-Carriers">Electronic and Ionic Charge Carriers</a><a id="Electronic-and-Ionic-Charge-Carriers-1"></a><a class="docs-heading-anchor-permalink" href="#Electronic-and-Ionic-Charge-Carriers" title="Permalink"></a></h1><p>In the following examples we will pay attention to specific types of drift-diffusion models for the description of the charge transport in perovskite solar cells, where we have electric and ionic charge carriers. Here, we assume to have three domains, denoted by  <span>$\mathbf{\Omega} = \mathbf{\Omega}_{\text{HTL}} \cup \mathbf{\Omega}_{\text{intr}} \cup \mathbf{\Omega}_{\text{ETL}}  $.  The considered unknowns are the quasi Fermi potentials of electrons, holes and anion vacancies  $\varphi_n, \varphi_p, \varphi_a$</span>  and the electric potential  <span>$\psi$</span>. The underlying PDE reads, see <a href="https://www.sciencedirect.com/science/article/abs/pii/S0013468621009865">Abdel2021</a></p><p class="math-container">\[\begin{aligned}
	- \nabla \cdot (\varepsilon_s \nabla \psi) &amp;= q \Big( (p(\psi, \varphi_p) - N_A ) - (n(\psi, \varphi_n) - N_D) \Big),\\
	q \partial_t n(\psi, \varphi_n) - \nabla \cdot \mathbf{j}_n &amp;= q\Bigl(G(\mathbf{x}) - R(n,p) \Bigr), \\
	q partial_t p(\psi, \varphi_p) + \nabla \cdot \mathbf{j}_p &amp;= \Bigl(G(\mathbf{x}) - R(n,p) \Bigr),
\end{aligned}\]</p><p>for  <span>$\mathbf{x} \in \mathbf{\Omega}_{\text{HTL}} \cup  \mathbf{\Omega}_{\text{ETL}} $, $[0, t_F]$</span> and for <span>$\mathbf{x} \in \mathbf{\Omega}_{\text{intr}} $, $[0, t_F]$</span> we have </p><p class="math-container">\[\begin{aligned}
	- \nabla \cdot (\varepsilon_s \nabla \psi) &amp;= q \Big( p(\psi, \varphi_p)  - n(\psi, \varphi_n) + a(\psi, \varphi_a) - C_0 \Big),\\
q \partial_t n(\psi, \varphi_n)	- \nabla \cdot \mathbf{j}_n &amp;= \Bigl(G(\mathbf{x}) - R(n,p) \Bigr), \\
	q \partial_t p(\psi, \varphi_p) + \nabla \cdot \mathbf{j}_p &amp;= \Bigl(G(\mathbf{x}) - R(n,p) \Bigr),\\
	q \partial_t a(\psi, \varphi_a) + \nabla \cdot \mathbf{j}_a &amp;= 0.
\end{aligned}\]</p><p><strong>General Information</strong> The extensions to the previous discussed simulation procedure in the previous example are the following</p><ul><li>another charge carrier, the anion vacancy, occurs (which is incorporated by the respective quasi Fermi potential)</li><li>we allow jumps within the parameters entering the state equation</li><li>the transient model is considered</li><li>we allow a generation <span>$G$</span> to be present</li></ul><p>A quick survey on how to use our solver to adjust the input parameters such that these features can be simulated will be given in the following.</p><h2 id="Example-1:-Solving-the-Stationary-Problem-with-Graded-Interfaces"><a class="docs-heading-anchor" href="#Example-1:-Solving-the-Stationary-Problem-with-Graded-Interfaces">Example 1: Solving the Stationary Problem with Graded Interfaces</a><a id="Example-1:-Solving-the-Stationary-Problem-with-Graded-Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Solving-the-Stationary-Problem-with-Graded-Interfaces" title="Permalink"></a></h2><p>We assume only electric charge carriers in this example. By default, we assume abrupt inner interfaces. If one wishes to simulate graded interfaces, where for example the effective density of states and the band-edge energy may vary, we refer to <a href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl/blob/master/examples/Example105_PSC_gradedFlux.jl">Example105</a> for more details.</p><p>First, we need to define two additional thin interface layers</p><pre><code class="language-julia hljs"># region numbers
regionDonor             = 1       # n doped region
regionJunction1         = 2
regionIntrinsic         = 3       # intrinsic region
regionJunction2         = 4
regionAcceptor          = 5       # p doped region</code></pre><p>which need to be taken into account by the initialization of the grid.</p><p>Second, since we allow varying parameters within the thin interface layers, the flux discretization scheme needs to be adjusted and we need to construct a nodal dependent parameter struct</p><pre><code class="language-julia hljs">data.flux_approximation = scharfetter_gummel_graded

paramsnodal             = ChargeTransportParamsNodal(grid, numberOfCarriers)</code></pre><p>Lastly, the respective parameters need to be graded. Currently, only a linear grading is implemented.</p><pre><code class="language-julia hljs">paramsnodal.bandEdgeEnergy[iphin, :]  = gradingParameter(paramsnodal.bandEdgeEnergy[iphin, :],
                                                        coord, regionTransportLayers, regionJunctions,
                                                        h, heightLayers, lengthLayers, EC)</code></pre><h2 id="Example-2:-A-Linear-I-V-Measurement-Scan-Protocol"><a class="docs-heading-anchor" href="#Example-2:-A-Linear-I-V-Measurement-Scan-Protocol">Example 2: A Linear I-V Measurement Scan Protocol</a><a id="Example-2:-A-Linear-I-V-Measurement-Scan-Protocol-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-A-Linear-I-V-Measurement-Scan-Protocol" title="Permalink"></a></h2><p>Here, the key parts of <a href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl/blob/master/examples/Example106_PSC_withIons_IVMeasurement.jl">Example106</a> are shortly summarized.</p><p>First, the charge carriers indices need to be extended since we assume here additional mobile anion vacancies</p><pre><code class="language-julia hljs">iphin                       = 2 # electron quasi Fermi potential
iphip                       = 1 # hole quasi Fermi potential
iphia                       = 3 # anion vacancy quasi Fermi potential
    
numberOfCarriers            = 3 # electrons, holes and anion vacancies</code></pre><p>Another change is the choice of model_type since we consider here the dynamic problem. Further, we need to enable the ionic charge carriers on the specific active layers.</p><pre><code class="language-julia hljs">data.model_type             = model_transient
data.enable_ionic_carriers  = enable_ionic_carriers(ionic_carriers = [iphia], regions = [regionIntrinsic])</code></pre><p>Arriving now at out of equilibrium calculations, we need to specify the scanrate and other information to set the time mesh. Currently, only linear scan protocols are predefined.</p><pre><code class="language-julia hljs"># primary data for I-V scan protocol
scanrate          = 1.0 * V/s
number_tsteps     = 31
endVoltage        = voltageAcceptor # bias goes until the given contactVoltage at acceptor boundary

# with fixed timestep sizes we can calculate the times
# a priori
tvalues           = set_time_mesh(scanrate, endVoltage, number_tsteps, type_protocol = linearScanProtocol)</code></pre><p>Lastly, the time loop needs to be performed. Note that within the solve! method, we need to specify the time step.</p><pre><code class="language-julia hljs">for istep = 2:number_tsteps
        
    t             = tvalues[istep]       # Actual time
    Δu            = t * scanrate         # Applied voltage 
    Δt            = t - tvalues[istep-1] # Time step size
        
    # Apply new voltage
    # set non equilibrium boundary conditions
    set_ohmic_contact!(ctsys, bregionAcceptor, Δu)

    # Solve time step problems with timestep Δt. initialGuess plays the role of the solution
    # from last timestep
    solve!(solution, initialGuess, ctsys, control  = control, tstep = Δt)


    initialGuess .= solution

end # time loop</code></pre><h2 id="Example-3:-Perovskite-Solar-Cell-under-I-V-Scan-Protocol-and-Illumination"><a class="docs-heading-anchor" href="#Example-3:-Perovskite-Solar-Cell-under-I-V-Scan-Protocol-and-Illumination">Example 3: Perovskite Solar Cell under I-V Scan Protocol and Illumination</a><a id="Example-3:-Perovskite-Solar-Cell-under-I-V-Scan-Protocol-and-Illumination-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Perovskite-Solar-Cell-under-I-V-Scan-Protocol-and-Illumination" title="Permalink"></a></h2><p>Now, we can add to the previous calculation an illumination protocol. For this one needs to add</p><pre><code class="language-julia hljs">data.generation_model    = generation_uniform</code></pre><p>and specify the uniform generation rate in each considered region, i.e.</p><pre><code class="language-julia hljs">for ireg in 1:numberOfRegions
    params.generationUniform[ireg]  = generationUniform[ireg]
end</code></pre><p>where the input data is stored in generationUniform. Note that as Beer-Lambert generation is implemented, but yet not well-tested. Further, we suggest to perform a time loop while increasing the generation rate and afterwards applying the scan protocol with a full generation due to numerical stability, see for this <a href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl/blob/master/examples/Example107_PSC_uniform_Generation.jl">Example107</a>.</p><h2 id="Example-4:-Solving-a-2D-Problem"><a class="docs-heading-anchor" href="#Example-4:-Solving-a-2D-Problem">Example 4: Solving a 2D Problem</a><a id="Example-4:-Solving-a-2D-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-Solving-a-2D-Problem" title="Permalink"></a></h2><p>Lastly, the code is capable of doing multi-dimensional calculations.</p><p>For a 2D mesh it is possible to use a structured grid via <a href="https://github.com/j-fu/ExtendableGrids.jl">ExtendableGrids.jl</a>, for this see <a href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl/blob/master/examples/Example108_PSC_2D_tensorGrid.jl">Example108</a>. But it is also possible to use the Julia wrapper <a href="https://github.com/JuliaGeometry/Triangulate.jl">Triangulate.jl</a> to use Jonathan Richard Shewchuk&#39;s Triangle mesh generator, see <a href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl/blob/master/examples/Example201_PSC_2D_unstructuredGrid.jl">Example201 for the simulation on a rectangular grid</a> or <a href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl/blob/master/examples/Example201_2D_non_rectangularGrid.jl">Example201 for a non-rectangular one</a>.</p><p>Lastly, with help of the <a href="https://github.com/JuliaGeometry/TetGen.jl">TetGen.jl</a> wrapper, three dimensional meshes can be generated, see <a href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl/blob/master/examples/Example202_3D_grid.jl">Example202</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../GaAs/">« Electronic Charge Carriers</a><a class="docs-footer-nextpage" href="../../allindex/">Overview on Types and Constructors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 2 December 2021 17:21">Thursday 2 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
