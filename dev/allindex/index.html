<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview on Types and Constructors · ChargeTransportInSolids.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../general/">ChargeTransportInSolids.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../general/">ChargeTransportInSolids.jl – A drift-diffusion solver</a></li><li><a class="tocitem" href="../backgroundinfo/">Mathematical Description of the Problem</a></li><li><span class="tocitem">Some Applications</span><ul><li><a class="tocitem" href="../GeneralInformation/">General Information on Code Structure</a></li><li><a class="tocitem" href="../examples/GaAs/">Electronic Charge Carriers</a></li><li><a class="tocitem" href="../examples/PSC/">Electronic and Ionic Charge Carriers</a></li></ul></li><li class="is-active"><a class="tocitem" href>Overview on Types and Constructors</a><ul class="internal"><li><a class="tocitem" href="#Types-and-Constructors"><span>Types and Constructors</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li><li class="toplevel"><a class="tocitem" href="#Description-of-Types,-Constructors-and-Methods"><span>Description of Types, Constructors and Methods</span></a></li><li><a class="tocitem" href="#Types-and-Constructors-2"><span>Types and Constructors</span></a></li><li><a class="tocitem" href="#Methods-2"><span>Methods</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Overview on Types and Constructors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overview on Types and Constructors</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Overview-–-Types,-Constructors-and-Methods"><a class="docs-heading-anchor" href="#Overview-–-Types,-Constructors-and-Methods">Overview – Types, Constructors and Methods</a><a id="Overview-–-Types,-Constructors-and-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-–-Types,-Constructors-and-Methods" title="Permalink"></a></h1><h2 id="Types-and-Constructors"><a class="docs-heading-anchor" href="#Types-and-Constructors">Types and Constructors</a><a id="Types-and-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-Constructors" title="Permalink"></a></h2><ul><li><a href="#ChargeTransportInSolids.ChargeTransportBulkRecombination"><code>ChargeTransportInSolids.ChargeTransportBulkRecombination</code></a></li><li><a href="#ChargeTransportInSolids.ChargeTransportData"><code>ChargeTransportInSolids.ChargeTransportData</code></a></li><li><a href="#ChargeTransportInSolids.ChargeTransportData-Tuple{Any, Any}"><code>ChargeTransportInSolids.ChargeTransportData</code></a></li><li><a href="#ChargeTransportInSolids.ChargeTransportIonicChargeCarriers"><code>ChargeTransportInSolids.ChargeTransportIonicChargeCarriers</code></a></li><li><a href="#ChargeTransportInSolids.ChargeTransportParams-Tuple{Any, Any}"><code>ChargeTransportInSolids.ChargeTransportParams</code></a></li><li><a href="#ChargeTransportInSolids.ChargeTransportParams"><code>ChargeTransportInSolids.ChargeTransportParams</code></a></li><li><a href="#ChargeTransportInSolids.ChargeTransportParamsNodal"><code>ChargeTransportInSolids.ChargeTransportParamsNodal</code></a></li><li><a href="#ChargeTransportInSolids.ChargeTransportParamsNodal-Tuple{Any, Any}"><code>ChargeTransportInSolids.ChargeTransportParamsNodal</code></a></li><li><a href="#ChargeTransportInSolids.ChargeTransportSystem-Tuple{Any, Any}"><code>ChargeTransportInSolids.ChargeTransportSystem</code></a></li><li><a href="#ChargeTransportInSolids.ChargeTransportSystem"><code>ChargeTransportInSolids.ChargeTransportSystem</code></a></li><li><a href="#ChargeTransportInSolids.ChargeTransportTraps"><code>ChargeTransportInSolids.ChargeTransportTraps</code></a></li><li><a href="#ChargeTransportInSolids.abstract_model_SRH"><code>ChargeTransportInSolids.abstract_model_SRH</code></a></li><li><a href="#ChargeTransportInSolids.boundary_model"><code>ChargeTransportInSolids.boundary_model</code></a></li><li><a href="#ChargeTransportInSolids.calculation_type"><code>ChargeTransportInSolids.calculation_type</code></a></li><li><a href="#ChargeTransportInSolids.diffusion_enhanced"><code>ChargeTransportInSolids.diffusion_enhanced</code></a></li><li><a href="#ChargeTransportInSolids.excess_chemical_potential"><code>ChargeTransportInSolids.excess_chemical_potential</code></a></li><li><a href="#ChargeTransportInSolids.excess_chemical_potential_graded"><code>ChargeTransportInSolids.excess_chemical_potential_graded</code></a></li><li><a href="#ChargeTransportInSolids.flux_approximation"><code>ChargeTransportInSolids.flux_approximation</code></a></li><li><a href="#ChargeTransportInSolids.generalized_sg"><code>ChargeTransportInSolids.generalized_sg</code></a></li><li><a href="#ChargeTransportInSolids.generation_beer_lambert"><code>ChargeTransportInSolids.generation_beer_lambert</code></a></li><li><a href="#ChargeTransportInSolids.generation_model"><code>ChargeTransportInSolids.generation_model</code></a></li><li><a href="#ChargeTransportInSolids.generation_none"><code>ChargeTransportInSolids.generation_none</code></a></li><li><a href="#ChargeTransportInSolids.generation_uniform"><code>ChargeTransportInSolids.generation_uniform</code></a></li><li><a href="#ChargeTransportInSolids.inEquilibrium"><code>ChargeTransportInSolids.inEquilibrium</code></a></li><li><a href="#ChargeTransportInSolids.interface_model"><code>ChargeTransportInSolids.interface_model</code></a></li><li><a href="#ChargeTransportInSolids.interface_model_discont_qF"><code>ChargeTransportInSolids.interface_model_discont_qF</code></a></li><li><a href="#ChargeTransportInSolids.interface_model_ion_charge"><code>ChargeTransportInSolids.interface_model_ion_charge</code></a></li><li><a href="#ChargeTransportInSolids.interface_model_none"><code>ChargeTransportInSolids.interface_model_none</code></a></li><li><a href="#ChargeTransportInSolids.interface_model_surface_recombination"><code>ChargeTransportInSolids.interface_model_surface_recombination</code></a></li><li><a href="#ChargeTransportInSolids.linearScanProtocol"><code>ChargeTransportInSolids.linearScanProtocol</code></a></li><li><a href="#ChargeTransportInSolids.model_SRH"><code>ChargeTransportInSolids.model_SRH</code></a></li><li><a href="#ChargeTransportInSolids.model_SRH_2species_present_trap_dens"><code>ChargeTransportInSolids.model_SRH_2species_present_trap_dens</code></a></li><li><a href="#ChargeTransportInSolids.model_SRH_with_traps"><code>ChargeTransportInSolids.model_SRH_with_traps</code></a></li><li><a href="#ChargeTransportInSolids.model_SRH_without_traps"><code>ChargeTransportInSolids.model_SRH_without_traps</code></a></li><li><a href="#ChargeTransportInSolids.model_stationary"><code>ChargeTransportInSolids.model_stationary</code></a></li><li><a href="#ChargeTransportInSolids.model_transient"><code>ChargeTransportInSolids.model_transient</code></a></li><li><a href="#ChargeTransportInSolids.model_type"><code>ChargeTransportInSolids.model_type</code></a></li><li><a href="#ChargeTransportInSolids.ohmic_contact"><code>ChargeTransportInSolids.ohmic_contact</code></a></li><li><a href="#ChargeTransportInSolids.outOfEquilibrium"><code>ChargeTransportInSolids.outOfEquilibrium</code></a></li><li><a href="#ChargeTransportInSolids.scan_protocol_type"><code>ChargeTransportInSolids.scan_protocol_type</code></a></li><li><a href="#ChargeTransportInSolids.scharfetter_gummel"><code>ChargeTransportInSolids.scharfetter_gummel</code></a></li><li><a href="#ChargeTransportInSolids.scharfetter_gummel_graded"><code>ChargeTransportInSolids.scharfetter_gummel_graded</code></a></li><li><a href="#ChargeTransportInSolids.schottky_contact"><code>ChargeTransportInSolids.schottky_contact</code></a></li></ul><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><ul><li><a href="#ChargeTransportInSolids.Blakemore-Tuple{Real, Real}"><code>ChargeTransportInSolids.Blakemore</code></a></li><li><a href="#ChargeTransportInSolids.Blakemore-Tuple{Real}"><code>ChargeTransportInSolids.Blakemore</code></a></li><li><a href="#ChargeTransportInSolids.Boltzmann-Tuple{Real}"><code>ChargeTransportInSolids.Boltzmann</code></a></li><li><a href="#ChargeTransportInSolids.FermiDiracMinusOne-Tuple{Real}"><code>ChargeTransportInSolids.FermiDiracMinusOne</code></a></li><li><a href="#ChargeTransportInSolids.FermiDiracOneHalfBednarczyk-Tuple{Real}"><code>ChargeTransportInSolids.FermiDiracOneHalfBednarczyk</code></a></li><li><a href="#ChargeTransportInSolids.FermiDiracOneHalfTeSCA-Tuple{Real}"><code>ChargeTransportInSolids.FermiDiracOneHalfTeSCA</code></a></li><li><a href="#ChargeTransportInSolids.addChargeCarriers!-NTuple{9, Any}"><code>ChargeTransportInSolids.addChargeCarriers!</code></a></li><li><a href="#ChargeTransportInSolids.addElectricPotential!-NTuple{5, Any}"><code>ChargeTransportInSolids.addElectricPotential!</code></a></li><li><a href="#ChargeTransportInSolids.addTrapDensity!-NTuple{9, Any}"><code>ChargeTransportInSolids.addTrapDensity!</code></a></li><li><a href="#ChargeTransportInSolids.bflux!-Tuple{Any, Any, Any, Any, Type{excess_chemical_potential}}"><code>ChargeTransportInSolids.bflux!</code></a></li><li><a href="#ChargeTransportInSolids.bflux!-NTuple{4, Any}"><code>ChargeTransportInSolids.bflux!</code></a></li><li><a href="#ChargeTransportInSolids.breaction!-Tuple{Any, Any, Any, Any, Type{interface_model_none}}"><code>ChargeTransportInSolids.breaction!</code></a></li><li><a href="#ChargeTransportInSolids.breaction!-Tuple{Any, Any, Any, Any, Type{ohmic_contact}}"><code>ChargeTransportInSolids.breaction!</code></a></li><li><a href="#ChargeTransportInSolids.breaction!-Tuple{Any, Any, Any, Any, Type{schottky_contact}}"><code>ChargeTransportInSolids.breaction!</code></a></li><li><a href="#ChargeTransportInSolids.breaction!-NTuple{4, Any}"><code>ChargeTransportInSolids.breaction!</code></a></li><li><a href="#ChargeTransportInSolids.bstorage!-Tuple{Any, Any, Any, Any, Type{interface_model_discont_qF}}"><code>ChargeTransportInSolids.bstorage!</code></a></li><li><a href="#ChargeTransportInSolids.bstorage!-Tuple{Any, Any, Any, Any, Type{ohmic_contact}}"><code>ChargeTransportInSolids.bstorage!</code></a></li><li><a href="#ChargeTransportInSolids.bstorage!-NTuple{4, Any}"><code>ChargeTransportInSolids.bstorage!</code></a></li><li><a href="#ChargeTransportInSolids.build_system-Tuple{Any, Any, Any, Type{interface_model_discont_qF}}"><code>ChargeTransportInSolids.build_system</code></a></li><li><a href="#ChargeTransportInSolids.build_system-Tuple{Any, Any, Any, Type{interface_model_none}}"><code>ChargeTransportInSolids.build_system</code></a></li><li><a href="#ChargeTransportInSolids.chargeDensity-Tuple{Any, Any}"><code>ChargeTransportInSolids.chargeDensity</code></a></li><li><a href="#ChargeTransportInSolids.chargeDensity-NTuple{8, Any}"><code>ChargeTransportInSolids.chargeDensity</code></a></li><li><a href="#ChargeTransportInSolids.compute_densities!-Tuple{Any, Any, Any}"><code>ChargeTransportInSolids.compute_densities!</code></a></li><li><a href="#ChargeTransportInSolids.compute_densities!-Tuple{Any, Any, Any, Any, Any, Any, Bool}"><code>ChargeTransportInSolids.compute_densities!</code></a></li><li><a href="#ChargeTransportInSolids.compute_energies!-Tuple{Any, Any, Any}"><code>ChargeTransportInSolids.compute_energies!</code></a></li><li><a href="#ChargeTransportInSolids.degenerateLimit-Tuple{Any}"><code>ChargeTransportInSolids.degenerateLimit</code></a></li><li><a href="#ChargeTransportInSolids.electroNeutralSolution!-Tuple{Any, Any}"><code>ChargeTransportInSolids.electroNeutralSolution!</code></a></li><li><a href="#ChargeTransportInSolids.electrochemicalReaction-NTuple{10, Any}"><code>ChargeTransportInSolids.electrochemicalReaction</code></a></li><li><a href="#ChargeTransportInSolids.enable_ionic_carriers-Tuple{}"><code>ChargeTransportInSolids.enable_ionic_carriers</code></a></li><li><a href="#ChargeTransportInSolids.enable_traps!-Tuple{Any}"><code>ChargeTransportInSolids.enable_traps!</code></a></li><li><a href="#ChargeTransportInSolids.enable_traps!-Tuple{}"><code>ChargeTransportInSolids.enable_traps!</code></a></li><li><a href="#ChargeTransportInSolids.etaFunction-Tuple{Any, Any, Any, Any, Any, Any, Bool}"><code>ChargeTransportInSolids.etaFunction</code></a></li><li><a href="#ChargeTransportInSolids.etaFunction-Tuple{Any, VoronoiFVM.Node, Any, Any, Any}"><code>ChargeTransportInSolids.etaFunction</code></a></li><li><a href="#ChargeTransportInSolids.etaFunction-NTuple{5, Any}"><code>ChargeTransportInSolids.etaFunction</code></a></li><li><a href="#ChargeTransportInSolids.etaFunction-Tuple{Any, VoronoiFVM.BNode, Any, Any, Any}"><code>ChargeTransportInSolids.etaFunction</code></a></li><li><a href="#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{scharfetter_gummel_graded}}"><code>ChargeTransportInSolids.flux!</code></a></li><li><a href="#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{generalized_sg}}"><code>ChargeTransportInSolids.flux!</code></a></li><li><a href="#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{excess_chemical_potential_graded}}"><code>ChargeTransportInSolids.flux!</code></a></li><li><a href="#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{excess_chemical_potential}}"><code>ChargeTransportInSolids.flux!</code></a></li><li><a href="#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{diffusion_enhanced}}"><code>ChargeTransportInSolids.flux!</code></a></li><li><a href="#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{scharfetter_gummel}}"><code>ChargeTransportInSolids.flux!</code></a></li><li><a href="#ChargeTransportInSolids.generation-Tuple{Any, Any, Any, Type{generation_uniform}}"><code>ChargeTransportInSolids.generation</code></a></li><li><a href="#ChargeTransportInSolids.generation-Tuple{Any, Any, Any, Type{generation_beer_lambert}}"><code>ChargeTransportInSolids.generation</code></a></li><li><a href="#ChargeTransportInSolids.get_BEE!-Tuple{Any, VoronoiFVM.BNode, Any}"><code>ChargeTransportInSolids.get_BEE!</code></a></li><li><a href="#ChargeTransportInSolids.get_BEE!-Tuple{Any, VoronoiFVM.Node, Any}"><code>ChargeTransportInSolids.get_BEE!</code></a></li><li><a href="#ChargeTransportInSolids.get_BEE!-Tuple{Any, VoronoiFVM.Edge, Any}"><code>ChargeTransportInSolids.get_BEE!</code></a></li><li><a href="#ChargeTransportInSolids.get_DOS!-Tuple{Any, VoronoiFVM.Edge, Any}"><code>ChargeTransportInSolids.get_DOS!</code></a></li><li><a href="#ChargeTransportInSolids.get_DOS!-Tuple{Any, VoronoiFVM.Node, Any}"><code>ChargeTransportInSolids.get_DOS!</code></a></li><li><a href="#ChargeTransportInSolids.get_DOS!-Tuple{Any, VoronoiFVM.BNode, Any}"><code>ChargeTransportInSolids.get_DOS!</code></a></li><li><a href="#ChargeTransportInSolids.get_current_val-Tuple{Any, Any}"><code>ChargeTransportInSolids.get_current_val</code></a></li><li><a href="#ChargeTransportInSolids.get_current_val-NTuple{4, Any}"><code>ChargeTransportInSolids.get_current_val</code></a></li><li><a href="#ChargeTransportInSolids.inner_interface_model-Tuple{ChargeTransportSystem}"><code>ChargeTransportInSolids.inner_interface_model</code></a></li><li><a href="#ChargeTransportInSolids.inner_interface_model-Tuple{ChargeTransportData}"><code>ChargeTransportInSolids.inner_interface_model</code></a></li><li><a href="#ChargeTransportInSolids.kernelSRH-Tuple{Any, Any, Any, Any, Any, Any, Type{model_SRH_off}}"><code>ChargeTransportInSolids.kernelSRH</code></a></li><li><a href="#ChargeTransportInSolids.kernelSRH-Tuple{Any, Any, Any, Any, Any, Any, Type{ChargeTransportInSolids.model_SRH_stationary}}"><code>ChargeTransportInSolids.kernelSRH</code></a></li><li><a href="#ChargeTransportInSolids.plotDiffusionEnhancements-Tuple{}"><code>ChargeTransportInSolids.plotDiffusionEnhancements</code></a></li><li><a href="#ChargeTransportInSolids.plotDistributions-Tuple{}"><code>ChargeTransportInSolids.plotDistributions</code></a></li><li><a href="#ChargeTransportInSolids.plot_IV-NTuple{4, Any}"><code>ChargeTransportInSolids.plot_IV</code></a></li><li><a href="#ChargeTransportInSolids.plot_densities-NTuple{5, Any}"><code>ChargeTransportInSolids.plot_densities</code></a></li><li><a href="#ChargeTransportInSolids.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ChargeTransportData}"><code>ChargeTransportInSolids.plot_doping</code></a></li><li><a href="#ChargeTransportInSolids.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ChargeTransportParamsNodal}"><code>ChargeTransportInSolids.plot_doping</code></a></li><li><a href="#ChargeTransportInSolids.plot_electroNeutralSolutionBoltzmann-Tuple{Any, Any, Any}"><code>ChargeTransportInSolids.plot_electroNeutralSolutionBoltzmann</code></a></li><li><a href="#ChargeTransportInSolids.plot_energies-NTuple{5, Any}"><code>ChargeTransportInSolids.plot_energies</code></a></li><li><a href="#ChargeTransportInSolids.plot_energies-Tuple{Any, ExtendableGrids.ExtendableGrid, Any}"><code>ChargeTransportInSolids.plot_energies</code></a></li><li><a href="#ChargeTransportInSolids.plot_solution-NTuple{5, Any}"><code>ChargeTransportInSolids.plot_solution</code></a></li><li><a href="#ChargeTransportInSolids.printJacobi-Tuple{Any, Any}"><code>ChargeTransportInSolids.printJacobi</code></a></li><li><a href="#ChargeTransportInSolids.reaction!-Tuple{Any, Any, Any, Any, Type{inEquilibrium}}"><code>ChargeTransportInSolids.reaction!</code></a></li><li><a href="#ChargeTransportInSolids.reaction!-NTuple{4, Any}"><code>ChargeTransportInSolids.reaction!</code></a></li><li><a href="#ChargeTransportInSolids.reaction!-Tuple{Any, Any, Any, Any, Type{outOfEquilibrium}}"><code>ChargeTransportInSolids.reaction!</code></a></li><li><a href="#ChargeTransportInSolids.set_bulk_recombination-Tuple{}"><code>ChargeTransportInSolids.set_bulk_recombination</code></a></li><li><a href="#ChargeTransportInSolids.set_time_mesh-Tuple{Any, Any, Any}"><code>ChargeTransportInSolids.set_time_mesh</code></a></li><li><a href="#ChargeTransportInSolids.storage!-NTuple{4, Any}"><code>ChargeTransportInSolids.storage!</code></a></li><li><a href="#ChargeTransportInSolids.storage!-Tuple{Any, Any, Any, Any, Type{model_transient}}"><code>ChargeTransportInSolids.storage!</code></a></li><li><a href="#ChargeTransportInSolids.trap_density!-NTuple{4, Any}"><code>ChargeTransportInSolids.trap_density!</code></a></li></ul><h1 id="Description-of-Types,-Constructors-and-Methods"><a class="docs-heading-anchor" href="#Description-of-Types,-Constructors-and-Methods">Description of Types, Constructors and Methods</a><a id="Description-of-Types,-Constructors-and-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Description-of-Types,-Constructors-and-Methods" title="Permalink"></a></h1><h2 id="Types-and-Constructors-2"><a class="docs-heading-anchor" href="#Types-and-Constructors-2">Types and Constructors</a><a class="docs-heading-anchor-permalink" href="#Types-and-Constructors-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.ChargeTransportBulkRecombination" href="#ChargeTransportInSolids.ChargeTransportBulkRecombination"><code>ChargeTransportInSolids.ChargeTransportBulkRecombination</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ChargeTransportBulkRecombination</code></pre><p>A struct holding all information necessary for building bulk recombination. With help of this constructor we can read out the indices the user chooses for electron and hole quasi Fermi potentials.</p><ul><li><p><code>iphin::Int64</code></p><p>index for data construction of quasi Fermi potential of electrons</p></li></ul><ul><li><p><code>iphip::Int64</code></p><p>index for data construction of quasi Fermi potential of holes</p></li></ul><ul><li><p><code>bulk_recomb_Auger::Bool</code></p><p>boolean for present Auger recombination in bulk</p></li></ul><ul><li><p><code>bulk_recomb_radiative::Bool</code></p><p>boolean for present radiative recombination in bulk</p></li></ul><ul><li><p><code>bulk_recomb_SRH::DataType</code></p><p>DataType for present SRH recombination in bulk</p></li></ul><ul><li><p><code>model_SRH_2species_trap::DataType</code></p><p>Auxiliary quantitiy for simulations with present trap density in Poisson, but without traps as own unknowns. Note that this one may be deleted in future versions.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.ChargeTransportData" href="#ChargeTransportInSolids.ChargeTransportData"><code>ChargeTransportInSolids.ChargeTransportData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ChargeTransportData</code></pre><p>A struct holding all data information including model and numerics information, but also all physical parameters for a drift-diffusion simulation of a semiconductor device.</p><ul><li><p><code>F::Vector{Function}</code></p><p>An array with the corresponding distribution function <span>$\mathcal{F}_\alpha$</span> for all carriers <span>$\alpha$</span>.</p></li></ul><ul><li><p><code>boundary_type::Vector{DataType}</code></p><p>An array of DataTypes with the type of boundary model for each boundary (interior and exterior).</p></li></ul><ul><li><p><code>bulk_recombination::ChargeTransportBulkRecombination</code></p><p>A struct containing information concerning the bulk recombination model.</p></li></ul><ul><li><p><code>enable_ionic_carriers::ChargeTransportIonicChargeCarriers</code></p><p>A struct which contains information on the regions, where ionic charge carriers (ions and/or ion vacancies) are present.</p></li></ul><ul><li><p><code>enable_traps::ChargeTransportInSolids.ChargeTransportTraps</code></p><p>An AbstractVector which contains information on present SRH traps.</p></li></ul><ul><li><p><code>inner_interface_model::DataType</code></p><p>DataType which stores information about which inner interface model is chosen by user. This quantity cannot be seen by the user and is needed for the core of package.</p></li></ul><ul><li><p><code>flux_approximation::DataType</code></p><p>A DataType for the flux discretization method.</p></li></ul><ul><li><p><code>calculation_type::DataType</code></p><p>A DataType for equilibrium or out of equilibrium calculations.</p></li></ul><ul><li><p><code>model_type::DataType</code></p><p>A DataType for transient or stationary calculations.</p></li></ul><ul><li><p><code>generation_model::DataType</code></p><p>A DataType for for generation model.</p></li></ul><ul><li><p><code>λ1::Float64</code></p><p>An embedding parameter used to solve the nonlinear Poisson problem, which corresponds for λ1 = 0 to the case of thermodynamic equilibrium and electrocharge neutrality and for λ1 = 1 to the case of thermodynamic equilibrium.</p></li></ul><ul><li><p><code>λ2::Float64</code></p><p>An embedding parameter for turning the generation rate <span>$G$</span> on.</p></li></ul><ul><li><p><code>λ3::Float64</code></p><p>An embedding parameter for electrochemical reaction.</p></li></ul><ul><li><p><code>tempBEE1::Vector{Float64}</code></p><p>Within this template informations concerning the band-edge energy of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.</p></li></ul><ul><li><p><code>tempBEE2::Vector{Float64}</code></p><p>see the description of tempBEE1</p></li></ul><ul><li><p><code>tempDOS1::Vector{Float64}</code></p><p>Within this template informations concerning the effective DOS of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.</p></li></ul><ul><li><p><code>tempDOS2::Vector{Float64}</code></p><p>see the desciption of tempDOS2</p></li></ul><ul><li><p><code>isContinuous::Vector{Bool}</code></p><p>An array which contains information on whether charge carriers are continuous or discontinuous. This is needed for building the AbstractQuantities which handle the indices of charge carriers on different regions.</p></li></ul><ul><li><p><code>chargeCarrierList::Union{Vector{VoronoiFVM.AbstractQuantity}, Vector{Int64}}</code></p><p>This list stores all charge carriers. Here, we can have a vector holding all abstract quantities or a vector holding an integer array depending on the interface model and the the regularity of unknowns.</p></li></ul><ul><li><p><code>indexPsi::Union{Int64, VoronoiFVM.AbstractQuantity}</code></p><p>This variable stores the index of the electric potential. Based on the user choice we have with this new type the opportunity to simulate with Quantities or integer indices.</p></li></ul><ul><li><p><code>params::ChargeTransportParams</code></p><p>A struct holding all region dependent parameter information. For more information see struct ChargeTransportParams.</p></li></ul><ul><li><p><code>paramsnodal::ChargeTransportParamsNodal</code></p><p>A struct holding all space dependent parameter information. For more information see struct ChargeTransportParamsNodal.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.ChargeTransportData-Tuple{Any, Any}" href="#ChargeTransportInSolids.ChargeTransportData-Tuple{Any, Any}"><code>ChargeTransportInSolids.ChargeTransportData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ChargeTransportData(grid, numberOfCarriers) -&gt; ChargeTransportData
</code></pre><p>Simplified constructor for ChargeTransportData which only takes the grid and the numberOfCarriers as argument. Here, all necessary information including the physical parameters, but also some numerical information are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.ChargeTransportIonicChargeCarriers" href="#ChargeTransportInSolids.ChargeTransportIonicChargeCarriers"><code>ChargeTransportInSolids.ChargeTransportIonicChargeCarriers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ChargeTransportIonicChargeCarriers</code></pre><p>A struct holding all information necessary on the ionic charge carriers. With help of this constructor we can read out the indices the user chooses for ionic charge carrier quasi Fermi potentials and the respective regions in which they are defined. Note that it is possible to use ions as well as ion vacancies.</p><ul><li><p><code>ionic_carriers::Vector{Int64}</code></p><p>Array with the indices of ionic charge carriers.</p></li></ul><ul><li><p><code>regions::Vector{Int64}</code></p><p>Corresponding regions where ionic charge carriers are assumed to be present.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.ChargeTransportParams" href="#ChargeTransportInSolids.ChargeTransportParams"><code>ChargeTransportInSolids.ChargeTransportParams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ChargeTransportParams</code></pre><p>A struct holding the physical region dependent parameters for a drift-diffusion simulation of a semiconductor device.</p><ul><li><p><code>numberOfNodes::Int64</code></p><p>number of nodes used for the disretization of the domain <span>$\mathbf{\Omega}$</span>.</p></li></ul><ul><li><p><code>numberOfRegions::Int64</code></p><p>number of subregions <span>$\mathbf{\Omega}_k$</span> within the domain <span>$\mathbf{\Omega}$</span>.</p></li></ul><ul><li><p><code>numberOfBoundaryRegions::Int64</code></p><p>number of boundary regions <span>$(\partial \mathbf{\Omega})_k$</span> such that <span>$\partial \mathbf{\Omega} = \cup_k (\partial \mathbf{\Omega})_k$</span>.</p></li></ul><ul><li><p><code>numberOfCarriers::Int64</code></p><p>number of moving charge carriers.</p></li></ul><ul><li><p><code>numberOfInterfaceCarriers::Int64</code></p><p>number of present interface carriers which solely live on the boundary.</p></li></ul><ul><li><p><code>temperature::Float64</code></p><p>A given constant temperature.</p></li></ul><ul><li><p><code>UT::Float64</code></p><p>The thermal voltage, which reads  <span>$U_T = k_B T / q$</span>.</p></li></ul><ul><li><p><code>γ::Float64</code></p><p>The parameter of the Blakemore statistics.</p></li></ul><ul><li><p><code>r0::Float64</code></p><p>Prefactor of electro-chemical reaction of internal boundary conditions.</p></li></ul><ul><li><p><code>SchottkyBarrier::Vector{Float64}</code></p><p>An array for the given Schottky barriers at present Schotkky contacts.</p></li></ul><ul><li><p><code>chargeNumbers::Vector{Float64}</code></p><p>An array with the corresponding charge numbers <span>$z_\alpha$</span> for all carriers <span>$\alpha$</span>.</p></li></ul><ul><li><p><code>bBandEdgeEnergy::Matrix{Float64}</code></p><p>An array with the corresponding boundary band-edge energy values <span>$E_\alpha$</span> in each region for each carrier <span>$\alpha$</span>.</p></li></ul><ul><li><p><code>bDensityOfStates::Matrix{Float64}</code></p><p>An array with the corresponding boundary effective density of states values <span>$N_\alpha$</span> for each carrier <span>$\alpha$</span>.</p></li></ul><ul><li><p><code>bMobility::Matrix{Float64}</code></p><p>A 2D array with the corresponding boundary mobility values <span>$\mu_\alpha$</span> in each region for each carrier <span>$\alpha$</span>.</p></li></ul><ul><li><p><code>bDoping::Matrix{Float64}</code></p><p>A 2D array with the corresponding boundary doping values for each carrier <span>$\alpha$</span>.</p></li></ul><ul><li><p><code>bVelocity::Matrix{Float64}</code></p><p>A 2D array with the corresponding boundary velocity values for each carrier <span>$\alpha$</span>, when assuming Schottky contacts.</p></li></ul><ul><li><p><code>recombinationSRHvelocity::Matrix{Float64}</code></p><p>A 2D array with the corresponding recombination surface boundary velocity values for electrons and holes.</p></li></ul><ul><li><p><code>bRecombinationSRHTrapDensity::Matrix{Float64}</code></p><p>A 2D array with the corresponding recombination surface boundary density values for electrons and holes.</p></li></ul><ul><li><p><code>doping::Matrix{Float64}</code></p><p>A 2D array with the corresponding doping values for each carrier <span>$\alpha$</span> on each region.</p></li></ul><ul><li><p><code>densityOfStates::Matrix{Float64}</code></p><p>A 2D array with the corresponding effective density of states values <span>$N_\alpha$</span> for each carrier <span>$\alpha$</span> on each region.</p></li></ul><ul><li><p><code>bandEdgeEnergy::Matrix{Float64}</code></p><p>A 2D array with the corresponding band-edge energy values <span>$E_\alpha$</span> for each carrier <span>$\alpha$</span> on each region.</p></li></ul><ul><li><p><code>mobility::Matrix{Float64}</code></p><p>A 2D array with the corresponding mobility values <span>$\mu_\alpha$</span> for each carrier <span>$\alpha$</span> on each region.</p></li></ul><ul><li><p><code>recombinationSRHLifetime::Matrix{Float64}</code></p><p>A 2D array with the corresponding SRH lifetimes <span>$\tau_n, \tau_p$</span> for electrons and holes.</p></li></ul><ul><li><p><code>recombinationSRHTrapDensity::Matrix{Float64}</code></p><p>A 2D array with the corresponding SRH trap densities <span>$n_{\tau}, p_{\tau}$</span> for electrons and holes.</p></li></ul><ul><li><p><code>recombinationAuger::Matrix{Float64}</code></p><p>A 2D array with the corresponding Auger coefficients for electrons and holes.</p></li></ul><ul><li><p><code>dielectricConstant::Vector{Float64}</code></p><p>A region dependent dielectric constant.</p></li></ul><ul><li><p><code>generationIncidentPhotonFlux::Vector{Float64}</code></p><p>A region dependent array for the prefactor in the generation process which is the incident photon flux.</p></li></ul><ul><li><p><code>generationUniform::Vector{Float64}</code></p><p>A region dependent array for an uniform generation rate.</p></li></ul><ul><li><p><code>generationAbsorption::Vector{Float64}</code></p><p>A region dependent array for the absorption coefficient in the generation process.</p></li></ul><ul><li><p><code>recombinationRadiative::Vector{Float64}</code></p><p>A region dependent array for the radiative recombination rate.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.ChargeTransportParams-Tuple{Any, Any}" href="#ChargeTransportInSolids.ChargeTransportParams-Tuple{Any, Any}"><code>ChargeTransportInSolids.ChargeTransportParams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ChargeTransportParams(grid, numberOfCarriers) -&gt; ChargeTransportParams
</code></pre><p>Simplified constructor for ChargeTransportParams which only takes the grid and the numberOfCarriers as argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.ChargeTransportParamsNodal" href="#ChargeTransportInSolids.ChargeTransportParamsNodal"><code>ChargeTransportInSolids.ChargeTransportParamsNodal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ChargeTransportParamsNodal</code></pre><p>A struct holding the physical nodal, i.e. space-dependent parameters for a drift-diffusion simulation of a semiconductor device.</p><ul><li><p><code>dielectricConstant::Vector{Float64}</code></p><p>A node dependent dielectric constant.</p></li></ul><ul><li><p><code>doping::Vector{Float64}</code></p><p>A 1D array with the corresponding doping values on each node.</p></li></ul><ul><li><p><code>mobility::Matrix{Float64}</code></p><p>A 2D array with the corresponding mobility values <span>$\mu_\alpha$</span> for each carrier <span>$\alpha$</span> on each node.</p></li></ul><ul><li><p><code>densityOfStates::Matrix{Float64}</code></p><p>A 2D array with the corresponding effective density of states values <span>$N_\alpha$</span> for each carrier <span>$\alpha$</span> on each node.</p></li></ul><ul><li><p><code>bandEdgeEnergy::Matrix{Float64}</code></p><p>A 2D array with the corresponding band-edge energy values <span>$E_\alpha$</span> for each carrier <span>$\alpha$</span> on each node.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.ChargeTransportParamsNodal-Tuple{Any, Any}" href="#ChargeTransportInSolids.ChargeTransportParamsNodal-Tuple{Any, Any}"><code>ChargeTransportInSolids.ChargeTransportParamsNodal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ChargeTransportParamsNodal(grid, numberOfCarriers) -&gt; ChargeTransportParamsNodal
</code></pre><p>Simplified constructor for ChargeTransportParamsNodal which only takes the grid and the numberOfCarriers as argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.ChargeTransportSystem" href="#ChargeTransportInSolids.ChargeTransportSystem"><code>ChargeTransportInSolids.ChargeTransportSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ChargeTransportSystem</code></pre><p>A struct holding all information necessary for a drift-diffusion type system.</p><ul><li><p><code>data::ChargeTransportData</code></p><p>A struct holding all data information, see ChargeTransportData</p></li></ul><ul><li><p><code>fvmsys::VoronoiFVM.AbstractSystem</code></p><p>A struct holding system information for the finite volume system.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.ChargeTransportSystem-Tuple{Any, Any}" href="#ChargeTransportInSolids.ChargeTransportSystem-Tuple{Any, Any}"><code>ChargeTransportInSolids.ChargeTransportSystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ChargeTransportSystem(grid, data; unknown_storage)
</code></pre><p>System constructor which builds all necessary information needed based on the input parameters with special regard to additional interface models. This is the main struct in which all information on the input data, but also on the solving system, with which the calculations are performed, are stored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.ChargeTransportTraps" href="#ChargeTransportInSolids.ChargeTransportTraps"><code>ChargeTransportInSolids.ChargeTransportTraps</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ChargeTransportTraps</code></pre><p>A struct holding all information necessary for enabling traps in the SRH recombination. With help of this constructor we can read out the index the user chooses for trap quasi Fermi potentials and the respective regions in which they are defined.</p><ul><li><p><code>traps::Int64</code></p><p>Array with the index of traps.</p></li></ul><ul><li><p><code>regions::Vector{Int64}</code></p><p>Corresponding regions where traps are assumed to be present.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.abstract_model_SRH" href="#ChargeTransportInSolids.abstract_model_SRH"><code>ChargeTransportInSolids.abstract_model_SRH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type abstract_model_SRH</code></pre><p>Abstract type for SRH bulk recombination model</p><pre><code class="nohighlight hljs">!!! compat  
This one will be removed in future versions.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.boundary_model" href="#ChargeTransportInSolids.boundary_model"><code>ChargeTransportInSolids.boundary_model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type boundary_model</code></pre><p>Abstract type for boundary model. Subtypes are ohmic<em>contact, schottky</em>contact and interface_model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.calculation_type" href="#ChargeTransportInSolids.calculation_type"><code>ChargeTransportInSolids.calculation_type</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type calculation_type</code></pre><p>Abstract type calculation_type which distinguishes between equilibrium and out of equilibrium calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.diffusion_enhanced" href="#ChargeTransportInSolids.diffusion_enhanced"><code>ChargeTransportInSolids.diffusion_enhanced</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type diffusion_enhanced &lt;: ChargeTransportInSolids.flux_approximation</code></pre><p>Abstract type for diffusion enhanced flux discretization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.excess_chemical_potential" href="#ChargeTransportInSolids.excess_chemical_potential"><code>ChargeTransportInSolids.excess_chemical_potential</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type excess_chemical_potential &lt;: ChargeTransportInSolids.flux_approximation</code></pre><p>Abstract type for excess chemical potential flux discretization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.excess_chemical_potential_graded" href="#ChargeTransportInSolids.excess_chemical_potential_graded"><code>ChargeTransportInSolids.excess_chemical_potential_graded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type excess_chemical_potential_graded &lt;: ChargeTransportInSolids.flux_approximation</code></pre><p>Abstract type for excess chemical potential flux discretization for graded effective density of states and/or graded band-edge  energies. This means, use this flux when at least one of these quantities is assumed to be space-dependent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.flux_approximation" href="#ChargeTransportInSolids.flux_approximation"><code>ChargeTransportInSolids.flux_approximation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type flux_approximation</code></pre><p>Abstract type for flux discretization model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.generalized_sg" href="#ChargeTransportInSolids.generalized_sg"><code>ChargeTransportInSolids.generalized_sg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type generalized_sg &lt;: ChargeTransportInSolids.flux_approximation</code></pre><p>Abstract type for generalized Scharfetter-Gummel flux discretization. This flux approximation results in an implicit equation which needs to be solved and is exact for all Blakemore type statistics functions with abritary γ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.generation_beer_lambert" href="#ChargeTransportInSolids.generation_beer_lambert"><code>ChargeTransportInSolids.generation_beer_lambert</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type generation_beer_lambert &lt;: generation_model</code></pre><p>Abstract type for Beer-Lambert generation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.generation_model" href="#ChargeTransportInSolids.generation_model"><code>ChargeTransportInSolids.generation_model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type generation_model</code></pre><p>Abstract type for generation model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.generation_none" href="#ChargeTransportInSolids.generation_none"><code>ChargeTransportInSolids.generation_none</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type generation_none &lt;: generation_model</code></pre><p>Abstract type for no generation model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.generation_uniform" href="#ChargeTransportInSolids.generation_uniform"><code>ChargeTransportInSolids.generation_uniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type generation_uniform &lt;: generation_model</code></pre><p>Abstract type for uniform generation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.inEquilibrium" href="#ChargeTransportInSolids.inEquilibrium"><code>ChargeTransportInSolids.inEquilibrium</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type inEquilibrium &lt;: ChargeTransportInSolids.calculation_type</code></pre><p>Abstract type for equilibrium calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.interface_model" href="#ChargeTransportInSolids.interface_model"><code>ChargeTransportInSolids.interface_model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type interface_model &lt;: boundary_model</code></pre><p>Abstract type for interface model which is part of boundary model. Subtypes are given below.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.interface_model_discont_qF" href="#ChargeTransportInSolids.interface_model_discont_qF"><code>ChargeTransportInSolids.interface_model_discont_qF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type interface_model_discont_qF &lt;: interface_model</code></pre><p>Abstract type for an interface model where discontinuous  quasi Fermi potentials are needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.interface_model_ion_charge" href="#ChargeTransportInSolids.interface_model_ion_charge"><code>ChargeTransportInSolids.interface_model_ion_charge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type interface_model_ion_charge &lt;: interface_model</code></pre><p>Abstract type for present ion charges at interfaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.interface_model_none" href="#ChargeTransportInSolids.interface_model_none"><code>ChargeTransportInSolids.interface_model_none</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type interface_model_none &lt;: interface_model</code></pre><p>Abstract type for no interface model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.interface_model_surface_recombination" href="#ChargeTransportInSolids.interface_model_surface_recombination"><code>ChargeTransportInSolids.interface_model_surface_recombination</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type interface_model_surface_recombination &lt;: interface_model</code></pre><p>Abstract type for surface recombination mechanisms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.linearScanProtocol" href="#ChargeTransportInSolids.linearScanProtocol"><code>ChargeTransportInSolids.linearScanProtocol</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type linearScanProtocol &lt;: scan_protocol_type</code></pre><p>Abstract type for linear scan protocol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.model_SRH" href="#ChargeTransportInSolids.model_SRH"><code>ChargeTransportInSolids.model_SRH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type model_SRH &lt;: abstract_model_SRH</code></pre><p>model_SRH as parent of several different subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.model_SRH_2species_present_trap_dens" href="#ChargeTransportInSolids.model_SRH_2species_present_trap_dens"><code>ChargeTransportInSolids.model_SRH_2species_present_trap_dens</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type model_SRH_2species_present_trap_dens &lt;: abstract_model_SRH</code></pre><p>This Datatype will be deleted soon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.model_SRH_with_traps" href="#ChargeTransportInSolids.model_SRH_with_traps"><code>ChargeTransportInSolids.model_SRH_with_traps</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type model_SRH_with_traps &lt;: model_SRH</code></pre><p>model<em>SRH</em>with_traps as parent of several different subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.model_SRH_without_traps" href="#ChargeTransportInSolids.model_SRH_without_traps"><code>ChargeTransportInSolids.model_SRH_without_traps</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type model_SRH_without_traps &lt;: model_SRH</code></pre><p>model<em>SRH</em>without_traps as parent of several different subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.model_stationary" href="#ChargeTransportInSolids.model_stationary"><code>ChargeTransportInSolids.model_stationary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type model_stationary &lt;: model_type</code></pre><p>Abstract type for stationary simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.model_transient" href="#ChargeTransportInSolids.model_transient"><code>ChargeTransportInSolids.model_transient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type model_transient &lt;: model_type</code></pre><p>Abstract type for transient simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.model_type" href="#ChargeTransportInSolids.model_type"><code>ChargeTransportInSolids.model_type</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type model_type</code></pre><p>Abstract type for model type which indicates, if we consider stationary  or transient problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.ohmic_contact" href="#ChargeTransportInSolids.ohmic_contact"><code>ChargeTransportInSolids.ohmic_contact</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for ohmic contacts as boundary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.outOfEquilibrium" href="#ChargeTransportInSolids.outOfEquilibrium"><code>ChargeTransportInSolids.outOfEquilibrium</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type outOfEquilibrium &lt;: ChargeTransportInSolids.calculation_type</code></pre><p>Abstract type for out of equilibrium calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.scan_protocol_type" href="#ChargeTransportInSolids.scan_protocol_type"><code>ChargeTransportInSolids.scan_protocol_type</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type scan_protocol_type</code></pre><p>Abstract type for scan protocol type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.scharfetter_gummel" href="#ChargeTransportInSolids.scharfetter_gummel"><code>ChargeTransportInSolids.scharfetter_gummel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type scharfetter_gummel &lt;: ChargeTransportInSolids.flux_approximation</code></pre><p>Abstract type for Scharfetter-Gummel flux discretization. Choose this one, when the Boltzmann statistics function is chosen as statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.scharfetter_gummel_graded" href="#ChargeTransportInSolids.scharfetter_gummel_graded"><code>ChargeTransportInSolids.scharfetter_gummel_graded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type scharfetter_gummel_graded &lt;: ChargeTransportInSolids.flux_approximation</code></pre><p>Abstract type for Scharfetter-Gummel flux discretization for graded effective density of states and/or graded band-edge energies. This means, use this flux when at least one of these quantities is assumed to be space-dependent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.schottky_contact" href="#ChargeTransportInSolids.schottky_contact"><code>ChargeTransportInSolids.schottky_contact</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for schottky contacts as boundary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><h2 id="Methods-2"><a class="docs-heading-anchor" href="#Methods-2">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.Blakemore-Tuple{Real, Real}" href="#ChargeTransportInSolids.Blakemore-Tuple{Real, Real}"><code>ChargeTransportInSolids.Blakemore</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Blakemore(x::Real, γ::Real) -&gt; Any
</code></pre><p>The Blakemore approximation <span>$1/(\exp(-x) + γ)$</span> with variable real scalar <span>$γ$</span>, see  [Blakemore1952, &quot;The parameters of partially degenerate semiconductors&quot;].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.Blakemore-Tuple{Real}" href="#ChargeTransportInSolids.Blakemore-Tuple{Real}"><code>ChargeTransportInSolids.Blakemore</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Blakemore(x::Real) -&gt; Any
</code></pre><p>The Blakemore approximation <span>$1/(\exp(-x) + γ)$</span> with <span>$γ = 0.27$</span>, see  [Blakemore1952, &quot;The parameters of partially degenerate semiconductors&quot;].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.Boltzmann-Tuple{Real}" href="#ChargeTransportInSolids.Boltzmann-Tuple{Real}"><code>ChargeTransportInSolids.Boltzmann</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Boltzmann(x::Real) -&gt; Any
</code></pre><p>The Boltzmann statistics function <span>$\exp(x)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.FermiDiracMinusOne-Tuple{Real}" href="#ChargeTransportInSolids.FermiDiracMinusOne-Tuple{Real}"><code>ChargeTransportInSolids.FermiDiracMinusOne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FermiDiracMinusOne(x::Real) -&gt; Any
</code></pre><p>The Fermi-Dirac integral of order <span>$-1$</span> which reads  <span>$1/(\exp(-x) + 1)$</span>, see [Blakemore1982: &quot;Approximations for Fermi-Dirac integrals, especially the function <span>$F_{1/2} (η)$</span> used to describe electron density in a semiconductor&quot;].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.FermiDiracOneHalfBednarczyk-Tuple{Real}" href="#ChargeTransportInSolids.FermiDiracOneHalfBednarczyk-Tuple{Real}"><code>ChargeTransportInSolids.FermiDiracOneHalfBednarczyk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FermiDiracOneHalfBednarczyk(x::Real) -&gt; Any
</code></pre><p>The incomplete Fermi-Dirac integral of order 1/2,  implemented according to [Bednarczyk1978,  &quot;The Approximation of the Fermi-Dirac integral <span>$F_{1/2}()$</span>&quot;].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.FermiDiracOneHalfTeSCA-Tuple{Real}" href="#ChargeTransportInSolids.FermiDiracOneHalfTeSCA-Tuple{Real}"><code>ChargeTransportInSolids.FermiDiracOneHalfTeSCA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FermiDiracOneHalfTeSCA(x::Real) -&gt; Any
</code></pre><p>The incomplete Fermi-Dirac integral of order 1/2,  implemented according to the software package TeSCA, see https://wias-berlin.de/software/index.jsp?lang=1&amp;id=TeSCA.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.addChargeCarriers!-NTuple{9, Any}" href="#ChargeTransportInSolids.addChargeCarriers!-NTuple{9, Any}"><code>ChargeTransportInSolids.addChargeCarriers!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addChargeCarriers!(f, u, node, data, ipsi, iphin, iphip, n, p) -&gt; Any
</code></pre><p>Function which builds right-hand side of charge carriers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.addElectricPotential!-NTuple{5, Any}" href="#ChargeTransportInSolids.addElectricPotential!-NTuple{5, Any}"><code>ChargeTransportInSolids.addElectricPotential!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addElectricPotential!(f, u, node, data, ipsi) -&gt; Any
</code></pre><p>Function which builds right-hand side of Poisson equation, i.e. which builds the space charge density for outOfEquilibrium calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.addTrapDensity!-NTuple{9, Any}" href="#ChargeTransportInSolids.addTrapDensity!-NTuple{9, Any}"><code>ChargeTransportInSolids.addTrapDensity!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">addTrapDensity!(f, u, node, data, ipsi, iphin, iphip, n, p) -&gt; Any
</code></pre><p>Function which adds additional trap density to right-hand side of Poisson equation without modeling traps as own charge carrier. Note that this one may be deleted in future version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.bflux!-NTuple{4, Any}" href="#ChargeTransportInSolids.bflux!-NTuple{4, Any}"><code>ChargeTransportInSolids.bflux!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bflux!(f, u, bedge, data) -&gt; Any
</code></pre><p>Master bflux! function. This is the function which enters VoronoiFVM and hands over for each boundary the flux within the boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.bflux!-Tuple{Any, Any, Any, Any, Type{excess_chemical_potential}}" href="#ChargeTransportInSolids.bflux!-Tuple{Any, Any, Any, Any, Type{excess_chemical_potential}}"><code>ChargeTransportInSolids.bflux!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bflux!(f, u, bedge, data, _::Type{excess_chemical_potential}) -&gt; Any
</code></pre><p>The excess chemical potential flux discretization scheme for inner boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.breaction!-NTuple{4, Any}" href="#ChargeTransportInSolids.breaction!-NTuple{4, Any}"><code>ChargeTransportInSolids.breaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">breaction!(f, u, bnode, data) -&gt; Any
</code></pre><p>Master breaction! function. This is the function which enters VoronoiFVM and hands over for each boundary the chosen boundary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.breaction!-Tuple{Any, Any, Any, Any, Type{interface_model_none}}" href="#ChargeTransportInSolids.breaction!-Tuple{Any, Any, Any, Any, Type{interface_model_none}}"><code>ChargeTransportInSolids.breaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">breaction!(f, u, bnode, data, _::Type{interface_model_none})
</code></pre><p>This breaction! function is chosen when no interface model is chosen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.breaction!-Tuple{Any, Any, Any, Any, Type{ohmic_contact}}" href="#ChargeTransportInSolids.breaction!-Tuple{Any, Any, Any, Any, Type{ohmic_contact}}"><code>ChargeTransportInSolids.breaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">breaction!(f, u, bnode, data, _::Type{ohmic_contact}) -&gt; Any
</code></pre><p>Creates ohmic boundary conditions via a penalty approach with penalty parameter <span>$\delta$</span>. For example, the right-hand side for the electrostatic potential <span>$\psi$</span> is implemented as</p><p><span>$f[\psi]  = -q/\delta   ( (p - N_a) - (n - N_d) )$</span>,</p><p>assuming a bipolar semiconductor. In general, we have for some given charge number <span>$z_\alpha$</span></p><p><span>$f[\psi] =  -q/\delta  \sum_\alpha{ z_\alpha  (n_\alpha - C_\alpha) },$</span></p><p>where <span>$C_\alpha$</span> corresponds to some doping w.r.t. the species <span>$\alpha$</span>.</p><p>The boundary conditions for the charge carriers are set in the main file. Hence,</p><p><span>$f[n_\alpha] = 0$</span>`</p><p>for all charge carriers <span>$\alpha$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.breaction!-Tuple{Any, Any, Any, Any, Type{schottky_contact}}" href="#ChargeTransportInSolids.breaction!-Tuple{Any, Any, Any, Any, Type{schottky_contact}}"><code>ChargeTransportInSolids.breaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">breaction!(f, u, bnode, data, _::Type{schottky_contact}) -&gt; Any
</code></pre><p>[Note that this way of implementation is not well tested yet. </p><p>Creates Schottky boundary conditions in a first attempt. For the electrostatic potential we assume </p><p><span>$\psi = \psi_S + U,$</span></p><p>where  <span>$\psi_S$</span> corresponds to a given value and <span>$U$</span> to the applied voltage. For now, the quantitity <span>$\psi_S$</span> needs to be specified in the main file. For the charge carriers we assume the following</p><p><span>$f[n_\alpha]  =  z_\alpha q v_\alpha (n_\alpha - n_{\alpha, 0})$</span>,</p><p>where <span>$v_{\alpha}$</span> can be treated as a surface recombination mechanism and is given. The parameter <span>$n_{\alpha, 0}$</span> is a given value, calculated by the statistical relation, when assuming  no electrical field and a quasi Fermi level equal to the metal work function <span>$\phi$</span>, i.e.</p><p><span>$n_{\alpha, 0}= z_\alpha/ U_T (E_\alpha - \phi) / q.$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.bstorage!-NTuple{4, Any}" href="#ChargeTransportInSolids.bstorage!-NTuple{4, Any}"><code>ChargeTransportInSolids.bstorage!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bstorage!(f, u, bnode, data) -&gt; Any
</code></pre><p>Master bstorage! function. This is the function which enters VoronoiFVM and hands over for each boundary the time-dependent part of the chosen boundary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.bstorage!-Tuple{Any, Any, Any, Any, Type{interface_model_discont_qF}}" href="#ChargeTransportInSolids.bstorage!-Tuple{Any, Any, Any, Any, Type{interface_model_discont_qF}}"><code>ChargeTransportInSolids.bstorage!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bstorage!(f, u, bnode, data, _::Type{interface_model_discont_qF})
</code></pre><p>No bstorage! is used, when assuming discontinuous qF.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.bstorage!-Tuple{Any, Any, Any, Any, Type{ohmic_contact}}" href="#ChargeTransportInSolids.bstorage!-Tuple{Any, Any, Any, Any, Type{ohmic_contact}}"><code>ChargeTransportInSolids.bstorage!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bstorage!(f, u, bnode, data, _::Type{ohmic_contact})
</code></pre><p>No bstorage! is used, if an ohmic and schottky contact model is chosen.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.build_system-Tuple{Any, Any, Any, Type{interface_model_discont_qF}}" href="#ChargeTransportInSolids.build_system-Tuple{Any, Any, Any, Type{interface_model_discont_qF}}"><code>ChargeTransportInSolids.build_system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_system(grid, data, unknown_storage, _)
</code></pre><p>The core of the new system constructor. Here, the system for discontinuous quantities is build.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.build_system-Tuple{Any, Any, Any, Type{interface_model_none}}" href="#ChargeTransportInSolids.build_system-Tuple{Any, Any, Any, Type{interface_model_none}}"><code>ChargeTransportInSolids.build_system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_system(grid, data, unknown_storage, _)
</code></pre><p>The core of the system constructor. Here, the system for no additional interface model is build.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.chargeDensity-NTuple{8, Any}" href="#ChargeTransportInSolids.chargeDensity-NTuple{8, Any}"><code>ChargeTransportInSolids.chargeDensity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chargeDensity(psi0, phi, UT, EVector, chargeNumbers, dopingVector, dosVector, FVector) -&gt; Any
</code></pre><p>Compute the charge density, i.e. the right-hand side of Poisson&#39;s equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.chargeDensity-Tuple{Any, Any}" href="#ChargeTransportInSolids.chargeDensity-Tuple{Any, Any}"><code>ChargeTransportInSolids.chargeDensity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chargeDensity(ctsys, sol) -&gt; Any
</code></pre><p>Compute the charge density for each region separately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.compute_densities!-Tuple{Any, Any, Any, Any, Any, Any, Bool}" href="#ChargeTransportInSolids.compute_densities!-Tuple{Any, Any, Any, Any, Any, Any, Bool}"><code>ChargeTransportInSolids.compute_densities!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_densities!(u, data, inode, region, icc, ipsi, in_region::Bool) -&gt; Any
</code></pre><p>For given potentials, compute corresponding densities. This function is needed for the method, plotting the densities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.compute_densities!-Tuple{Any, Any, Any}" href="#ChargeTransportInSolids.compute_densities!-Tuple{Any, Any, Any}"><code>ChargeTransportInSolids.compute_densities!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_densities!(grid, data, sol) -&gt; Matrix{Real}
</code></pre><p>For given potentials in vector form, compute corresponding vectorized densities. [Caution: this was not tested for multidimensions.]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.compute_energies!-Tuple{Any, Any, Any}" href="#ChargeTransportInSolids.compute_energies!-Tuple{Any, Any, Any}"><code>ChargeTransportInSolids.compute_energies!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_energies!(grid, data, sol)
</code></pre><p>For given solution in vector form, compute corresponding vectorized band-edge energies and Fermi level. [Caution: this was not tested for multidimensions.]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.degenerateLimit-Tuple{Any}" href="#ChargeTransportInSolids.degenerateLimit-Tuple{Any}"><code>ChargeTransportInSolids.degenerateLimit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degenerateLimit(x) -&gt; Any
</code></pre><p>Degenerate limit of incomplete Fermi-Dirac integral of order 1/2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.electroNeutralSolution!-Tuple{Any, Any}" href="#ChargeTransportInSolids.electroNeutralSolution!-Tuple{Any, Any}"><code>ChargeTransportInSolids.electroNeutralSolution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">electroNeutralSolution!(grid, data; Newton) -&gt; Any
</code></pre><p>Compute the electro-neutral solution for the Boltzmann approximation.  It is obtained by setting the left-hand side in the Poisson equation equal to zero and solving for <span>$\psi$</span>. The charge carriers may obey different statitics functions. Currently, this one is not well tested for the case of charge carriers beyond electrons and holes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.electrochemicalReaction-NTuple{10, Any}" href="#ChargeTransportInSolids.electrochemicalReaction-NTuple{10, Any}"><code>ChargeTransportInSolids.electrochemicalReaction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">electrochemicalReaction(data, u, iphia, ipsi, iphiaJunction, ipsiJunction, β, κ, DOS, E) -&gt; Any
</code></pre><p>Electrochemical reaction between interface and bulk ionic species. This function enters in the internal boundary reaction in case of an ion charge interface model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.enable_ionic_carriers-Tuple{}" href="#ChargeTransportInSolids.enable_ionic_carriers-Tuple{}"><code>ChargeTransportInSolids.enable_ionic_carriers</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Corresponding constructor for the present ionic charge carriers and the respective regions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.enable_traps!-Tuple{Any}" href="#ChargeTransportInSolids.enable_traps!-Tuple{Any}"><code>ChargeTransportInSolids.enable_traps!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Corresponding constructor for the present trap density and the respective regions. Note that, this one will may be deleted in future versions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.enable_traps!-Tuple{}" href="#ChargeTransportInSolids.enable_traps!-Tuple{}"><code>ChargeTransportInSolids.enable_traps!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Corresponding constructor for the present trap density and the respective regions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.etaFunction-NTuple{5, Any}" href="#ChargeTransportInSolids.etaFunction-NTuple{5, Any}"><code>ChargeTransportInSolids.etaFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">etaFunction(psi, phi, UT, E, z) -&gt; Any
</code></pre><p>The argument of the distribution function for given <span>$\varphi_\alpha$</span> and <span>$\psi$</span></p><p><span>$z_\alpha / U_T  ( (\varphi_\alpha - \psi) + E_\alpha / q ).$</span></p><p>The parameters <span>$E_\alpha$</span> and <span>$z_\alpha$</span> are given as vectors. This function may be used to compute the charge density, i.e. the right-hand side of the Poisson equation.   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.etaFunction-Tuple{Any, Any, Any, Any, Any, Any, Bool}" href="#ChargeTransportInSolids.etaFunction-Tuple{Any, Any, Any, Any, Any, Any, Bool}"><code>ChargeTransportInSolids.etaFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">etaFunction(u, data, node, region, icc, ipsi, in_region::Bool) -&gt; Any
</code></pre><p>The argument of the distribution function</p><p><span>$z_\alpha / U_T  ( (\varphi_\alpha - \psi) + E_\alpha / q )$</span></p><p>for floats.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.etaFunction-Tuple{Any, VoronoiFVM.BNode, Any, Any, Any}" href="#ChargeTransportInSolids.etaFunction-Tuple{Any, VoronoiFVM.BNode, Any, Any, Any}"><code>ChargeTransportInSolids.etaFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">etaFunction(u, bnode::VoronoiFVM.BNode, data, icc, ipsi) -&gt; Any
</code></pre><p>The argument of the distribution function</p><p><span>$z_\alpha / U_T  ( (\varphi_\alpha - \psi) + E_\alpha / q )$</span></p><p>for boundary nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.etaFunction-Tuple{Any, VoronoiFVM.Node, Any, Any, Any}" href="#ChargeTransportInSolids.etaFunction-Tuple{Any, VoronoiFVM.Node, Any, Any, Any}"><code>ChargeTransportInSolids.etaFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">etaFunction(u, node::VoronoiFVM.Node, data, icc, ipsi) -&gt; Any
</code></pre><p>The argument of the distribution function</p><p><span>$z_\alpha / U_T  ( (\varphi_\alpha - \psi) + E_\alpha / q )$</span></p><p>for interior nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{diffusion_enhanced}}" href="#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{diffusion_enhanced}}"><code>ChargeTransportInSolids.flux!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux!(f, u, edge, data, _::Type{diffusion_enhanced}) -&gt; Any
</code></pre><p>The diffusion enhanced scheme by Bessemoulin-Chatard. Currently, the Pietra-Jüngel scheme is  used for the regularization of the removable singularity. This also works for space-dependent band-edge energy, but not for space-dependent effective DOS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{excess_chemical_potential_graded}}" href="#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{excess_chemical_potential_graded}}"><code>ChargeTransportInSolids.flux!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux!(f, u, edge, data, _::Type{excess_chemical_potential_graded}) -&gt; Any
</code></pre><p>The excess chemical potential flux scheme for  possible space-dependent DOS and band-edge energies. For these parameters the discretization scheme is modified. [insert continuous flux etc ...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{excess_chemical_potential}}" href="#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{excess_chemical_potential}}"><code>ChargeTransportInSolids.flux!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux!(f, u, edge, data, _::Type{excess_chemical_potential}) -&gt; Any
</code></pre><p>The excess chemical potential flux discretization scheme. This also works for space-dependent band-edge energy, but not for space-dependent effective DOS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{generalized_sg}}" href="#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{generalized_sg}}"><code>ChargeTransportInSolids.flux!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux!(f, u, edge, data, _::Type{generalized_sg}) -&gt; Any
</code></pre><p>The Koprucki-Gärtner scheme. This scheme is calculated by solving a fixed point equation which arise when considering the generalized Scharfetter-Gummel scheme in case of Blakemore statistics. Hence, it should be exclusively worked with, when considering the Blakemore distribution. This also works for space-dependent band-edge energy, but not for space-dependent effective DOS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{scharfetter_gummel_graded}}" href="#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{scharfetter_gummel_graded}}"><code>ChargeTransportInSolids.flux!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux!(f, u, edge, data, _::Type{scharfetter_gummel_graded}) -&gt; Any
</code></pre><p>The classical Scharfetter-Gummel flux scheme for  possible space-dependent DOS and band-edge energies. For these parameters the discretization scheme is modified. [insert continuous flux etc ...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{scharfetter_gummel}}" href="#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{scharfetter_gummel}}"><code>ChargeTransportInSolids.flux!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux!(f, u, edge, data, _::Type{scharfetter_gummel}) -&gt; Any
</code></pre><p>The classical Scharfetter-Gummel flux scheme. This also works for space-dependent band-edge energy, but not for space-dependent effective DOS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.generation-Tuple{Any, Any, Any, Type{generation_beer_lambert}}" href="#ChargeTransportInSolids.generation-Tuple{Any, Any, Any, Type{generation_beer_lambert}}"><code>ChargeTransportInSolids.generation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generation(data, ireg, node, _::Type{generation_beer_lambert}) -&gt; Any
</code></pre><p>The generation rate <span>$G$</span>, which occurs in the right-hand side of the continuity equations obeying the Beer-Lambert law.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.generation-Tuple{Any, Any, Any, Type{generation_uniform}}" href="#ChargeTransportInSolids.generation-Tuple{Any, Any, Any, Type{generation_uniform}}"><code>ChargeTransportInSolids.generation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generation(data, ireg, node, _::Type{generation_uniform}) -&gt; Any
</code></pre><p>The generation rate <span>$G$</span>, which occurs in the right-hand side of the continuity equations with a uniform generation rate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.get_BEE!-Tuple{Any, VoronoiFVM.BNode, Any}" href="#ChargeTransportInSolids.get_BEE!-Tuple{Any, VoronoiFVM.BNode, Any}"><code>ChargeTransportInSolids.get_BEE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_BEE!(icc, bnode::VoronoiFVM.BNode, data) -&gt; Any
</code></pre><p>Defining locally the band-edge energy for boundary nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.get_BEE!-Tuple{Any, VoronoiFVM.Edge, Any}" href="#ChargeTransportInSolids.get_BEE!-Tuple{Any, VoronoiFVM.Edge, Any}"><code>ChargeTransportInSolids.get_BEE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_BEE!(icc, edge::VoronoiFVM.Edge, data) -&gt; Any
</code></pre><p>Defining locally the band-edge energy for edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.get_BEE!-Tuple{Any, VoronoiFVM.Node, Any}" href="#ChargeTransportInSolids.get_BEE!-Tuple{Any, VoronoiFVM.Node, Any}"><code>ChargeTransportInSolids.get_BEE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_BEE!(icc, node::VoronoiFVM.Node, data) -&gt; Any
</code></pre><p>Defining locally the band-edge energy for interior nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.get_DOS!-Tuple{Any, VoronoiFVM.BNode, Any}" href="#ChargeTransportInSolids.get_DOS!-Tuple{Any, VoronoiFVM.BNode, Any}"><code>ChargeTransportInSolids.get_DOS!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_DOS!(icc, bnode::VoronoiFVM.BNode, data) -&gt; Any
</code></pre><p>Defining locally the effective DOS for boundary nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.get_DOS!-Tuple{Any, VoronoiFVM.Edge, Any}" href="#ChargeTransportInSolids.get_DOS!-Tuple{Any, VoronoiFVM.Edge, Any}"><code>ChargeTransportInSolids.get_DOS!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_DOS!(icc, edge::VoronoiFVM.Edge, data) -&gt; Tuple{Any, Any}
</code></pre><p>Defining locally the effective DOS for edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.get_DOS!-Tuple{Any, VoronoiFVM.Node, Any}" href="#ChargeTransportInSolids.get_DOS!-Tuple{Any, VoronoiFVM.Node, Any}"><code>ChargeTransportInSolids.get_DOS!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_DOS!(icc, node::VoronoiFVM.Node, data) -&gt; Any
</code></pre><p>Defining locally the effective DOS for interior nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.get_current_val-NTuple{4, Any}" href="#ChargeTransportInSolids.get_current_val-NTuple{4, Any}"><code>ChargeTransportInSolids.get_current_val</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates current for time dependent problem. But caution, still need some small modification!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.get_current_val-Tuple{Any, Any}" href="#ChargeTransportInSolids.get_current_val-Tuple{Any, Any}"><code>ChargeTransportInSolids.get_current_val</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates current for stationary problem. But caution, still need some small modification!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.inner_interface_model-Tuple{ChargeTransportData}" href="#ChargeTransportInSolids.inner_interface_model-Tuple{ChargeTransportData}"><code>ChargeTransportInSolids.inner_interface_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner_interface_model(data)
</code></pre><p>Method which determines with input parameters which inner interface model  was chosen by user.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.inner_interface_model-Tuple{ChargeTransportSystem}" href="#ChargeTransportInSolids.inner_interface_model-Tuple{ChargeTransportSystem}"><code>ChargeTransportInSolids.inner_interface_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner_interface_model(ctsys)
</code></pre><p>Method which determines with input parameters which inner interface model  was chosen by user.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.kernelSRH-Tuple{Any, Any, Any, Any, Any, Any, Type{ChargeTransportInSolids.model_SRH_stationary}}" href="#ChargeTransportInSolids.kernelSRH-Tuple{Any, Any, Any, Any, Any, Any, Type{ChargeTransportInSolids.model_SRH_stationary}}"><code>ChargeTransportInSolids.kernelSRH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kernelSRH(data, ireg, iphin, iphip, n, p, _::Type{ChargeTransportInSolids.model_SRH_stationary}) -&gt; Any
</code></pre><p>SRH kernel for case of using stationary formula, i.e. case where no present traps are assumed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.kernelSRH-Tuple{Any, Any, Any, Any, Any, Any, Type{model_SRH_off}}" href="#ChargeTransportInSolids.kernelSRH-Tuple{Any, Any, Any, Any, Any, Any, Type{model_SRH_off}}"><code>ChargeTransportInSolids.kernelSRH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kernelSRH(data, ireg, iphin, iphip, n, p, _::Type{model_SRH_off}) -&gt; Float64
</code></pre><p>SRH kernel for case of non-existing rate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.plotDiffusionEnhancements-Tuple{}" href="#ChargeTransportInSolids.plotDiffusionEnhancements-Tuple{}"><code>ChargeTransportInSolids.plotDiffusionEnhancements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotDiffusionEnhancements()
</code></pre><p>Plot diffusion enhancements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.plotDistributions-Tuple{}" href="#ChargeTransportInSolids.plotDistributions-Tuple{}"><code>ChargeTransportInSolids.plotDistributions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotDistributions(; Plotter)
</code></pre><p>Plot different distribution integrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.plot_IV-NTuple{4, Any}" href="#ChargeTransportInSolids.plot_IV-NTuple{4, Any}"><code>ChargeTransportInSolids.plot_IV</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_IV(Plotter, biasValues, IV, Δu; plotGridpoints) -&gt; Any
</code></pre><p>Method for showing the total current in dependence of the applied voltage. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.plot_densities-NTuple{5, Any}" href="#ChargeTransportInSolids.plot_densities-NTuple{5, Any}"><code>ChargeTransportInSolids.plot_densities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_densities(Plotter, grid, data, sol, title; plotGridpoints) -&gt; Any
</code></pre><p>Plotting routine, where the charge carrier densities are depicted in dependence of space. The case of heterojunctions is tested, but yet multidimensional calculations are missing. Currently, for a matching legend, we need the following order:</p><p>index 1: electrons as charge carrier with the corresponding density <span>$n$</span>,</p><p>index 2: holes as charge carrier with the corresponding density <span>$p$</span>,</p><p>index 3: anion vacancies as charge carrier with the corresponding density <span>$a$</span>,</p><p>index 4: cation vacancies as charge carrier with the corresponding density <span>$c$</span>.</p><p>One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ChargeTransportData}" href="#ChargeTransportInSolids.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ChargeTransportData}"><code>ChargeTransportInSolids.plot_doping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_doping(Plotter, g::ExtendableGrids.ExtendableGrid, data::ChargeTransportData) -&gt; Any
</code></pre><p>Possibility to plot the considered doping. This is especially useful  for making sure that the interior and the boundary doping agree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ChargeTransportParamsNodal}" href="#ChargeTransportInSolids.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ChargeTransportParamsNodal}"><code>ChargeTransportInSolids.plot_doping</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Plot doping for nodal dependent doping</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.plot_electroNeutralSolutionBoltzmann-Tuple{Any, Any, Any}" href="#ChargeTransportInSolids.plot_electroNeutralSolutionBoltzmann-Tuple{Any, Any, Any}"><code>ChargeTransportInSolids.plot_electroNeutralSolutionBoltzmann</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_electroNeutralSolutionBoltzmann(Plotter, grid, psi0; plotGridpoints) -&gt; Any
</code></pre><p>Plotting routine for depicting the electroneutral potential. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.plot_energies-NTuple{5, Any}" href="#ChargeTransportInSolids.plot_energies-NTuple{5, Any}"><code>ChargeTransportInSolids.plot_energies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_energies(Plotter, grid, data, sol, title; plotGridpoints) -&gt; Any
</code></pre><p>With this method it is possible to plot the energies</p><p><span>$E_\alpha - q \psi \quad \text{w.r.t. space.}$</span></p><p>The case of heterojunctions is tested, but yet multidimensional calculations are missing.  Currently, for a matching legend, we need the following order:</p><p>index 1: electrons as charge carrier with the corresponding density <span>$n$</span>,</p><p>index 2: holes as charge carrier with the corresponding density <span>$p$</span>,</p><p>index 3: anion vacancies as charge carrier with the corresponding density <span>$a$</span>,</p><p>index 4: cation vacancies as charge carrier with the corresponding density <span>$c$</span>.</p><p>One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.plot_energies-Tuple{Any, ExtendableGrids.ExtendableGrid, Any}" href="#ChargeTransportInSolids.plot_energies-Tuple{Any, ExtendableGrids.ExtendableGrid, Any}"><code>ChargeTransportInSolids.plot_energies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_energies(Plotter, grid, data)
</code></pre><p>With this method it is possible to depict the band-edge energies <span>$E_\alpha$</span>.  This can be useful for debugging when dealing with heterojunctions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.plot_solution-NTuple{5, Any}" href="#ChargeTransportInSolids.plot_solution-NTuple{5, Any}"><code>ChargeTransportInSolids.plot_solution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_solution(Plotter, grid, data, solution, title; plotGridpoints) -&gt; Any
</code></pre><p>Method for plotting the solution vectors: the electrostatic potential <span>$\psi$</span> as well as the charge carriers. The case of heterojunctions is tested, but yet multidimensional calculations are missing.  Currently, for a matching legend, we need the following order:</p><p>index 1: electrons as charge carrier with the corresponding density <span>$n$</span>,</p><p>index 2: holes as charge carrier with the corresponding density <span>$p$</span>,</p><p>index 3: anion vacancies as charge carrier with the corresponding density <span>$a$</span>,</p><p>index 4: cation vacancies as charge carrier with the corresponding density <span>$c$</span>. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.printJacobi-Tuple{Any, Any}" href="#ChargeTransportInSolids.printJacobi-Tuple{Any, Any}"><code>ChargeTransportInSolids.printJacobi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printJacobi(node, sys)
</code></pre><p>First try of debugger. Print the Jacobi matrix for a given node, i.e. the number of the node in the grid and not the excact coordinate. This is only done for the one dimensional case so far. [insert some information about VoronoiFVM]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.reaction!-NTuple{4, Any}" href="#ChargeTransportInSolids.reaction!-NTuple{4, Any}"><code>ChargeTransportInSolids.reaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reaction!(f, u, node, data) -&gt; Any
</code></pre><p>Master reaction! function. This is the function which enters VoronoiFVM and hands over reaction terms for concrete calculation type and bulk recombination model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.reaction!-Tuple{Any, Any, Any, Any, Type{inEquilibrium}}" href="#ChargeTransportInSolids.reaction!-Tuple{Any, Any, Any, Any, Type{inEquilibrium}}"><code>ChargeTransportInSolids.reaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reaction!(f, u, node, data, _::Type{inEquilibrium}) -&gt; Any
</code></pre><p>Reaction in case of equilibrium, i.e. no generation and recombination is considered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.reaction!-Tuple{Any, Any, Any, Any, Type{outOfEquilibrium}}" href="#ChargeTransportInSolids.reaction!-Tuple{Any, Any, Any, Any, Type{outOfEquilibrium}}"><code>ChargeTransportInSolids.reaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reaction!(f, u, node, data, _::Type{outOfEquilibrium}) -&gt; Any
</code></pre><p>Sets up the right-hand sides. Assuming a bipolar semiconductor the right-hand side for the electrostatic potential becomes</p><p><span>$f[ψ]  = - q ((p - N_a) - (n - N_d) ) = - q  \sum  n_\alpha  (n_\alpha - C_\alpha)$</span></p><p>for some doping <span>$C_\alpha$</span> w.r.t. to the species <span>$\alpha$</span>. The right-hand sides for the charge carriers read as</p><p><span>$f[n_\alpha] =  - z_\alpha  q (G -  R)$</span></p><p>for all charge carriers <span>$n_\alpha$</span>. The recombination includes radiative, Auger and Shockley-Read-Hall recombination. For latter recombination process the stationary simplification is implemented.</p><p>The recombination is only implemented for electron and holes and assumes that the electron index is 1 and the hole index is 2. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.set_bulk_recombination-Tuple{}" href="#ChargeTransportInSolids.set_bulk_recombination-Tuple{}"><code>ChargeTransportInSolids.set_bulk_recombination</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_bulk_recombination(; iphin, iphip, bulk_recomb_Auger, bulk_recomb_radiative, bulk_recomb_SRH)
</code></pre><p>Corresponding constructor for the bulk recombination model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.set_time_mesh-Tuple{Any, Any, Any}" href="#ChargeTransportInSolids.set_time_mesh-Tuple{Any, Any, Any}"><code>ChargeTransportInSolids.set_time_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gives the user a linear time mesh, this mesh is used for a linear I-V scan protocol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.storage!-NTuple{4, Any}" href="#ChargeTransportInSolids.storage!-NTuple{4, Any}"><code>ChargeTransportInSolids.storage!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">storage!(f, u, node, data) -&gt; Any
</code></pre><p>Master storage! function. This is the function which enters VoronoiFVM and hands over a storage term, if we consider transient problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.storage!-Tuple{Any, Any, Any, Any, Type{model_transient}}" href="#ChargeTransportInSolids.storage!-Tuple{Any, Any, Any, Any, Type{model_transient}}"><code>ChargeTransportInSolids.storage!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">storage!(f, u, node, data, _::Type{model_transient}) -&gt; Any
</code></pre><p>The storage term for time-dependent problems. Currently, for the time-dependent current densities the implicit Euler scheme is used. Hence, we have </p><p><span>$f[n_\alpha] =  z_\alpha  q ∂_t n_\alpha$</span> </p><p>and for the electrostatic potential <span>$f[ψ] = 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransportInSolids.trap_density!-NTuple{4, Any}" href="#ChargeTransportInSolids.trap_density!-NTuple{4, Any}"><code>ChargeTransportInSolids.trap_density!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trap_density!(icc, ireg, data, Et)
</code></pre><p>Compute trap densities for a given trap energy. [Currently, only done for the Boltzmann statistics and for region dependent parameters.]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransportInSolids.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/PSC/">« Electronic and Ionic Charge Carriers</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 2 December 2021 17:21">Thursday 2 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
