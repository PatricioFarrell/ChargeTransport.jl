var documenterSearchIndex = {"docs":
[{"location":"GeneralInformation/#generalDescription","page":"General Information on Code Structure","title":"General Information on Code Structure","text":"","category":"section"},{"location":"GeneralInformation/","page":"General Information on Code Structure","title":"General Information on Code Structure","text":"... insert here a mindmap ......","category":"page"},{"location":"allindex/#Overview-–-Types,-Constructors-and-Methods","page":"Overview on Types and Constructors","title":"Overview – Types, Constructors and Methods","text":"","category":"section"},{"location":"allindex/#Types-and-Constructors","page":"Overview on Types and Constructors","title":"Types and Constructors","text":"","category":"section"},{"location":"allindex/","page":"Overview on Types and Constructors","title":"Overview on Types and Constructors","text":"Modules = [ChargeTransportInSolids]\nOrder=[:type]","category":"page"},{"location":"allindex/#Methods","page":"Overview on Types and Constructors","title":"Methods","text":"","category":"section"},{"location":"allindex/","page":"Overview on Types and Constructors","title":"Overview on Types and Constructors","text":"Modules = [ChargeTransportInSolids]\nOrder=[:function]","category":"page"},{"location":"allindex/#Description-of-Types,-Constructors-and-Methods","page":"Overview on Types and Constructors","title":"Description of Types, Constructors and Methods","text":"","category":"section"},{"location":"allindex/#Types-and-Constructors-2","page":"Overview on Types and Constructors","title":"Types and Constructors","text":"","category":"section"},{"location":"allindex/","page":"Overview on Types and Constructors","title":"Overview on Types and Constructors","text":"Modules = [ChargeTransportInSolids]\nOrder=[:type]","category":"page"},{"location":"allindex/#ChargeTransportInSolids.ChargeTransportBulkRecombination","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.ChargeTransportBulkRecombination","text":"mutable struct ChargeTransportBulkRecombination\n\nA struct holding all information necessary for building bulk recombination. With help of this constructor we can read out the indices the user chooses for electron and hole quasi Fermi potentials.\n\niphin::Int64\nindex for data construction of quasi Fermi potential of electrons\n\niphip::Int64\nindex for data construction of quasi Fermi potential of holes\n\nbulk_recomb_Auger::Bool\nboolean for present Auger recombination in bulk\n\nbulk_recomb_radiative::Bool\nboolean for present radiative recombination in bulk\n\nbulk_recomb_SRH::DataType\nDataType for present SRH recombination in bulk\n\nmodel_SRH_2species_trap::DataType\nAuxiliary quantitiy for simulations with present trap density in Poisson, but without traps as own unknowns. Note that this one may be deleted in future versions.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.ChargeTransportData","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.ChargeTransportData","text":"mutable struct ChargeTransportData\n\nA struct holding all data information including model and numerics information, but also all physical parameters for a drift-diffusion simulation of a semiconductor device.\n\nF::Vector{Function}\nAn array with the corresponding distribution function mathcalF_alpha for all carriers alpha.\n\nboundary_type::Vector{DataType}\nAn array of DataTypes with the type of boundary model for each boundary (interior and exterior).\n\nbulk_recombination::ChargeTransportBulkRecombination\nA struct containing information concerning the bulk recombination model.\n\nenable_ionic_carriers::ChargeTransportIonicChargeCarriers\nA struct which contains information on the regions, where ionic charge carriers (ions and/or ion vacancies) are present.\n\nenable_traps::ChargeTransportInSolids.ChargeTransportTraps\nAn AbstractVector which contains information on present SRH traps.\n\ninner_interface_model::DataType\nDataType which stores information about which inner interface model is chosen by user. This quantity cannot be seen by the user and is needed for the core of package.\n\nflux_approximation::DataType\nA DataType for the flux discretization method.\n\ncalculation_type::DataType\nA DataType for equilibrium or out of equilibrium calculations.\n\nmodel_type::DataType\nA DataType for transient or stationary calculations.\n\ngeneration_model::DataType\nA DataType for for generation model.\n\nλ1::Float64\nAn embedding parameter used to solve the nonlinear Poisson problem, which corresponds for λ1 = 0 to the case of thermodynamic equilibrium and electrocharge neutrality and for λ1 = 1 to the case of thermodynamic equilibrium.\n\nλ2::Float64\nAn embedding parameter for turning the generation rate G on.\n\nλ3::Float64\nAn embedding parameter for electrochemical reaction.\n\ntempBEE1::Vector{Float64}\nWithin this template informations concerning the band-edge energy of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.\n\ntempBEE2::Vector{Float64}\nsee the description of tempBEE1\n\ntempDOS1::Vector{Float64}\nWithin this template informations concerning the effective DOS of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.\n\ntempDOS2::Vector{Float64}\nsee the desciption of tempDOS2\n\nisContinuous::Vector{Bool}\nAn array which contains information on whether charge carriers are continuous or discontinuous. This is needed for building the AbstractQuantities which handle the indices of charge carriers on different regions.\n\nchargeCarrierList::Union{Vector{VoronoiFVM.AbstractQuantity}, Vector{Int64}}\nThis list stores all charge carriers. Here, we can have a vector holding all abstract quantities or a vector holding an integer array depending on the interface model and the the regularity of unknowns.\n\nindexPsi::Union{Int64, VoronoiFVM.AbstractQuantity}\nThis variable stores the index of the electric potential. Based on the user choice we have with this new type the opportunity to simulate with Quantities or integer indices.\n\nparams::ChargeTransportParams\nA struct holding all region dependent parameter information. For more information see struct ChargeTransportParams.\n\nparamsnodal::ChargeTransportParamsNodal\nA struct holding all space dependent parameter information. For more information see struct ChargeTransportParamsNodal.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.ChargeTransportData-Tuple{Any, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.ChargeTransportData","text":"ChargeTransportData(grid, numberOfCarriers) -> ChargeTransportData\n\n\nSimplified constructor for ChargeTransportData which only takes the grid and the numberOfCarriers as argument. Here, all necessary information including the physical parameters, but also some numerical information are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.ChargeTransportIonicChargeCarriers","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.ChargeTransportIonicChargeCarriers","text":"mutable struct ChargeTransportIonicChargeCarriers\n\nA struct holding all information necessary on the ionic charge carriers. With help of this constructor we can read out the indices the user chooses for ionic charge carrier quasi Fermi potentials and the respective regions in which they are defined. Note that it is possible to use ions as well as ion vacancies.\n\nionic_carriers::Vector{Int64}\nArray with the indices of ionic charge carriers.\n\nregions::Vector{Int64}\nCorresponding regions where ionic charge carriers are assumed to be present.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.ChargeTransportParams","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.ChargeTransportParams","text":"mutable struct ChargeTransportParams\n\nA struct holding the physical region dependent parameters for a drift-diffusion simulation of a semiconductor device.\n\nnumberOfNodes::Int64\nnumber of nodes used for the disretization of the domain mathbfOmega.\n\nnumberOfRegions::Int64\nnumber of subregions mathbfOmega_k within the domain mathbfOmega.\n\nnumberOfBoundaryRegions::Int64\nnumber of boundary regions (partial mathbfOmega)_k such that partial mathbfOmega = cup_k (partial mathbfOmega)_k.\n\nnumberOfCarriers::Int64\nnumber of moving charge carriers.\n\nnumberOfInterfaceCarriers::Int64\nnumber of present interface carriers which solely live on the boundary.\n\ntemperature::Float64\nA given constant temperature.\n\nUT::Float64\nThe thermal voltage, which reads  U_T = k_B T  q.\n\nγ::Float64\nThe parameter of the Blakemore statistics.\n\nr0::Float64\nPrefactor of electro-chemical reaction of internal boundary conditions.\n\nSchottkyBarrier::Vector{Float64}\nAn array for the given Schottky barriers at present Schotkky contacts.\n\nchargeNumbers::Vector{Float64}\nAn array with the corresponding charge numbers z_alpha for all carriers alpha.\n\nbBandEdgeEnergy::Matrix{Float64}\nAn array with the corresponding boundary band-edge energy values E_alpha in each region for each carrier alpha.\n\nbDensityOfStates::Matrix{Float64}\nAn array with the corresponding boundary effective density of states values N_alpha for each carrier alpha.\n\nbMobility::Matrix{Float64}\nA 2D array with the corresponding boundary mobility values mu_alpha in each region for each carrier alpha.\n\nbDoping::Matrix{Float64}\nA 2D array with the corresponding boundary doping values for each carrier alpha.\n\nbVelocity::Matrix{Float64}\nA 2D array with the corresponding boundary velocity values for each carrier alpha, when assuming Schottky contacts.\n\nrecombinationSRHvelocity::Matrix{Float64}\nA 2D array with the corresponding recombination surface boundary velocity values for electrons and holes.\n\nbRecombinationSRHTrapDensity::Matrix{Float64}\nA 2D array with the corresponding recombination surface boundary density values for electrons and holes.\n\ndoping::Matrix{Float64}\nA 2D array with the corresponding doping values for each carrier alpha on each region.\n\ndensityOfStates::Matrix{Float64}\nA 2D array with the corresponding effective density of states values N_alpha for each carrier alpha on each region.\n\nbandEdgeEnergy::Matrix{Float64}\nA 2D array with the corresponding band-edge energy values E_alpha for each carrier alpha on each region.\n\nmobility::Matrix{Float64}\nA 2D array with the corresponding mobility values mu_alpha for each carrier alpha on each region.\n\nrecombinationSRHLifetime::Matrix{Float64}\nA 2D array with the corresponding SRH lifetimes tau_n tau_p for electrons and holes.\n\nrecombinationSRHTrapDensity::Matrix{Float64}\nA 2D array with the corresponding SRH trap densities n_tau p_tau for electrons and holes.\n\nrecombinationAuger::Matrix{Float64}\nA 2D array with the corresponding Auger coefficients for electrons and holes.\n\ndielectricConstant::Vector{Float64}\nA region dependent dielectric constant.\n\ngenerationIncidentPhotonFlux::Vector{Float64}\nA region dependent array for the prefactor in the generation process which is the incident photon flux.\n\ngenerationUniform::Vector{Float64}\nA region dependent array for an uniform generation rate.\n\ngenerationAbsorption::Vector{Float64}\nA region dependent array for the absorption coefficient in the generation process.\n\nrecombinationRadiative::Vector{Float64}\nA region dependent array for the radiative recombination rate.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.ChargeTransportParams-Tuple{Any, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.ChargeTransportParams","text":"ChargeTransportParams(grid, numberOfCarriers) -> ChargeTransportParams\n\n\nSimplified constructor for ChargeTransportParams which only takes the grid and the numberOfCarriers as argument.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.ChargeTransportParamsNodal","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.ChargeTransportParamsNodal","text":"mutable struct ChargeTransportParamsNodal\n\nA struct holding the physical nodal, i.e. space-dependent parameters for a drift-diffusion simulation of a semiconductor device.\n\ndielectricConstant::Vector{Float64}\nA node dependent dielectric constant.\n\ndoping::Vector{Float64}\nA 1D array with the corresponding doping values on each node.\n\nmobility::Matrix{Float64}\nA 2D array with the corresponding mobility values mu_alpha for each carrier alpha on each node.\n\ndensityOfStates::Matrix{Float64}\nA 2D array with the corresponding effective density of states values N_alpha for each carrier alpha on each node.\n\nbandEdgeEnergy::Matrix{Float64}\nA 2D array with the corresponding band-edge energy values E_alpha for each carrier alpha on each node.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.ChargeTransportParamsNodal-Tuple{Any, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.ChargeTransportParamsNodal","text":"ChargeTransportParamsNodal(grid, numberOfCarriers) -> ChargeTransportParamsNodal\n\n\nSimplified constructor for ChargeTransportParamsNodal which only takes the grid and the numberOfCarriers as argument.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.ChargeTransportSystem","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.ChargeTransportSystem","text":"mutable struct ChargeTransportSystem\n\nA struct holding all information necessary for a drift-diffusion type system.\n\ndata::ChargeTransportData\nA struct holding all data information, see ChargeTransportData\n\nfvmsys::VoronoiFVM.AbstractSystem\nA struct holding system information for the finite volume system.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.ChargeTransportSystem-Tuple{Any, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.ChargeTransportSystem","text":"ChargeTransportSystem(grid, data; unknown_storage)\n\n\nSystem constructor which builds all necessary information needed based on the input parameters with special regard to additional interface models. This is the main struct in which all information on the input data, but also on the solving system, with which the calculations are performed, are stored.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.ChargeTransportTraps","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.ChargeTransportTraps","text":"mutable struct ChargeTransportTraps\n\nA struct holding all information necessary for enabling traps in the SRH recombination. With help of this constructor we can read out the index the user chooses for trap quasi Fermi potentials and the respective regions in which they are defined.\n\ntraps::Int64\nArray with the index of traps.\n\nregions::Vector{Int64}\nCorresponding regions where traps are assumed to be present.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.abstract_model_SRH","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.abstract_model_SRH","text":"abstract type abstract_model_SRH\n\nAbstract type for SRH bulk recombination model\n\n!!! compat  \nThis one will be removed in future versions.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.boundary_model","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.boundary_model","text":"abstract type boundary_model\n\nAbstract type for boundary model. Subtypes are ohmiccontact, schottkycontact and interface_model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.calculation_type","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.calculation_type","text":"abstract type calculation_type\n\nAbstract type calculation_type which distinguishes between equilibrium and out of equilibrium calculations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.diffusion_enhanced","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.diffusion_enhanced","text":"abstract type diffusion_enhanced <: ChargeTransportInSolids.flux_approximation\n\nAbstract type for diffusion enhanced flux discretization.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.excess_chemical_potential","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.excess_chemical_potential","text":"abstract type excess_chemical_potential <: ChargeTransportInSolids.flux_approximation\n\nAbstract type for excess chemical potential flux discretization.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.excess_chemical_potential_graded","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.excess_chemical_potential_graded","text":"abstract type excess_chemical_potential_graded <: ChargeTransportInSolids.flux_approximation\n\nAbstract type for excess chemical potential flux discretization for graded effective density of states and/or graded band-edge  energies. This means, use this flux when at least one of these quantities is assumed to be space-dependent.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.flux_approximation","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.flux_approximation","text":"abstract type flux_approximation\n\nAbstract type for flux discretization model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.generalized_sg","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.generalized_sg","text":"abstract type generalized_sg <: ChargeTransportInSolids.flux_approximation\n\nAbstract type for generalized Scharfetter-Gummel flux discretization. This flux approximation results in an implicit equation which needs to be solved and is exact for all Blakemore type statistics functions with abritary γ.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.generation_beer_lambert","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.generation_beer_lambert","text":"abstract type generation_beer_lambert <: generation_model\n\nAbstract type for Beer-Lambert generation.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.generation_model","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.generation_model","text":"abstract type generation_model\n\nAbstract type for generation model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.generation_none","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.generation_none","text":"abstract type generation_none <: generation_model\n\nAbstract type for no generation model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.generation_uniform","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.generation_uniform","text":"abstract type generation_uniform <: generation_model\n\nAbstract type for uniform generation.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.inEquilibrium","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.inEquilibrium","text":"abstract type inEquilibrium <: ChargeTransportInSolids.calculation_type\n\nAbstract type for equilibrium calculations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.interface_model","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.interface_model","text":"abstract type interface_model <: boundary_model\n\nAbstract type for interface model which is part of boundary model. Subtypes are given below.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.interface_model_discont_qF","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.interface_model_discont_qF","text":"abstract type interface_model_discont_qF <: interface_model\n\nAbstract type for an interface model where discontinuous  quasi Fermi potentials are needed.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.interface_model_ion_charge","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.interface_model_ion_charge","text":"abstract type interface_model_ion_charge <: interface_model\n\nAbstract type for present ion charges at interfaces.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.interface_model_none","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.interface_model_none","text":"abstract type interface_model_none <: interface_model\n\nAbstract type for no interface model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.interface_model_surface_recombination","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.interface_model_surface_recombination","text":"abstract type interface_model_surface_recombination <: interface_model\n\nAbstract type for surface recombination mechanisms.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.linearScanProtocol","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.linearScanProtocol","text":"abstract type linearScanProtocol <: scan_protocol_type\n\nAbstract type for linear scan protocol.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.model_SRH","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.model_SRH","text":"abstract type model_SRH <: abstract_model_SRH\n\nmodel_SRH as parent of several different subtypes.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.model_SRH_2species_present_trap_dens","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.model_SRH_2species_present_trap_dens","text":"abstract type model_SRH_2species_present_trap_dens <: abstract_model_SRH\n\nThis Datatype will be deleted soon.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.model_SRH_with_traps","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.model_SRH_with_traps","text":"abstract type model_SRH_with_traps <: model_SRH\n\nmodelSRHwith_traps as parent of several different subtypes.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.model_SRH_without_traps","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.model_SRH_without_traps","text":"abstract type model_SRH_without_traps <: model_SRH\n\nmodelSRHwithout_traps as parent of several different subtypes.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.model_stationary","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.model_stationary","text":"abstract type model_stationary <: model_type\n\nAbstract type for stationary simulations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.model_transient","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.model_transient","text":"abstract type model_transient <: model_type\n\nAbstract type for transient simulations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.model_type","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.model_type","text":"abstract type model_type\n\nAbstract type for model type which indicates, if we consider stationary  or transient problem.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.ohmic_contact","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.ohmic_contact","text":"Abstract type for ohmic contacts as boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.outOfEquilibrium","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.outOfEquilibrium","text":"abstract type outOfEquilibrium <: ChargeTransportInSolids.calculation_type\n\nAbstract type for out of equilibrium calculations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.scan_protocol_type","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.scan_protocol_type","text":"abstract type scan_protocol_type\n\nAbstract type for scan protocol type\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.scharfetter_gummel","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.scharfetter_gummel","text":"abstract type scharfetter_gummel <: ChargeTransportInSolids.flux_approximation\n\nAbstract type for Scharfetter-Gummel flux discretization. Choose this one, when the Boltzmann statistics function is chosen as statistics.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.scharfetter_gummel_graded","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.scharfetter_gummel_graded","text":"abstract type scharfetter_gummel_graded <: ChargeTransportInSolids.flux_approximation\n\nAbstract type for Scharfetter-Gummel flux discretization for graded effective density of states and/or graded band-edge energies. This means, use this flux when at least one of these quantities is assumed to be space-dependent.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransportInSolids.schottky_contact","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.schottky_contact","text":"Abstract type for schottky contacts as boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#Methods-2","page":"Overview on Types and Constructors","title":"Methods","text":"","category":"section"},{"location":"allindex/","page":"Overview on Types and Constructors","title":"Overview on Types and Constructors","text":"Modules = [ChargeTransportInSolids]\nOrder=[:function]","category":"page"},{"location":"allindex/#ChargeTransportInSolids.Blakemore-Tuple{Real, Real}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.Blakemore","text":"Blakemore(x::Real, γ::Real) -> Any\n\n\nThe Blakemore approximation 1(exp(-x) + γ) with variable real scalar γ, see  [Blakemore1952, \"The parameters of partially degenerate semiconductors\"].\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.Blakemore-Tuple{Real}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.Blakemore","text":"Blakemore(x::Real) -> Any\n\n\nThe Blakemore approximation 1(exp(-x) + γ) with γ = 027, see  [Blakemore1952, \"The parameters of partially degenerate semiconductors\"].\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.Boltzmann-Tuple{Real}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.Boltzmann","text":"Boltzmann(x::Real) -> Any\n\n\nThe Boltzmann statistics function exp(x).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.FermiDiracMinusOne-Tuple{Real}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.FermiDiracMinusOne","text":"FermiDiracMinusOne(x::Real) -> Any\n\n\nThe Fermi-Dirac integral of order -1 which reads  1(exp(-x) + 1), see [Blakemore1982: \"Approximations for Fermi-Dirac integrals, especially the function F_12 (η) used to describe electron density in a semiconductor\"].\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.FermiDiracOneHalfBednarczyk-Tuple{Real}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.FermiDiracOneHalfBednarczyk","text":"FermiDiracOneHalfBednarczyk(x::Real) -> Any\n\n\nThe incomplete Fermi-Dirac integral of order 1/2,  implemented according to [Bednarczyk1978,  \"The Approximation of the Fermi-Dirac integral F_12()\"].\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.FermiDiracOneHalfTeSCA-Tuple{Real}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.FermiDiracOneHalfTeSCA","text":"FermiDiracOneHalfTeSCA(x::Real) -> Any\n\n\nThe incomplete Fermi-Dirac integral of order 1/2,  implemented according to the software package TeSCA, see https://wias-berlin.de/software/index.jsp?lang=1&id=TeSCA.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.addChargeCarriers!-NTuple{9, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.addChargeCarriers!","text":"addChargeCarriers!(f, u, node, data, ipsi, iphin, iphip, n, p) -> Any\n\n\nFunction which builds right-hand side of charge carriers.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.addElectricPotential!-NTuple{5, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.addElectricPotential!","text":"addElectricPotential!(f, u, node, data, ipsi) -> Any\n\n\nFunction which builds right-hand side of Poisson equation, i.e. which builds the space charge density for outOfEquilibrium calculations.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.addTrapDensity!-NTuple{9, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.addTrapDensity!","text":"addTrapDensity!(f, u, node, data, ipsi, iphin, iphip, n, p) -> Any\n\n\nFunction which adds additional trap density to right-hand side of Poisson equation without modeling traps as own charge carrier. Note that this one may be deleted in future version.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.bflux!-NTuple{4, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.bflux!","text":"bflux!(f, u, bedge, data) -> Any\n\n\nMaster bflux! function. This is the function which enters VoronoiFVM and hands over for each boundary the flux within the boundary.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.bflux!-Tuple{Any, Any, Any, Any, Type{excess_chemical_potential}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.bflux!","text":"bflux!(f, u, bedge, data, _::Type{excess_chemical_potential}) -> Any\n\n\nThe excess chemical potential flux discretization scheme for inner boundaries.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.breaction!-NTuple{4, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.breaction!","text":"breaction!(f, u, bnode, data) -> Any\n\n\nMaster breaction! function. This is the function which enters VoronoiFVM and hands over for each boundary the chosen boundary model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.breaction!-Tuple{Any, Any, Any, Any, Type{interface_model_none}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.breaction!","text":"breaction!(f, u, bnode, data, _::Type{interface_model_none})\n\n\nThis breaction! function is chosen when no interface model is chosen.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.breaction!-Tuple{Any, Any, Any, Any, Type{ohmic_contact}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.breaction!","text":"breaction!(f, u, bnode, data, _::Type{ohmic_contact}) -> Any\n\n\nCreates ohmic boundary conditions via a penalty approach with penalty parameter delta. For example, the right-hand side for the electrostatic potential psi is implemented as\n\nfpsi  = -qdelta   ( (p - N_a) - (n - N_d) ),\n\nassuming a bipolar semiconductor. In general, we have for some given charge number z_alpha\n\nfpsi =  -qdelta  sum_alpha z_alpha  (n_alpha - C_alpha) \n\nwhere C_alpha corresponds to some doping w.r.t. the species alpha.\n\nThe boundary conditions for the charge carriers are set in the main file. Hence,\n\nfn_alpha = 0`\n\nfor all charge carriers alpha.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.breaction!-Tuple{Any, Any, Any, Any, Type{schottky_contact}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.breaction!","text":"breaction!(f, u, bnode, data, _::Type{schottky_contact}) -> Any\n\n\n[Note that this way of implementation is not well tested yet. \n\nCreates Schottky boundary conditions in a first attempt. For the electrostatic potential we assume \n\npsi = psi_S + U\n\nwhere  psi_S corresponds to a given value and U to the applied voltage. For now, the quantitity psi_S needs to be specified in the main file. For the charge carriers we assume the following\n\nfn_alpha  =  z_alpha q v_alpha (n_alpha - n_alpha 0),\n\nwhere v_alpha can be treated as a surface recombination mechanism and is given. The parameter n_alpha 0 is a given value, calculated by the statistical relation, when assuming  no electrical field and a quasi Fermi level equal to the metal work function phi, i.e.\n\nn_alpha 0= z_alpha U_T (E_alpha - phi)  q\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.bstorage!-NTuple{4, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.bstorage!","text":"bstorage!(f, u, bnode, data) -> Any\n\n\nMaster bstorage! function. This is the function which enters VoronoiFVM and hands over for each boundary the time-dependent part of the chosen boundary model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.bstorage!-Tuple{Any, Any, Any, Any, Type{interface_model_discont_qF}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.bstorage!","text":"bstorage!(f, u, bnode, data, _::Type{interface_model_discont_qF})\n\n\nNo bstorage! is used, when assuming discontinuous qF.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.bstorage!-Tuple{Any, Any, Any, Any, Type{ohmic_contact}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.bstorage!","text":"bstorage!(f, u, bnode, data, _::Type{ohmic_contact})\n\n\nNo bstorage! is used, if an ohmic and schottky contact model is chosen.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.build_system-Tuple{Any, Any, Any, Type{interface_model_discont_qF}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.build_system","text":"build_system(grid, data, unknown_storage, _)\n\n\nThe core of the new system constructor. Here, the system for discontinuous quantities is build.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.build_system-Tuple{Any, Any, Any, Type{interface_model_none}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.build_system","text":"build_system(grid, data, unknown_storage, _)\n\n\nThe core of the system constructor. Here, the system for no additional interface model is build.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.chargeDensity-NTuple{8, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.chargeDensity","text":"chargeDensity(psi0, phi, UT, EVector, chargeNumbers, dopingVector, dosVector, FVector) -> Any\n\n\nCompute the charge density, i.e. the right-hand side of Poisson's equation.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.chargeDensity-Tuple{Any, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.chargeDensity","text":"chargeDensity(ctsys, sol) -> Any\n\n\nCompute the charge density for each region separately.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.compute_densities!-Tuple{Any, Any, Any, Any, Any, Any, Bool}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.compute_densities!","text":"compute_densities!(u, data, inode, region, icc, ipsi, in_region::Bool) -> Any\n\n\nFor given potentials, compute corresponding densities. This function is needed for the method, plotting the densities.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.compute_densities!-Tuple{Any, Any, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.compute_densities!","text":"compute_densities!(grid, data, sol) -> Matrix{Real}\n\n\nFor given potentials in vector form, compute corresponding vectorized densities. [Caution: this was not tested for multidimensions.]\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.compute_energies!-Tuple{Any, Any, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.compute_energies!","text":"compute_energies!(grid, data, sol)\n\n\nFor given solution in vector form, compute corresponding vectorized band-edge energies and Fermi level. [Caution: this was not tested for multidimensions.]\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.degenerateLimit-Tuple{Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.degenerateLimit","text":"degenerateLimit(x) -> Any\n\n\nDegenerate limit of incomplete Fermi-Dirac integral of order 1/2.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.electroNeutralSolution!-Tuple{Any, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.electroNeutralSolution!","text":"electroNeutralSolution!(grid, data; Newton) -> Any\n\n\nCompute the electro-neutral solution for the Boltzmann approximation.  It is obtained by setting the left-hand side in the Poisson equation equal to zero and solving for psi. The charge carriers may obey different statitics functions. Currently, this one is not well tested for the case of charge carriers beyond electrons and holes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.electrochemicalReaction-NTuple{10, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.electrochemicalReaction","text":"electrochemicalReaction(data, u, iphia, ipsi, iphiaJunction, ipsiJunction, β, κ, DOS, E) -> Any\n\n\nElectrochemical reaction between interface and bulk ionic species. This function enters in the internal boundary reaction in case of an ion charge interface model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.enable_ionic_carriers-Tuple{}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.enable_ionic_carriers","text":"Corresponding constructor for the present ionic charge carriers and the respective regions.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.enable_traps!-Tuple{Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.enable_traps!","text":"Corresponding constructor for the present trap density and the respective regions. Note that, this one will may be deleted in future versions.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.enable_traps!-Tuple{}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.enable_traps!","text":"Corresponding constructor for the present trap density and the respective regions.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.etaFunction-NTuple{5, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.etaFunction","text":"etaFunction(psi, phi, UT, E, z) -> Any\n\n\nThe argument of the distribution function for given varphi_alpha and psi\n\nz_alpha  U_T  ( (varphi_alpha - psi) + E_alpha  q )\n\nThe parameters E_alpha and z_alpha are given as vectors. This function may be used to compute the charge density, i.e. the right-hand side of the Poisson equation.   \n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.etaFunction-Tuple{Any, Any, Any, Any, Any, Any, Bool}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.etaFunction","text":"etaFunction(u, data, node, region, icc, ipsi, in_region::Bool) -> Any\n\n\nThe argument of the distribution function\n\nz_alpha  U_T  ( (varphi_alpha - psi) + E_alpha  q )\n\nfor floats.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.etaFunction-Tuple{Any, VoronoiFVM.BNode, Any, Any, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.etaFunction","text":"etaFunction(u, bnode::VoronoiFVM.BNode, data, icc, ipsi) -> Any\n\n\nThe argument of the distribution function\n\nz_alpha  U_T  ( (varphi_alpha - psi) + E_alpha  q )\n\nfor boundary nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.etaFunction-Tuple{Any, VoronoiFVM.Node, Any, Any, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.etaFunction","text":"etaFunction(u, node::VoronoiFVM.Node, data, icc, ipsi) -> Any\n\n\nThe argument of the distribution function\n\nz_alpha  U_T  ( (varphi_alpha - psi) + E_alpha  q )\n\nfor interior nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{diffusion_enhanced}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.flux!","text":"flux!(f, u, edge, data, _::Type{diffusion_enhanced}) -> Any\n\n\nThe diffusion enhanced scheme by Bessemoulin-Chatard. Currently, the Pietra-Jüngel scheme is  used for the regularization of the removable singularity. This also works for space-dependent band-edge energy, but not for space-dependent effective DOS.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{excess_chemical_potential_graded}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.flux!","text":"flux!(f, u, edge, data, _::Type{excess_chemical_potential_graded}) -> Any\n\n\nThe excess chemical potential flux scheme for  possible space-dependent DOS and band-edge energies. For these parameters the discretization scheme is modified. [insert continuous flux etc ...]\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{excess_chemical_potential}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.flux!","text":"flux!(f, u, edge, data, _::Type{excess_chemical_potential}) -> Any\n\n\nThe excess chemical potential flux discretization scheme. This also works for space-dependent band-edge energy, but not for space-dependent effective DOS.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{generalized_sg}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.flux!","text":"flux!(f, u, edge, data, _::Type{generalized_sg}) -> Any\n\n\nThe Koprucki-Gärtner scheme. This scheme is calculated by solving a fixed point equation which arise when considering the generalized Scharfetter-Gummel scheme in case of Blakemore statistics. Hence, it should be exclusively worked with, when considering the Blakemore distribution. This also works for space-dependent band-edge energy, but not for space-dependent effective DOS.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{scharfetter_gummel_graded}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.flux!","text":"flux!(f, u, edge, data, _::Type{scharfetter_gummel_graded}) -> Any\n\n\nThe classical Scharfetter-Gummel flux scheme for  possible space-dependent DOS and band-edge energies. For these parameters the discretization scheme is modified. [insert continuous flux etc ...]\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.flux!-Tuple{Any, Any, Any, Any, Type{scharfetter_gummel}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.flux!","text":"flux!(f, u, edge, data, _::Type{scharfetter_gummel}) -> Any\n\n\nThe classical Scharfetter-Gummel flux scheme. This also works for space-dependent band-edge energy, but not for space-dependent effective DOS.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.generation-Tuple{Any, Any, Any, Type{generation_beer_lambert}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.generation","text":"generation(data, ireg, node, _::Type{generation_beer_lambert}) -> Any\n\n\nThe generation rate G, which occurs in the right-hand side of the continuity equations obeying the Beer-Lambert law.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.generation-Tuple{Any, Any, Any, Type{generation_uniform}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.generation","text":"generation(data, ireg, node, _::Type{generation_uniform}) -> Any\n\n\nThe generation rate G, which occurs in the right-hand side of the continuity equations with a uniform generation rate.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.get_BEE!-Tuple{Any, VoronoiFVM.BNode, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.get_BEE!","text":"get_BEE!(icc, bnode::VoronoiFVM.BNode, data) -> Any\n\n\nDefining locally the band-edge energy for boundary nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.get_BEE!-Tuple{Any, VoronoiFVM.Edge, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.get_BEE!","text":"get_BEE!(icc, edge::VoronoiFVM.Edge, data) -> Any\n\n\nDefining locally the band-edge energy for edges.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.get_BEE!-Tuple{Any, VoronoiFVM.Node, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.get_BEE!","text":"get_BEE!(icc, node::VoronoiFVM.Node, data) -> Any\n\n\nDefining locally the band-edge energy for interior nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.get_DOS!-Tuple{Any, VoronoiFVM.BNode, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.get_DOS!","text":"get_DOS!(icc, bnode::VoronoiFVM.BNode, data) -> Any\n\n\nDefining locally the effective DOS for boundary nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.get_DOS!-Tuple{Any, VoronoiFVM.Edge, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.get_DOS!","text":"get_DOS!(icc, edge::VoronoiFVM.Edge, data) -> Tuple{Any, Any}\n\n\nDefining locally the effective DOS for edges.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.get_DOS!-Tuple{Any, VoronoiFVM.Node, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.get_DOS!","text":"get_DOS!(icc, node::VoronoiFVM.Node, data) -> Any\n\n\nDefining locally the effective DOS for interior nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.get_current_val-NTuple{4, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.get_current_val","text":"Calculates current for time dependent problem. But caution, still need some small modification!\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.get_current_val-Tuple{Any, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.get_current_val","text":"Calculates current for stationary problem. But caution, still need some small modification!\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.inner_interface_model-Tuple{ChargeTransportData}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.inner_interface_model","text":"inner_interface_model(data)\n\n\nMethod which determines with input parameters which inner interface model  was chosen by user.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.inner_interface_model-Tuple{ChargeTransportSystem}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.inner_interface_model","text":"inner_interface_model(ctsys)\n\n\nMethod which determines with input parameters which inner interface model  was chosen by user.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.kernelSRH-Tuple{Any, Any, Any, Any, Any, Any, Type{ChargeTransportInSolids.model_SRH_stationary}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.kernelSRH","text":"kernelSRH(data, ireg, iphin, iphip, n, p, _::Type{ChargeTransportInSolids.model_SRH_stationary}) -> Any\n\n\nSRH kernel for case of using stationary formula, i.e. case where no present traps are assumed.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.kernelSRH-Tuple{Any, Any, Any, Any, Any, Any, Type{model_SRH_off}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.kernelSRH","text":"kernelSRH(data, ireg, iphin, iphip, n, p, _::Type{model_SRH_off}) -> Float64\n\n\nSRH kernel for case of non-existing rate.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.plotDiffusionEnhancements-Tuple{}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.plotDiffusionEnhancements","text":"plotDiffusionEnhancements()\n\n\nPlot diffusion enhancements.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.plotDistributions-Tuple{}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.plotDistributions","text":"plotDistributions(; Plotter)\n\n\nPlot different distribution integrals.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.plot_IV-NTuple{4, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.plot_IV","text":"plot_IV(Plotter, biasValues, IV, Δu; plotGridpoints) -> Any\n\n\nMethod for showing the total current in dependence of the applied voltage. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.plot_densities-NTuple{5, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.plot_densities","text":"plot_densities(Plotter, grid, data, sol, title; plotGridpoints) -> Any\n\n\nPlotting routine, where the charge carrier densities are depicted in dependence of space. The case of heterojunctions is tested, but yet multidimensional calculations are missing. Currently, for a matching legend, we need the following order:\n\nindex 1: electrons as charge carrier with the corresponding density n,\n\nindex 2: holes as charge carrier with the corresponding density p,\n\nindex 3: anion vacancies as charge carrier with the corresponding density a,\n\nindex 4: cation vacancies as charge carrier with the corresponding density c.\n\nOne input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ChargeTransportData}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.plot_doping","text":"plot_doping(Plotter, g::ExtendableGrids.ExtendableGrid, data::ChargeTransportData) -> Any\n\n\nPossibility to plot the considered doping. This is especially useful  for making sure that the interior and the boundary doping agree.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ChargeTransportParamsNodal}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.plot_doping","text":"Plot doping for nodal dependent doping\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.plot_electroNeutralSolutionBoltzmann-Tuple{Any, Any, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.plot_electroNeutralSolutionBoltzmann","text":"plot_electroNeutralSolutionBoltzmann(Plotter, grid, psi0; plotGridpoints) -> Any\n\n\nPlotting routine for depicting the electroneutral potential. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.plot_energies-NTuple{5, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.plot_energies","text":"plot_energies(Plotter, grid, data, sol, title; plotGridpoints) -> Any\n\n\nWith this method it is possible to plot the energies\n\nE_alpha - q psi quad textwrt space\n\nThe case of heterojunctions is tested, but yet multidimensional calculations are missing.  Currently, for a matching legend, we need the following order:\n\nindex 1: electrons as charge carrier with the corresponding density n,\n\nindex 2: holes as charge carrier with the corresponding density p,\n\nindex 3: anion vacancies as charge carrier with the corresponding density a,\n\nindex 4: cation vacancies as charge carrier with the corresponding density c.\n\nOne input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.plot_energies-Tuple{Any, ExtendableGrids.ExtendableGrid, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.plot_energies","text":"plot_energies(Plotter, grid, data)\n\n\nWith this method it is possible to depict the band-edge energies E_alpha.  This can be useful for debugging when dealing with heterojunctions.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.plot_solution-NTuple{5, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.plot_solution","text":"plot_solution(Plotter, grid, data, solution, title; plotGridpoints) -> Any\n\n\nMethod for plotting the solution vectors: the electrostatic potential psi as well as the charge carriers. The case of heterojunctions is tested, but yet multidimensional calculations are missing.  Currently, for a matching legend, we need the following order:\n\nindex 1: electrons as charge carrier with the corresponding density n,\n\nindex 2: holes as charge carrier with the corresponding density p,\n\nindex 3: anion vacancies as charge carrier with the corresponding density a,\n\nindex 4: cation vacancies as charge carrier with the corresponding density c. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.printJacobi-Tuple{Any, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.printJacobi","text":"printJacobi(node, sys)\n\n\nFirst try of debugger. Print the Jacobi matrix for a given node, i.e. the number of the node in the grid and not the excact coordinate. This is only done for the one dimensional case so far. [insert some information about VoronoiFVM]\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.reaction!-NTuple{4, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.reaction!","text":"reaction!(f, u, node, data) -> Any\n\n\nMaster reaction! function. This is the function which enters VoronoiFVM and hands over reaction terms for concrete calculation type and bulk recombination model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.reaction!-Tuple{Any, Any, Any, Any, Type{inEquilibrium}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.reaction!","text":"reaction!(f, u, node, data, _::Type{inEquilibrium}) -> Any\n\n\nReaction in case of equilibrium, i.e. no generation and recombination is considered.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.reaction!-Tuple{Any, Any, Any, Any, Type{outOfEquilibrium}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.reaction!","text":"reaction!(f, u, node, data, _::Type{outOfEquilibrium}) -> Any\n\n\nSets up the right-hand sides. Assuming a bipolar semiconductor the right-hand side for the electrostatic potential becomes\n\nfψ  = - q ((p - N_a) - (n - N_d) ) = - q  sum  n_alpha  (n_alpha - C_alpha)\n\nfor some doping C_alpha w.r.t. to the species alpha. The right-hand sides for the charge carriers read as\n\nfn_alpha =  - z_alpha  q (G -  R)\n\nfor all charge carriers n_alpha. The recombination includes radiative, Auger and Shockley-Read-Hall recombination. For latter recombination process the stationary simplification is implemented.\n\nThe recombination is only implemented for electron and holes and assumes that the electron index is 1 and the hole index is 2. \n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.set_bulk_recombination-Tuple{}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.set_bulk_recombination","text":"set_bulk_recombination(; iphin, iphip, bulk_recomb_Auger, bulk_recomb_radiative, bulk_recomb_SRH)\n\n\nCorresponding constructor for the bulk recombination model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.set_time_mesh-Tuple{Any, Any, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.set_time_mesh","text":"Gives the user a linear time mesh, this mesh is used for a linear I-V scan protocol.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.storage!-NTuple{4, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.storage!","text":"storage!(f, u, node, data) -> Any\n\n\nMaster storage! function. This is the function which enters VoronoiFVM and hands over a storage term, if we consider transient problem.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.storage!-Tuple{Any, Any, Any, Any, Type{model_transient}}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.storage!","text":"storage!(f, u, node, data, _::Type{model_transient}) -> Any\n\n\nThe storage term for time-dependent problems. Currently, for the time-dependent current densities the implicit Euler scheme is used. Hence, we have \n\nfn_alpha =  z_alpha  q _t n_alpha \n\nand for the electrostatic potential fψ = 0.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransportInSolids.trap_density!-NTuple{4, Any}","page":"Overview on Types and Constructors","title":"ChargeTransportInSolids.trap_density!","text":"trap_density!(icc, ireg, data, Et)\n\n\nCompute trap densities for a given trap energy. [Currently, only done for the Boltzmann statistics and for region dependent parameters.]\n\n\n\n\n\n","category":"method"},{"location":"examples/PSC/#Electronic-and-Ionic-Charge-Carriers","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"","category":"section"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"In the following examples we will pay attention to specific types of drift-diffusion models for the description of the charge transport in perovskite solar cells, where we have electric and ionic charge carriers. Here, we assume to have three domains, denoted by  mathbfOmega = mathbfOmega_textHTL cup mathbfOmega_textintr cup mathbfOmega_textETL    The considered unknowns are the quasi Fermi potentials of electrons holes and anion vacancies  varphi_n varphi_p varphi_a  and the electric potential  psi. The underlying PDE reads, see Abdel2021","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"beginaligned\n\t- nabla cdot (varepsilon_s nabla psi) = q Big( (p(psi varphi_p) - N_A ) - (n(psi varphi_n) - N_D) Big)\n\tq partial_t n(psi varphi_n) - nabla cdot mathbfj_n = qBigl(G(mathbfx) - R(np) Bigr) \n\tq partial_t p(psi varphi_p) + nabla cdot mathbfj_p = Bigl(G(mathbfx) - R(np) Bigr)\nendaligned","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"for  mathbfx in mathbfOmega_textHTL cup  mathbfOmega_textETL  0 t_F and for mathbfx in mathbfOmega_textintr  0 t_F we have ","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"beginaligned\n\t- nabla cdot (varepsilon_s nabla psi) = q Big( p(psi varphi_p)  - n(psi varphi_n) + a(psi varphi_a) - C_0 Big)\nq partial_t n(psi varphi_n)\t- nabla cdot mathbfj_n = Bigl(G(mathbfx) - R(np) Bigr) \n\tq partial_t p(psi varphi_p) + nabla cdot mathbfj_p = Bigl(G(mathbfx) - R(np) Bigr)\n\tq partial_t a(psi varphi_a) + nabla cdot mathbfj_a = 0\nendaligned","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"General Information The extensions to the previous discussed simulation procedure in the previous example are the following","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"another charge carrier, the anion vacancy, occurs (which is incorporated by the respective quasi Fermi potential)\nwe allow jumps within the parameters entering the state equation\nthe transient model is considered\nwe allow a generation G to be present","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"A quick survey on how to use our solver to adjust the input parameters such that these features can be simulated will be given in the following.","category":"page"},{"location":"examples/PSC/#Example-1:-Solving-the-Stationary-Problem-with-Graded-Interfaces","page":"Electronic and Ionic Charge Carriers","title":"Example 1: Solving the Stationary Problem with Graded Interfaces","text":"","category":"section"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"We assume only electric charge carriers in this example. By default, we assume abrupt inner interfaces. If one wishes to simulate graded interfaces, where for example the effective density of states and the band-edge energy may vary, we refer to Example105 for more details.","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"First, we need to define two additional thin interface layers","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"# region numbers\nregionDonor             = 1       # n doped region\nregionJunction1         = 2\nregionIntrinsic         = 3       # intrinsic region\nregionJunction2         = 4\nregionAcceptor          = 5       # p doped region","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"which need to be taken into account by the initialization of the grid.","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"Second, since we allow varying parameters within the thin interface layers, the flux discretization scheme needs to be adjusted and we need to construct a nodal dependent parameter struct","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"data.flux_approximation = scharfetter_gummel_graded\n\nparamsnodal             = ChargeTransportParamsNodal(grid, numberOfCarriers)","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"Lastly, the respective parameters need to be graded. Currently, only a linear grading is implemented.","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"paramsnodal.bandEdgeEnergy[iphin, :]  = gradingParameter(paramsnodal.bandEdgeEnergy[iphin, :],\n                                                        coord, regionTransportLayers, regionJunctions,\n                                                        h, heightLayers, lengthLayers, EC)","category":"page"},{"location":"examples/PSC/#Example-2:-A-Linear-I-V-Measurement-Scan-Protocol","page":"Electronic and Ionic Charge Carriers","title":"Example 2: A Linear I-V Measurement Scan Protocol","text":"","category":"section"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"Here, the key parts of Example106 are shortly summarized.","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"First, the charge carriers indices need to be extended since we assume here additional mobile anion vacancies","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"iphin                       = 2 # electron quasi Fermi potential\niphip                       = 1 # hole quasi Fermi potential\niphia                       = 3 # anion vacancy quasi Fermi potential\n    \nnumberOfCarriers            = 3 # electrons, holes and anion vacancies","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"Another change is the choice of model_type since we consider here the dynamic problem. Further, we need to enable the ionic charge carriers on the specific active layers.","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"data.model_type             = model_transient\ndata.enable_ionic_carriers  = enable_ionic_carriers(ionic_carriers = [iphia], regions = [regionIntrinsic])","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"Arriving now at out of equilibrium calculations, we need to specify the scanrate and other information to set the time mesh. Currently, only linear scan protocols are predefined.","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"# primary data for I-V scan protocol\nscanrate          = 1.0 * V/s\nnumber_tsteps     = 31\nendVoltage        = voltageAcceptor # bias goes until the given contactVoltage at acceptor boundary\n\n# with fixed timestep sizes we can calculate the times\n# a priori\ntvalues           = set_time_mesh(scanrate, endVoltage, number_tsteps, type_protocol = linearScanProtocol)","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"Lastly, the time loop needs to be performed. Note that within the solve! method, we need to specify the time step.","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"for istep = 2:number_tsteps\n        \n    t             = tvalues[istep]       # Actual time\n    Δu            = t * scanrate         # Applied voltage \n    Δt            = t - tvalues[istep-1] # Time step size\n        \n    # Apply new voltage\n    # set non equilibrium boundary conditions\n    set_ohmic_contact!(ctsys, bregionAcceptor, Δu)\n\n    # Solve time step problems with timestep Δt. initialGuess plays the role of the solution\n    # from last timestep\n    solve!(solution, initialGuess, ctsys, control  = control, tstep = Δt)\n\n\n    initialGuess .= solution\n\nend # time loop","category":"page"},{"location":"examples/PSC/#Example-3:-Perovskite-Solar-Cell-under-I-V-Scan-Protocol-and-Illumination","page":"Electronic and Ionic Charge Carriers","title":"Example 3: Perovskite Solar Cell under I-V Scan Protocol and Illumination","text":"","category":"section"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"Now, we can add to the previous calculation an illumination protocol. For this one needs to add","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"data.generation_model    = generation_uniform","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"and specify the uniform generation rate in each considered region, i.e.","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"for ireg in 1:numberOfRegions\n    params.generationUniform[ireg]  = generationUniform[ireg]\nend","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"where the input data is stored in generationUniform. Note that as Beer-Lambert generation is implemented, but yet not well-tested. Further, we suggest to perform a time loop while increasing the generation rate and afterwards applying the scan protocol with a full generation due to numerical stability, see for this Example107.","category":"page"},{"location":"examples/PSC/#Example-4:-Solving-a-2D-Problem","page":"Electronic and Ionic Charge Carriers","title":"Example 4: Solving a 2D Problem","text":"","category":"section"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"Lastly, the code is capable of doing multi-dimensional calculations.","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"For a 2D mesh it is possible to use a structured grid via ExtendableGrids.jl, for this see Example108. But it is also possible to use the Julia wrapper Triangulate.jl to use Jonathan Richard Shewchuk's Triangle mesh generator, see Example201 for the simulation on a rectangular grid or Example201 for a non-rectangular one.","category":"page"},{"location":"examples/PSC/","page":"Electronic and Ionic Charge Carriers","title":"Electronic and Ionic Charge Carriers","text":"Lastly, with help of the TetGen.jl wrapper, three dimensional meshes can be generated, see Example202.","category":"page"},{"location":"examples/GaAs/#Electronic-Charge-Carriers","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"","category":"section"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"In both of the following examples we solve a system of partial differential equations for the description of the current flow in a bipolar three layer device (also called van Roosbroeck system)","category":"page"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"beginaligned\n\t- nabla cdot (varepsilon_s nabla psi) = q Big( (p(psi varphi_p) - N_A ) - (n(psi varphi_n) - N_D) Big)\n\tq partial_t n(psi varphi_n) -nabla cdot mathbfj_n = -qR(np) \n\tq partial_t p(psi varphi_p) + nabla cdot mathbfj_p = -qR(np)\nendaligned","category":"page"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"for a given applied voltage. The procedure will be the following","category":"page"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"Initialize grid information\nInitialize model information\nSolve the problem in equilibrium\nSolve the problem for an applied bias ","category":"page"},{"location":"examples/GaAs/#Example-1:-Solving-the-Stationary-1D-Problem","page":"Electronic Charge Carriers","title":"Example 1: Solving the Stationary 1D Problem","text":"","category":"section"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"We consider a three layer GaAs p-i-n device in one dimension. Here, we discuss Example101_PIN.","category":"page"},{"location":"examples/GaAs/#Step-1:-Declare-grid-information","page":"Electronic Charge Carriers","title":"Step 1: Declare grid information","text":"","category":"section"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"We have three layers and two external boundaries. We want to solve the system of equations on a uniform mesh with a local grid refinement. Within this part we assign the indices of subregions and boundaries and declare from where to where the subregions are defined.","category":"page"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"# region numbers\nregionAcceptor          = 1          # p doped region\nregionIntrinsic         = 2          # intrinsic region\nregionDonor             = 3          # n doped region\nregions                 = [regionAcceptor, regionIntrinsic, regionDonor]\nnumberOfRegions         = length(regions)\n\n# boundary region numbers\nbregionAcceptor         = 1\nbregionDonor            = 2\nbregions                = [bregionAcceptor, bregionDonor]\nnumberOfBoundaryRegions = length(bregions)\n\n# grid\nrefinementfactor        = 2^(n-1)\nh_pdoping               = 2 * μm\nh_intrinsic             = 2 * μm\nh_ndoping               = 2 * μm\ncoord                   = initialize_pin_grid(refinementfactor,\n                                             h_pdoping,\n                                             h_intrinsic,\n                                             h_ndoping)\n\ngrid                    = simplexgrid(coord)\n\n# ExtendableGrids.cellmask! for defining the subregions and assigning region number\ncellmask!(grid, [0.0 * μm],[h_pdoping], regionAcceptor)\ncellmask!(grid, [h_pdoping],[h_pdoping + h_intrinsic], regionIntrinsic)\ncellmask!(grid, [h_pdoping + h_intrinsic],[h_pdoping + h_intrinsic + h_ndoping], regionDonor)","category":"page"},{"location":"examples/GaAs/#Step-2:-Declare-model-information","page":"Electronic Charge Carriers","title":"Step 2: Declare model information","text":"","category":"section"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"In this step, the indices of charge carriers need to be assigned. Automatically, the index numberOfCarriers  $ + 1 $ is set for the electric potential. Additionally, we can choose here between several other model information e.g. such as the underlying statistics function or the recombination model. The possible choices are denoted above the respective variable.","category":"page"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"# set indices of the quasi Fermi potentials\niphin                    = 1 # electron quasi Fermi potential\niphip                    = 2 # hole quasi Fermi potential\nnumberOfCarriers         = 2\n\n# initialize ChargeTransportData instance and fill in data\ndata                     = ChargeTransportData(grid, numberOfCarriers)\n\n# Following variable declares, if we want to solve stationary or transient problem\ndata.model_type          = model_stationary\n\n# Following choices are possible for F: Boltzmann, FermiDiracOneHalfBednarczyk,\n# FermiDiracOneHalfTeSCA FermiDiracMinusOne, Blakemore\ndata.F                  .= Boltzmann\n\n# Here, we need to specify which numbers are associated with electron and hole quasi Fermi\n# potential. Further, the desired recombination processes can be chosen here. By default\n# we use the stationary model for the SRH recombination.\ndata.bulk_recombination  = set_bulk_recombination(;iphin = iphin, iphip = iphip, \n                                                   bulk_recomb_Auger = true,\n                                                   bulk_recomb_radiative = true,\n                                                   bulk_recomb_SRH = true)\n\n# Following choices are possible for boundary model: For contacts currently only ohmic_contact\n# and schottky_contact are possible. For inner boundaries we have interface_model_none,\n# interface_model_surface_recombination.\ndata.boundary_type[bregionAcceptor] = ohmic_contact                       \ndata.boundary_type[bregionDonor]    = ohmic_contact   \n    \n# Following choices are possible for the flux_discretization scheme: scharfetter_gummel,\n# scharfetter_gummel_graded, excess_chemical_potential, excess_chemical_potential_graded,\n# diffusion_enhanced, generalized_sg\ndata.flux_approximation             = excess_chemical_potential","category":"page"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"Lastly, you are filling in your previously defined or externally read in parameter values.","category":"page"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"# Params is a struct which contains all necessary physical parameters. If one wants to\n# simulate space-dependent variable, one additionally needs to generate a ParamsNodal\n# struct, see Example102.\nparams                                              = ChargeTransportParams(grid,\n                                                                            numberOfCarriers)\n\nparams.temperature                                  = T\nparams.UT                                           = (kB * params.temperature) / q\nparams.chargeNumbers[iphin]                         = -1\nparams.chargeNumbers[iphip]                         =  1\n\nfor ibreg in 1:numberOfBoundaryRegions   # boundary region data\n\n    params.bDensityOfStates[iphin, ibreg]           = Nc\n    params.bDensityOfStates[iphip, ibreg]           = Nv\n    params.bBandEdgeEnergy[iphin, ibreg]            = Ec\n    params.bBandEdgeEnergy[iphip, ibreg]            = Ev\nend\n\nfor ireg in 1:numberOfRegions           # interior region data\n\n    params.dielectricConstant[ireg]                 = εr\n\n    # effective DOS, band-edge energy and mobilities\n    params.densityOfStates[iphin, ireg]             = Nc\n    params.densityOfStates[iphip, ireg]             = Nv\n    params.bandEdgeEnergy[iphin, ireg]              = Ec\n    params.bandEdgeEnergy[iphip, ireg]              = Ev\n    params.mobility[iphin, ireg]                    = mun\n    params.mobility[iphip, ireg]                    = mup\n\n    # recombination parameters\n    params.recombinationRadiative[ireg]             = Radiative\n    params.recombinationSRHLifetime[iphin, ireg]    = SRH_LifeTime\n    params.recombinationSRHLifetime[iphip, ireg]    = SRH_LifeTime\n    params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity\n    params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity\n    params.recombinationAuger[iphin, ireg]          = Auger\n    params.recombinationAuger[iphip, ireg]          = Auger\n\nend\n\n# interior doping\nparams.doping[iphin, regionDonor]                   = Nd   \nparams.doping[iphin, regionIntrinsic]               = ni    \nparams.doping[iphip, regionIntrinsic]               = 0.0     \nparams.doping[iphip, regionAcceptor]                = Na\n\n# boundary doping\nparams.bDoping[iphin, bregionDonor]                 = Nd     \nparams.bDoping[iphip, bregionAcceptor]              = Na \n\n# Region dependent params is now a substruct of data which is again a substruct of the\n# system and will be parsed in next step.\ndata.params                                         = params\n\n# in the last step, we initialize our system with previous data which is likewise dependent\n# on the parameters. Important that this is in the end, otherwise our VoronoiFVMSys is\n# not dependent on the data we initialized but rather on default data.\nctsys                                               = ChargeTransportSystem(grid, data, \n                                                            unknown_storage=unknown_storage)","category":"page"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"For this system we apply ohmic contacts. For the equilibrium calculations the applied voltage is zero.","category":"page"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"set_ohmic_contact!(ctsys, bregionAcceptor, 0.0)\nset_ohmic_contact!(ctsys, bregionDonor, 0.0)","category":"page"},{"location":"examples/GaAs/#Step-3:-Solve-for-equilibrium-solution","page":"Electronic Charge Carriers","title":"Step 3: Solve for equilibrium solution","text":"","category":"section"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"With this call, the equilibrium solution will be calculated. Note that control refers to the Newton control parameters and is a struct within VoronoiFVM.","category":"page"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"solution         = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)\ninitialGuess    .= solution ","category":"page"},{"location":"examples/GaAs/#Step-4:-Solve-the-stationary-model-with-varying-applied-voltage","page":"Electronic Charge Carriers","title":"Step 4: Solve the stationary model with varying applied voltage","text":"","category":"section"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"Now, we increase the applied voltage, which is incorporated to the model by the quasi Fermi potential boundary conditions, and solve the underlying problem for each new set of boundary conditions. Note that it is important to mark that we are now in outOfEqulibrium calculations.","category":"page"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"ctsys.data.calculation_type  = outOfEquilibrium\nmaxBias                      = voltageAcceptor # bias goes until the given contactVoltage at acceptor boundary\nbiasValues                   = range(0, stop = maxBias, length = 32)\n\nfor Δu in biasValues\n\n    # set non equilibrium boundary conditions\n    set_ohmic_contact!(ctsys, bregionAcceptor, Δu)\n\n    solve!(solution, initialGuess, ctsys, control = control, tstep = Inf)\n\n    initialGuess .= solution\n\nend # bias loop","category":"page"},{"location":"examples/GaAs/#Step-5:-Postprocessing","page":"Electronic Charge Carriers","title":"Step 5: Postprocessing","text":"","category":"section"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"By adding the following line to the previous loop","category":"page"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"# get I-V data\ncurrent = get_current_val(ctsys, solution)","category":"page"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"we have the possibility to calculate the total current.","category":"page"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"Further, there are several different plotting routines which help to assess the quality of the numerical solution, see ct_plotting.jl.","category":"page"},{"location":"examples/GaAs/#Example-2:-Adding-a-Nodal-Dependent-Doping","page":"Electronic Charge Carriers","title":"Example 2: Adding a Nodal Dependent Doping","text":"","category":"section"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"Now, instead of applying a region dependent doping it is possible to apply a nodal dependent one. (This is indeed also possible for other quantities, see the description of ChargeTransportParamsNodal.) For this, go to previous Step 2, where you build your parameter set and adjust the doping initialization (code snippet from Example102_PIN_nodal_doping.jl)","category":"page"},{"location":"examples/GaAs/","page":"Electronic Charge Carriers","title":"Electronic Charge Carriers","text":"paramsnodal  = ChargeTransportParamsNodal(grid, numberOfCarriers)\n\n# initialize the space dependent doping\nNDoping           =   1.0e17  / cm^3\nκ = 500.0\nfor icoord = 1:numberOfNodes\n    paramsnodal.doping[icoord] = NDoping * 0.5 * ( 1.0  +  tanh( (0.1 - coord[icoord]/μm) *κ )  - ( 1.0 + tanh( (coord[icoord]/μm - 0.2) * κ )) )\nend\n\n# parse the substruct containg the nodal dependent parameters to the struct data\ndata.paramsnodal  = paramsnodal","category":"page"},{"location":"general/#ChargeTransportInSolids.jl-–-A-drift-diffusion-solver","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"","category":"section"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"(Image: Build status) (Image: ) (Image: )","category":"page"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"This package is a prototype for solving drift-diffusion equations for the simulation of charge transport in solids that centers physics preserving discretization schemes.","category":"page"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"Concerning the spatial discretization we rely on a Voronoi finite volume method implemented within the solver VoronoiFVM.jl. Currently, we use for the time discretization an implicit Euler method.","category":"page"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"note: Note\nThis package exclusively assumes charge transport portrayed by drift-diffusion equations (Poisson equation + continuity equation(s)).","category":"page"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"The simulations in following papers are based on ChargeTransportInSolids.jl","category":"page"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"[1.] D. Abdel, P. Farrell and J. Fuhrmann. Assessing the quality of the excess chemical potential flux scheme for degenerate semiconductor device simulation. Optical and Quantum Electronics 53 (163) (2021).","category":"page"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"[2.] D. Abdel, P. Vágner, J. Fuhrmann and P. Farrell. Modelling charge transport in perovskite solar cells: Potential-based and limiting ion depletion. Electrochimica Acta 390 (2021).","category":"page"},{"location":"general/#Installation-and-First-Steps","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"Installation and First Steps","text":"","category":"section"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"The installation can be easily done via the Julia REPL by the following commands","category":"page"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"julia> using Pkg\njulia> Pkg.add(\"ChargeTransportInSolids\")\n\n## or within the package environment\njulia> ]\n(@v1.6.1) pkg> add ChargeTransportInSolids","category":"page"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"For the construction of an example the following packages need to be loaded","category":"page"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"# concrete application dependent numerical tools\njulia> using ChargeTransportInSolids\n# nonlinear partial differential equations solver (based on a Voronoi finite volume method)\njulia> using VoronoiFVM\n# package for storing grid information\njulia> using ExtendableGrids","category":"page"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"We recommend on having a look on the example files. A guide on how to understand the main parts of the example problems and, thus, how to properly build your own class of problems is explained here:","category":"page"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"Pages = [\n    \"examples/GaAs.md\",\n    \"examples/PSC.md\",\n    ]\nDepth = 2","category":"page"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"Further, the examples can be loaded and run by ","category":"page"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"julia> include(\"Example103_PSC.jl\")\nMain.Example103_PSC\njulia> Example103_PSC.main()\n\n## or if you are interested in visualization of solutions ## (currently, predefined functions only tested with PyPlot)\njulia> include(\"Example103_PSC.jl\")\nMain.Example103_PSC\njulia> Example103_PSC.main(plotting = true)","category":"page"},{"location":"general/","page":"ChargeTransportInSolids.jl – A drift-diffusion solver","title":"ChargeTransportInSolids.jl – A drift-diffusion solver","text":"Due to the encapsulation of the examples into modules, you can load as many examples as you like. If you want to modify one of the examples, consider using Revise.jl and includet.","category":"page"},{"location":"plot/#Plotting-Routines","page":"Plotting Routines","title":"Plotting Routines","text":"","category":"section"},{"location":"plot/","page":"Plotting Routines","title":"Plotting Routines","text":"The same design as in VoronoiFVM.jl is used: To avoid dependencies for this package, the plot methods defined in this package have as their first argument the module of the plotting package used.","category":"page"},{"location":"plot/","page":"Plotting Routines","title":"Plotting Routines","text":"Currently, only PyPlot was tested.","category":"page"},{"location":"backgroundinfo/#Mathematical-Description-of-the-Problem","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"","category":"section"},{"location":"backgroundinfo/#Why-are-we-interested-in-charge-transport?","page":"Mathematical Description of the Problem","title":"Why are we interested in charge transport?","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"Understanding charge transport in a medium is one of the keys to understand the (exact) physical operations taken place in this medium. Where charge transport happens, there is also an electric current flowing. ","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"These charge transport mechanisms can be captured in mathematical models. The model itself sometimes cannot be solved analytically and numerical simulations help us to solve the underlying model.","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"Now, ongoing interdisciplinary research is made for improving existing electronic devices or providing new technologies – sophisticated theoretical tools can help us to predict the behavior of these devices of interest.","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"Hence, on the one hand reliable and physically correct models and on the other hand physics preserving numerical techniques are powerful utensils for a potentially optimizations of device designs without actually building cost-worthy prototypes, just by understanding the charge transport.","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"As one might surmised, there is not only one correct way to go for the model and for the simulations tools. Hence, we introduce in the following the theoretical models we exclusively work with.","category":"page"},{"location":"backgroundinfo/#Charge-Transport-Description-via-Drift-Diffusion-Equations","page":"Mathematical Description of the Problem","title":"Charge Transport Description via Drift-Diffusion Equations","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"For describing the charge transport of carriers, denoted by  alpha with a respective density n_alpha, within a device mathbfOmega during a finite time interval  0 t_F we use drift-diffusion equations. We consider the Poisson equation for the electric potential psi","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"beginaligned\n- nabla cdot Bigl(varepsilon_s nabla psi(mathbfx t) Bigr) = q sum_alpha z_alpha Bigl( n_alpha(mathbfx t) - C_alpha(mathbfx) Bigr)\nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"Here,  varepsilon_s denotes the dielectric permittivity and $ q $ the elementary charge. The right-hand side of the Poisson equation is given by the space charge density which is the sum of charge carrier densities z_alpha n_alpha multiplied by the respective charge number and some corresponding doping $ C_\\alpha $, if given.","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"This nonlinear equation is coupled to additional continuity equations for each charge carrier $ \\alpha $, which describe the motion of free charge carriers in dependance of an electric field","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"beginaligned\nz_alpha q partial_t n_alpha +  nablacdot mathbfj_alpha \n\t= \n\tz_alpha q\tr_alpha\nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"Here, mathbfj_alpha stands for the carrier current and $ r_\\alpha $ for some production/reduction rate.","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"In our current applications we only allow specific recombination and generation processes. Further comments on this can be found in the following or in the general description of the code.","category":"page"},{"location":"backgroundinfo/#Analogy-to-Semiconductor-Theory","page":"Mathematical Description of the Problem","title":"Analogy to Semiconductor Theory","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"This package mainly focuses currently semiconductors as an application. Hence, we assume that the charge carrier density n_alpha can be linked to corresponding quasi Fermi potentials varphi_alpha via the state equation ","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"beginaligned\nn_alpha = N_alpha mathcalF_alpha Bigl(eta_alpha(psi varphi_alpha) Bigr) quad eta_alpha = z_alpha fracq (varphi_alpha - psi) + E_alphak_B T\nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"where the physical quantities are clarified in the list of notations. With this definition we can formulate the carrier current given by","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"beginaligned\n    mathbfj_alpha \n\t=\n    - (z_alpha)^2 q mu_alpha  \n    n_alpha  \n    nablavarphi_alpha\n    \nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"with the gradient of the quasi Fermi potentials as driving forces. ","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"note: Note\nThe unknowns in our simulation tool are always defined as the quasi Fermi potentials $ \\varphi_a$ and the electric potential psi.","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"For a comprehensive overview on drift-diffusion models and semiconductor applications such as the underlying numerical simulation we recommend the following books and book chapters:","category":"page"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"P. Farrell, D. H. Doan, M. Kantner, J. Fuhrmann, T. Koprucki, and N. Rotundo. “Drift-Diffusion Models”. In: Optoelectronic Device Modeling and Simulation: Fundamentals, Materials, Nanostructures, LEDs, and Amplifiers. CRC Press Taylor & Francis Group, 2017, pp. 733–771.\nS. Selberherr. Analysis and Simulation of Semiconductor Devices. Springer-Verlag, 1984.\nS. M. Sze and K. K. Ng. Physics of Semiconductor Devices. Wiley, 2006.","category":"page"},{"location":"backgroundinfo/#List-of-Notations","page":"Mathematical Description of the Problem","title":"List of Notations","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical Description of the Problem","title":"Mathematical Description of the Problem","text":"symbol physical quantity     symbol physical quantity\n$ \\alpha $ mobile charge carrier     $ n_\\alpha $ charge carrier density of $ \\alpha $\nvarepsilon_s dielectric permittivity     $ \\psi $ electrostatic potential\n$ q $ elementary charge     C doping/background charge\n$ z_\\alpha $ charge number w.r.t. $ \\alpha $     $ r_\\alpha $ production/reaction rate w.r.t. $ \\alpha $\n$ N_\\alpha $ effective density of states w.r.t. $ \\alpha $     $ \\mathcal{F}_\\alpha $ statistics function\n$ \\varphi_\\alpha $ quasi Fermi potential w.r.t. $ \\alpha $     $ E_\\alpha $ band-edge energy w.r.t. $ \\alpha $\n$ k_B $ Boltzmann constant     $ T $ temperature\n$ \\mu_\\alpha $ mobility of carrier $ \\alpha $      ","category":"page"},{"location":"","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"}]
}
