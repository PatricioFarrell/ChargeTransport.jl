var documenterSearchIndex = {"docs":
[{"location":"GeneralInformation/#generalDescription","page":"Code overview","title":"Code overview","text":"","category":"section"},{"location":"GeneralInformation/","page":"Code overview","title":"Code overview","text":"The following flow chart explains what needs to be defined when designing new examples. The important information is stored in the Data struct with the most important components listed here.","category":"page"},{"location":"GeneralInformation/","page":"Code overview","title":"Code overview","text":"(Image: Code Structure)","category":"page"},{"location":"examples/Ex104_PSC_Photogeneration/#PSC-device-with-photogeneration-rate-(1D).","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"","category":"section"},{"location":"examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"Simulating a three layer PSC device TiO2 | MAPI | Pedot with mobile ions where the ion vacancy accumulation is limited by the Fermi-Dirac integral of order -1.","category":"page"},{"location":"examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"We perform a linear scan protocol and try out different photogeneration rates.","category":"page"},{"location":"examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"module Ex104_PSC_Photogeneration\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot\n\nfunction main(;n = 5, Plotter = PyPlot, plotting = false, verbose = false, test = false,\n              ########################\n              parameter_file = \"../parameter_files/Params_PSC_TiO2_MAPI_spiro.jl\", # choose the parameter file\n              ########################\n              userdefinedGeneration = false) # you can choose between predefined and user-defined generation profiles\n\n    Plotter.close(\"all\")\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    include(parameter_file) # include the parameter file we specified\n\n    # contact voltage\n    voltageAcceptor = 1.2 * V\n\n    # primary data for I-V scan protocol\n    scanrate        = 0.04 * V/s\n    number_tsteps   = 31\n    endVoltage      = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    tend            = endVoltage/scanrate\n\n    # Define scan protocol function\n    function scanProtocol(t)\n\n        if    0.0 <= t  && t <= tend\n            biasVal = 0.0 + scanrate * t\n        elseif  t > tend  && t <= 2*tend\n            biasVal = scanrate * tend .+ scanrate * (tend - t)\n        else\n            biasVal = 0.0\n        end\n\n        return biasVal\n\n    end\n\n    # Apply zero voltage on left boundary and a linear scan protocol on right boundary\n    contactVoltageFunction = [zeroVoltage, scanProtocol]\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    δ                = 4*n        # the larger, the finer the mesh\n    t                = 0.5*(cm)/δ # tolerance for geomspace and glue (with factor 10)\n    k                = 1.5        # the closer to 1, the closer to the boundary geomspace\n\n    coord_n_u        = collect(range(0.0, h_ndoping/2, step=h_ndoping/(0.8*δ)))\n    coord_n_g        = geomspace(h_ndoping/2,\n                                 h_ndoping,\n                                 h_ndoping/(0.7*δ),\n                                 h_ndoping/(1.1*δ),\n                                 tol=t)\n    coord_i_g1       = geomspace(h_ndoping,\n                                 h_ndoping+h_intrinsic/k,\n                                 h_intrinsic/(2.8*δ),\n                                 h_intrinsic/(2.1*δ),\n                                 tol=t)\n    coord_i_g2       = geomspace(h_ndoping+h_intrinsic/k,\n                                 h_ndoping+h_intrinsic,\n                                 h_intrinsic/(2.1*δ),\n                                 h_intrinsic/(2.8*δ),\n                                 tol=t)\n    coord_p_g        = geomspace(h_ndoping+h_intrinsic,\n                                 h_ndoping+h_intrinsic+h_pdoping/2,\n                                 h_pdoping/(1.6*δ),\n                                 h_pdoping/(1.6*δ),\n                                 tol=t)\n    coord_p_u        = collect(range(h_ndoping+h_intrinsic+h_pdoping/2, h_ndoping+h_intrinsic+h_pdoping, step=h_pdoping/(1.3*δ)))\n\n    coord            = glue(coord_n_u, coord_n_g,  tol=10*t)\n    coord            = glue(coord,     coord_i_g1, tol=10*t)\n    coord            = glue(coord,     coord_i_g2, tol=10*t)\n    coord            = glue(coord,     coord_p_g,  tol=10*t)\n    coord            = glue(coord,     coord_p_u,  tol=10*t)\n    grid             = ExtendableGrids.simplexgrid(coord)\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm],        [heightLayers[1]], regionDonor,     tol = 1.0e-18) # n-doped region   = 1\n    cellmask!(grid, [heightLayers[1]], [heightLayers[2]], regionIntrinsic, tol = 1.0e-18) # intrinsic region = 2\n    cellmask!(grid, [heightLayers[2]], [heightLayers[3]], regionAcceptor,  tol = 1.0e-18) # p-doped region   = 3\n\n    bfacemask!(grid, [heightLayers[1]], [heightLayers[1]], bregionJ1,      tol = 1.0e-18)\n    bfacemask!(grid, [heightLayers[2]], [heightLayers[2]], bregionJ2,      tol = 1.0e-18)\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend=:lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    if userdefinedGeneration\n\n        subg1          = subgrid(grid, [regionDonor]); subg2 = subgrid(grid, [regionIntrinsic]); subg3 = subgrid(grid, [regionAcceptor])\n\n        gen1           = zeros(length(subg1[Coordinates])-1); gen3 = zeros(length(subg3[Coordinates])-1)\n        gen2           = incidentPhotonFlux[regionIntrinsic] .* absorption[regionIntrinsic] .* exp.( - absorption[regionIntrinsic] .* (subg2[Coordinates] .- generationPeak))\n\n        weight1        = (subg2[Coordinates][1] - subg1[Coordinates][end-1]) / (subg2[Coordinates][2]-subg1[Coordinates][end-1])\n        weight2        = (subg2[Coordinates][end] - subg2[Coordinates][end-1]) / (subg3[Coordinates][2]-subg2[Coordinates][end-1])\n\n        gen2[1]        = weight1 * gen2[1]; gen2[end] = weight2 * gen2[end]\n\n        generationData = [gen1; gen2'; gen3]\n\n        data                          = Data(grid, numberOfCarriers,\n                                             contactVoltageFunction = contactVoltageFunction,\n                                             generationData = generationData)\n    else\n\n        data                          = Data(grid, numberOfCarriers,\n                                             contactVoltageFunction = contactVoltageFunction)\n\n    end\n\n    data.modelType                     = Transient\n    data.F                             = [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = false,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n    data.fluxApproximation            .= ExcessChemicalPotential\n\n    enable_ionic_carrier!(data, ionicCarrier = iphia, regions = [regionIntrinsic])\n\n    if userdefinedGeneration\n        data.generationModel           = GenerationUserDefined\n    else\n        data.generationModel           = GenerationBeerLambert\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                              = Params(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = zn\n    params.chargeNumbers[iphip]                         = zp\n    params.chargeNumbers[iphia]                         = za\n\n    for ireg in 1:numberOfRegions # interior region data\n\n        params.dielectricConstant[ireg]                 = ε[ireg] * ε0\n\n        # effective DOS, band edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = Nn[ireg]\n        params.densityOfStates[iphip, ireg]             = Np[ireg]\n        params.densityOfStates[iphia, ireg]             = Na[ireg]\n\n        params.bandEdgeEnergy[iphin, ireg]              = En[ireg]\n        params.bandEdgeEnergy[iphip, ireg]              = Ep[ireg]\n        params.bandEdgeEnergy[iphia, ireg]              = Ea[ireg]\n\n        params.mobility[iphin, ireg]                    = μn[ireg]\n        params.mobility[iphip, ireg]                    = μp[ireg]\n        params.mobility[iphia, ireg]                    = μa[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]    = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = trap_density!(iphin, ireg, params, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg] = trap_density!(iphip, ireg, params, EI[ireg])\n\n        # generation parameters\n        params.generationIncidentPhotonFlux[ireg]       = incidentPhotonFlux[ireg]\n        params.generationAbsorption[ireg]               = absorption[ireg]\n        params.generationUniform[ireg]                  = generation_uniform[ireg]\n    end","category":"page"},{"location":"examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"parameter which passes the shift information in the Beer-Lambert generation","category":"page"},{"location":"examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"    params.generationPeak                               = generationPeak\n\n    # interior doping\n    params.doping[iphin, regionDonor]                   = Cn\n    params.doping[iphia, regionIntrinsic]               = Ca\n    params.doping[iphip, regionAcceptor]                = Cp\n\n    data.params                                         = params\n    ctsys                                               = System(grid, data, unknown_storage=:sparse)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control              = SolverControl()\n    if verbose == true\n        control.verbose  = verbose\n    else\n        control.verbose  = \"eda\" # still print the time values\n    end\n    if test == true\n        control.verbose  = false # do not show time values in testing case\n    end\n    control.maxiters     = 300\n    control.max_round    = 5\n    control.damp_initial = 0.5\n    control.damp_growth  = 1.21 # >= 1\n    control.Δt_max       = 5.0e-1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # calculate equilibrium solution and as initial guess\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival   = solution\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Loop for generation\")\n    end\n    ################################################################################","category":"page"},{"location":"examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"these values are needed for putting the generation slightly on","category":"page"},{"location":"examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"    I      = collect(20:-1:0.0)\n    LAMBDA = 10 .^ (-I)\n\n    # since the constant which represents the constant quasi Fermi potential of anion vacancies is undetermined, we need\n    # to fix it in the bias loop, since we have no applied bias. Otherwise we get convergence errors\n    ctsys.fvmsys.boundary_factors[iphia, bregionJ2] = 1.0e30\n    ctsys.fvmsys.boundary_values[iphia, bregionJ2]  = 0.0\n\n    for istep = 1:length(I)-1\n\n        # turn slowly generation on\n        ctsys.data.λ2   = LAMBDA[istep + 1]\n\n        if test == false\n            println(\"increase generation with λ2 = $(data.λ2)\")\n        end\n\n        solution = solve(ctsys, inival = inival, control = control)\n        inival   = solution\n\n    end # generation loop\n\n    solutionEQ = inival\n\n    if plotting\n        label_solution, label_density, label_energy, label_BEE = set_plotting_labels(data)\n\n        # add labels for anion vacancy\n        label_energy[1, iphia] = \"\\$E_a-q\\\\psi\\$\"; label_energy[2, iphia] = \"\\$ - q \\\\varphi_a\\$\"; label_BEE[iphia] = \"\\$E_a\\$\"\n        label_density[iphia]   = \"\\$ n_a \\$\";      label_solution[iphia]  = \"\\$ \\\\varphi_a\\$\"\n\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"Initial condition\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"Initial condition\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"IV Measurement loop\")\n    end\n    ################################################################################\n\n    # put here back the homogenous Neumann boundary conditions.\n    ctsys.fvmsys.boundary_factors[iphia, bregionJ2] = 0.0\n    ctsys.fvmsys.boundary_values[iphia, bregionJ2]  = 0.0\n\n    sol = solve(ctsys, inival = inival, times=(0.0, tend), control = control)\n\n    if plotting\n        tsol = sol(tend)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, tsol, \"Densities at end time\", label_density)\n        Plotter.tight_layout()\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, tsol, \"Solution at end time\", label_solution)\n        Plotter.tight_layout()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Reverse scan protocol\")\n    end\n    ################################################################################\n\n    inivalReverse = sol(tend)\n    solReverse    = solve(ctsys, inival = inivalReverse, times=(tend, 2 * tend), control = control)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"IV Curve calculation\")\n    end\n    ################################################################################\n\n    factory       = TestFunctionFactory(ctsys)\n    tf            = testfunction(factory, [bregionDonor], [bregionAcceptor])\n\n    tvalues       = sol.t\n    number_tsteps = length(tvalues)\n    biasValues    = scanProtocol.(tvalues)\n    IV            = zeros(0)\n\n    for istep = 2:number_tsteps\n        Δt       = tvalues[istep] - tvalues[istep-1] # Time step size\n        inival   = sol[istep-1]\n        solution = sol[istep]\n\n        I        = integrate(ctsys, tf, solution, inival, Δt)\n\n        current = 0.0\n        for ii = 1:numberOfCarriers+1\n            current = current + I[ii]\n        end\n\n        push!(IV, current)\n\n    end\n\n    tvaluesReverse       = solReverse.t\n    number_tstepsReverse = length(tvaluesReverse)\n    biasValuesReverse    = scanProtocol.(tvaluesReverse)\n    IVReverse            = zeros(0)\n\n    for istep = 2:number_tstepsReverse\n        Δt       = tvaluesReverse[istep] - tvaluesReverse[istep-1] # Time step size\n        inival   = solReverse[istep-1]\n        solution = solReverse[istep]\n\n        I        = integrate(ctsys, tf, solution, inival, Δt)\n\n        current = 0.0\n        for ii = 1:numberOfCarriers+1\n            current = current + I[ii]\n        end\n\n        push!(IVReverse, current)\n\n    end\n\n    if plotting\n        Plotter.figure()\n        Plotter.plot([tvalues tvaluesReverse], [biasValues biasValuesReverse], marker = \"x\")\n        Plotter.xlabel(\"time [s]\")\n        Plotter.ylabel(\"voltage [V]\")\n        Plotter.grid()\n\n        Plotter.figure()\n        Plotter.plot(biasValues[2:end], -IV, linewidth = 5, label = \"forward\")\n        Plotter.plot(biasValuesReverse[2:end], -IVReverse, linewidth = 5, label = \"reverse\")\n        Plotter.grid()\n        Plotter.legend()\n        Plotter.xlabel(\"applied bias [V]\")\n        Plotter.ylabel(\"total current [A]\")\n\n        Plotter.figure()\n        if userdefinedGeneration\n            Plotter.plot(coord, data.generationData)\n        else\n            for ireg = 1:numberOfRegions\n                subg = subgrid(grid, [ireg])\n                Plotter.plot(subg[Coordinates]', BeerLambert(ctsys, ireg, subg[Coordinates])', label = \"region $ireg\")\n            end\n\n        end\n        Plotter.legend()\n        Plotter.grid()\n        Plotter.xlabel(\"space [\\$m\\$]\")\n        Plotter.ylabel(\"photogeneration [\\$\\\\frac{1}{cm^3s}\\$]\")\n        Plotter.tight_layout()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute fill factor and efficiency\")\n    end\n    ################################################################################\n\n    bias                      = biasValues[2:end]\n    IV                        = -IV\n\n    powerDensity              = bias .* (IV)           # power density function\n    MaxPD, indexPD            = findmax(powerDensity)\n\n    open_circuit              = compute_open_circuit_voltage(bias, IV)\n\n    IncidentLightPowerDensity = 1000.0 * W/m^2\n\n    efficiency                =  bias[indexPD] * IV[indexPD]  / IncidentLightPowerDensity\n    fillfactor                = (bias[indexPD] * IV[indexPD]) / (IV[1] * open_circuit)\n\n    if test == false\n        println(\"The fill factor is $fillfactor %.\")\n        println(\"The efficiency  is $efficiency %.\")\n        println(\"The open circuit voltage  is $open_circuit.\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = sum(filter(!isnan, solutionEQ))/length(solutionEQ) # when using sparse storage, we get NaN values in solution\n    return testval\n\nend #  main\n\nfunction test()\n    testval = -1.052813874410313; testvalUserdefined = -1.0528971495353738\n    main(test = true, userdefinedGeneration = false) ≈ testval && main(test = true, userdefinedGeneration = true) ≈ testvalUserdefined\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"","category":"page"},{"location":"examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Grid_3D/#Example-code-for-a-3D-grid.","page":"Example code for a 3D grid.","title":"Example code for a 3D grid.","text":"","category":"section"},{"location":"examples/Grid_3D/","page":"Example code for a 3D grid.","title":"Example code for a 3D grid.","text":"(source code)","category":"page"},{"location":"examples/Grid_3D/","page":"Example code for a 3D grid.","title":"Example code for a 3D grid.","text":"This code provides an unstructured grid for a three-dimensional domain with an additional quadratic hole within the device. The grid is produced with TetGen.jl.","category":"page"},{"location":"examples/Grid_3D/","page":"Example code for a 3D grid.","title":"Example code for a 3D grid.","text":"module Grid_3D\n\nusing ExtendableGrids\n\nusing ChargeTransport\n# For using this example, one additionally needs to add TetGen. SimplexGridFactory is a wrapper for using this meshgenerator.\nusing SimplexGridFactory\nusing TetGen\nusing GLMakie\n\nfunction main(;Plotter = GLMakie, plotting = true) # plotting is currently only tested with GLMakie and PyPlot\n\n    builder3d=let\n\n        b=SimplexGridBuilder(Generator=TetGen)\n\n        # region numbers\n        regionDonor     = 1                           # n doped region\n        regionIntrinsic = 2                           # intrinsic region\n        regionAcceptor  = 3                           # p doped region\n\n        # boundary region numbers\n        bregionDonor    = 1\n        bregionAcceptor = 2\n        bregionJ1       = 3\n        bregionJ2       = 4\n        bregionNoFlux   = 5\n\n        # grid\n        h_ndoping       = 9.90e-6 * cm\n        h_intrinsic     = 4.00e-5 * cm + 2.0e-7 * cm\n        h_pdoping       = 1.99e-5 * cm\n        height          = 3.00e-5 * cm\n        width           = 3.00e-5 * cm\n\n        # lower area (nregion)\n        Area1length_0   = point!(b, 0.0, 0.0, 0.0)\n        Area1length_n   = point!(b, h_ndoping, 0.0, 0.0)\n        Area1width_n    = point!(b, h_ndoping, width, 0)\n        Area1width_0    = point!(b, 0, width, 0)\n\n        # upper area (nregion)\n        Area2length_0   = point!(b, 0.0, 0.0, height)\n        Area2length_n   = point!(b, h_ndoping, 0.0, height)\n        Area2height_n   = point!(b, h_ndoping, width, height)\n        Area2height_0   = point!(b, 0, width, height)\n\n        # lower area (iregion)\n        Area1length_ni  = point!(b, h_ndoping + h_intrinsic, 0.0, 0.0)\n        Area1width_ni   = point!(b, h_ndoping + h_intrinsic, width, 0)\n        # upper area (iregion)\n        Area2length_ni  = point!(b, h_ndoping + h_intrinsic, 0.0, height)\n        Area2height_ni  = point!(b, h_ndoping + h_intrinsic, width, height)\n\n        # lower area (pregion)\n        Area1length_nip = point!(b, h_ndoping + h_intrinsic + h_pdoping, 0.0, 0.0)\n        Area1width_nip  = point!(b, h_ndoping + h_intrinsic + h_pdoping, width, 0)\n        # upper area (pregion)\n        Area2length_nip = point!(b, h_ndoping + h_intrinsic + h_pdoping, 0.0, height)\n        Area2height_nip = point!(b, h_ndoping + h_intrinsic + h_pdoping, width, height)\n\n        # n-region\n        facetregion!(b, bregionNoFlux) # surface below\n        facet!(b, Area1length_0, Area1length_n, Area1width_n, Area1width_0)\n        facetregion!(b, bregionNoFlux) # surface up\n        facet!(b, Area2length_0, Area2length_n, Area2height_n, Area2height_0)\n        facetregion!(b, bregionNoFlux) # surface front\n        facet!(b, Area1length_0, Area1length_n ,Area2length_n, Area2length_0)\n        facetregion!(b, bregionNoFlux) # surface back\n        facet!(b, Area1width_n, Area1width_0, Area2height_0, Area2height_n)\n\n        # i-region\n        facetregion!(b, bregionNoFlux) # surface below\n        facet!(b, Area1length_n, Area1length_ni, Area1width_ni, Area1width_n)\n        facetregion!(b, bregionNoFlux) # surface up\n        facet!(b, Area2length_n, Area2length_ni, Area2height_ni, Area2height_n)\n        facetregion!(b, bregionNoFlux) # surface front\n        facet!(b, Area1length_n, Area1length_ni, Area2length_ni, Area2length_n)\n        facetregion!(b, bregionNoFlux) # surface back\n        facet!(b, Area1width_ni, Area1width_n, Area2height_n, Area2height_ni)\n\n        # p-region\n        facetregion!(b, bregionNoFlux) # untere Oberfläche\n        facet!(b, Area1length_ni, Area1length_nip, Area1width_nip, Area1width_ni)\n        facetregion!(b, bregionNoFlux) # surface up\n        facet!(b, Area2length_ni, Area2length_nip, Area2height_nip, Area2height_ni)\n        facetregion!(b, bregionNoFlux) # surface front\n        facet!(b, Area1length_ni, Area1length_nip, Area2length_nip, Area2length_ni)\n        facetregion!(b, bregionNoFlux) # surface back\n        facet!(b, Area1width_nip, Area1width_ni, Area2height_ni, Area2height_nip)\n\n        # inner interfaces\n        facetregion!(b, bregionJ1) # inner interface n/i\n        facet!(b, Area1length_n, Area1width_n, Area2height_n, Area2length_n)\n        facetregion!(b, bregionJ2) # inner interface i/n\n        facet!(b, Area1length_ni, Area1width_ni, Area2height_ni, Area2length_ni)\n\n        facetregion!(b, bregionDonor) # metalinterface left\n        facet!(b, Area1width_0, Area1length_0, Area2length_0, Area2height_0)\n        facetregion!(b, bregionAcceptor) # metalinterface right\n        facet!(b, Area1width_nip, Area1length_nip, Area2length_nip, Area2height_nip)\n\n        distance = 8.0e-6*cm\n\n        hp1 = point!(b,h_ndoping + h_intrinsic/2 - distance ,width/2 - distance, height/2 - distance)\n        hp2 = point!(b,h_ndoping + h_intrinsic/2 + distance ,width/2 - distance, height/2 - distance)\n        hp3 = point!(b,h_ndoping + h_intrinsic/2 + distance ,width/2 + distance, height/2 - distance)\n        hp4 = point!(b,h_ndoping + h_intrinsic/2 - distance, width/2 + distance, height/2 - distance)\n        hp5 = point!(b,h_ndoping + h_intrinsic/2 - distance, width/2 - distance, height/2 + distance)\n        hp6 = point!(b,h_ndoping + h_intrinsic/2 + distance, width/2 - distance, height/2 + distance)\n        hp7 = point!(b,h_ndoping + h_intrinsic/2 + distance, width/2 + distance, height/2 + distance)\n        hp8 = point!(b,h_ndoping + h_intrinsic/2 - distance, width/2 + distance, height/2 + distance)\n\n        facetregion!(b,6)\n        facet!(b, hp1, hp2, hp3, hp4)\n        facet!(b, hp5, hp6, hp7, hp8)\n        facet!(b, hp1, hp2, hp6, hp5)\n        facet!(b, hp2, hp3, hp7, hp6)\n        facet!(b, hp3, hp4, hp8, hp7)\n        facet!(b, hp4, hp1, hp5, hp8)\n        holepoint!(b, h_ndoping + h_intrinsic/2, width/2, height/2)\n\n        cellregion!(b, regionDonor)\n        regionpoint!(b, h_ndoping-2.0e-6*cm, width/2-2.0e-6*cm, height/2-2.0e-6*cm)\n        cellregion!(b, regionIntrinsic)\n        regionpoint!(b, h_ndoping+h_intrinsic-6.0e-6*cm, width/2-6.0e-6*cm, height/2-6.0e-6*cm)\n        cellregion!(b, regionAcceptor)\n        regionpoint!(b, h_ndoping+h_intrinsic+h_pdoping-6.0e-6*cm, width/2-6.0e-6*cm, height/2-6.0e-6*cm)\n\n        options!(b, maxvolume=1.0e-24)\n\n        b\n\n    end;\n\n    grid = simplexgrid(builder3d)\n\n    if plotting == true # plotting is currently only tested with GLMakie and PyPlot\n        gridplot(Plotter = Plotter, grid, zplane=1.50e-7,azim=20,elev=60,linewidth=0.5, legend=:lt)\n    end\n\nend # main\n\nend # module","category":"page"},{"location":"examples/Grid_3D/","page":"Example code for a 3D grid.","title":"Example code for a 3D grid.","text":"","category":"page"},{"location":"examples/Grid_3D/","page":"Example code for a 3D grid.","title":"Example code for a 3D grid.","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/PSC_2D_unstructuredGrid/#PSC-device-on-2D-domain-(unstructured-grid).","page":"PSC device on 2D domain (unstructured grid).","title":"PSC device on 2D domain (unstructured grid).","text":"","category":"section"},{"location":"examples/PSC_2D_unstructuredGrid/","page":"PSC device on 2D domain (unstructured grid).","title":"PSC device on 2D domain (unstructured grid).","text":"(source code)","category":"page"},{"location":"examples/PSC_2D_unstructuredGrid/","page":"PSC device on 2D domain (unstructured grid).","title":"PSC device on 2D domain (unstructured grid).","text":"Simulating a three layer PSC device PCBM | MAPI | Pedot with mobile ions. The simulations are performed in 2D on an unstructured grid, out of equilibrium and with abrupt interfaces.","category":"page"},{"location":"examples/PSC_2D_unstructuredGrid/","page":"PSC device on 2D domain (unstructured grid).","title":"PSC device on 2D domain (unstructured grid).","text":"ENV[\"LC_NUMERIC\"]=\"C\" # put this in to work with Triangulate.jl, which is originally written in c++\n\nmodule PSC_2D_unstructuredGrid\n\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\n\n# For using this example one additionally needs to add Triangulate.\n# SimplexGridFactory is a wrapper for using this meshgenerator.\nusing SimplexGridFactory\nusing Triangulate\n\n# problem with linux, when including PyPlot not until the end: \"ERROR: LoadError: InitError: could not load library \"/home/abdel/.julia/artifacts/8cc532f6a1ace8d1b756fc413f4ab340195ec3c3/lib/libgio-2.0.so\"/home/abdel/.julia/artifacts/8cc532f6a1ace8d1b756fc413f4ab340195ec3c3/lib/libgobject-2.0.so.0: undefined symbol: g_uri_ref\"\n# It seems that this problem is common: https://discourse.julialang.org/t/could-not-load-library-librsvg-very-strange-error/21276\nusing PyPlot\n\nfunction main(Plotter = PyPlot, ;plotting = false, verbose = false, test = false,\n              parameter_file = \"../parameter_files/Params_PSC_PCBM_MAPI_Pedot.jl\", # choose the parameter file)\n            )\n\n    PyPlot.close(\"all\")\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    include(parameter_file) # include the parameter file we specified\n\n    bregionNoFlux   = 5\n    height          = 5.00e-6 * cm\n\n    # contact voltage\n    voltageAcceptor = 1.2 * V\n\n    # primary data for I-V scan protocol\n    scanrate        = 0.4 * V/s\n    number_tsteps   = 31\n    endVoltage      = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n\n    # with fixed timestep sizes we can calculate the times a priori\n    tend            = endVoltage/scanrate\n    tvalues         = range(0, stop = tend, length = number_tsteps)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    b               = SimplexGridBuilder(Generator=Triangulate)\n\n    # specify boundary nodes\n    length_0        = point!(b, 0.0, 0.0)\n    length_n        = point!(b, h_ndoping, 0.0)\n    length_ni       = point!(b, h_ndoping + h_intrinsic, 0.0)\n    length_nip      = point!(b, h_total, 0.0)\n\n    height_0        = point!(b, 0.0, height)\n    height_n        = point!(b, h_ndoping, height)\n    height_ni       = point!(b, h_ndoping + h_intrinsic, height)\n    height_nip      = point!(b, h_total, height)\n\n    # specify boundary regions\n    # metal interface\n    facetregion!(b, bregionDonor)\n    facet!(b, length_0, height_0)\n    facetregion!(b, bregionAcceptor)\n    facet!(b, length_nip, height_nip)\n\n    # no flux\n    facetregion!(b, bregionNoFlux)\n    facet!(b, length_0, length_nip)\n    facetregion!(b, bregionNoFlux)\n    facet!(b, height_0, height_nip)\n\n    # inner interface\n    facetregion!(b, bregionJ1)\n    facet!(b, length_n, height_n)\n    facetregion!(b, bregionJ2)\n    facet!(b, length_ni, height_ni)\n\n    # cell regions\n    cellregion!(b, regionDonor)\n\tregionpoint!(b, h_ndoping/2, height/2)\n    cellregion!(b, regionIntrinsic)\n\tregionpoint!(b, h_ndoping + h_intrinsic/2, height/2)\n    cellregion!(b,regionAcceptor)\n\tregionpoint!(b, h_ndoping + h_intrinsic + h_pdoping/2, height/2)\n\n    options!(b,maxvolume=1.0e-16)\n\n    grid           = simplexgrid(b)\n\n    if plotting\n        GridVisualize.gridplot(grid, Plotter= Plotter, resolution=(600,400),linewidth=0.5, legend=:lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in data\n    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Transient\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA, FermiDiracMinusOne, Blakemore\n    data.F                             = [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = false,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n\n    # Present ionic vacancies in perovskite layer\n    enable_ionic_carrier!(data, ionicCarrier = iphia, regions = [regionIntrinsic])\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation            .= ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                              = Params(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = zn\n    params.chargeNumbers[iphip]                         = zp\n    params.chargeNumbers[iphia]                         = za\n\n    for ireg in 1:numberOfRegions # interior region data\n\n        params.dielectricConstant[ireg]                 = ε[ireg] * ε0\n\n        # effective DOS, band edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = Nn[ireg]\n        params.densityOfStates[iphip, ireg]             = Np[ireg]\n        params.densityOfStates[iphia, ireg]             = Na[ireg]\n\n        params.bandEdgeEnergy[iphin, ireg]              = En[ireg]\n        params.bandEdgeEnergy[iphip, ireg]              = Ep[ireg]\n        params.bandEdgeEnergy[iphia, ireg]              = Ea[ireg]\n\n        params.mobility[iphin, ireg]                    = μn[ireg]\n        params.mobility[iphip, ireg]                    = μp[ireg]\n        params.mobility[iphia, ireg]                    = μa[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]    = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = trap_density!(iphin, ireg, params, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg] = trap_density!(iphip, ireg, params, EI[ireg])\n\n    end\n\n    # interior doping\n    params.doping[iphin, regionDonor]                   = Cn\n    params.doping[iphia, regionIntrinsic]               = Ca\n    params.doping[iphip, regionAcceptor]                = Cp\n\n    data.params                                         = params\n    ctsys                                               = System(grid, data, unknown_storage=:sparse)\n\n    # print data\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control           = SolverControl()\n    control.verbose   = verbose\n    control.maxiters  = 300\n    control.max_round = 5\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium for Boltzmann\")\n    end\n    ################################################################################\n\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival   = solution\n\n    if plotting # currently, plotting the solution was only tested with PyPlot.\n        ipsi = data.index_psi\n        X    = grid[Coordinates][1,:]\n        Y    = grid[Coordinates][2,:]\n\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[ipsi, :])\n        Plotter.title(\"Electrostatic potential \\$ \\\\psi \\$ in Equilibrium\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        Plotter.tight_layout()\n        ################\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[iphin,:] )\n        Plotter.title(\"quasi Fermi potential \\$ \\\\varphi_n \\$ in Equilibrium\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        Plotter.tight_layout()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"I-V Measurement Loop\")\n    end\n    ################################################################################\n\n    # for saving I-V data\n    IV            = zeros(0) # for IV values\n    biasValues    = zeros(0) # for bias values\n\n    for istep = 2:number_tsteps\n\n        t  = tvalues[istep]       # Actual time\n        Δu = t * scanrate         # Applied voltage\n        Δt = t - tvalues[istep-1] # Time step size\n\n        # Apply new voltage; set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: t = $(t) s\")\n        end\n\n        solution = solve(ctsys, inival = inival, control = control, tstep = Δt)\n\n        # get I-V data\n        current  = get_current_val(ctsys, solution, inival, Δt)\n\n        push!(IV, current)\n        push!(biasValues, Δu)\n\n        inival   = solution\n    end # time loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    if plotting\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[ipsi, :])\n        Plotter.title(\"Electrostatic potential \\$ \\\\psi \\$ at end time\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        # ################\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[iphin,:] )\n        Plotter.title(\"quasi Fermi potential \\$ \\\\varphi_n \\$ at end time\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        # ################\n        Plotter.figure()\n        Plotter.plot(biasValues, IV.*(cm)^2/height, label = \"\", linewidth= 3, marker=\"o\")\n        PyPlot.grid()\n        Plotter.ylabel(\"total current [A]\") #\n        Plotter.xlabel(\"Applied Voltage [V]\")\n    end\n\n    testval = sum(filter(!isnan, solution))/length(solution) # when using sparse storage, we get NaN values in solution\n    return testval\n\nend #  main\n\nfunction test()\n    testval = -0.5694033507574118\n    main(test = true) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/PSC_2D_unstructuredGrid/","page":"PSC device on 2D domain (unstructured grid).","title":"PSC device on 2D domain (unstructured grid).","text":"","category":"page"},{"location":"examples/PSC_2D_unstructuredGrid/","page":"PSC device on 2D domain (unstructured grid).","title":"PSC device on 2D domain (unstructured grid).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Non_RectangularGrid_2D/#Example-code-for-a-2D-non-rectangular-grid.","page":"Example code for a 2D non rectangular grid.","title":"Example code for a 2D non rectangular grid.","text":"","category":"section"},{"location":"examples/Non_RectangularGrid_2D/","page":"Example code for a 2D non rectangular grid.","title":"Example code for a 2D non rectangular grid.","text":"(source code)","category":"page"},{"location":"examples/Non_RectangularGrid_2D/","page":"Example code for a 2D non rectangular grid.","title":"Example code for a 2D non rectangular grid.","text":"This code provides an unstructured grid for a non rectangular two-dimensional domain. The grid is produced with Triangulate.jl.","category":"page"},{"location":"examples/Non_RectangularGrid_2D/","page":"Example code for a 2D non rectangular grid.","title":"Example code for a 2D non rectangular grid.","text":"ENV[\"LC_NUMERIC\"]=\"C\"\n\nmodule Non_RectangularGrid_2D\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot\n\n# For using this example, one additionally needs to add Triangulate. SimplexGridFactory is a wrapper for using this meshgenerator.\nusing SimplexGridFactory\nusing Triangulate\n\nfunction main(;Plotter = PyPlot, plotting = false)\n\n    # region numbers\n    regionDonor      = 1                           # n doped region\n    regionIntrinsic  = 2                           # intrinsic region\n    regionAcceptor   = 3                           # p doped region\n\n    # boundary region numbers\n    bregionDonor     = 1\n    bregionAcceptor  = 2\n    bregionJunction1 = 3\n    bregionJunction2 = 4\n    bregionNoFlux    = 5\n\n    # grid\n    h_ndoping        = 9.90e-6 * cm\n    h_intrinsic      = 4.00e-5 * cm + 2.0e-7 * cm\n    h_pdoping        = 1.99e-5 * cm\n    height           = 3.00e-5 * cm\n\n    function unsuitable(x1,y1,x2,y2,x3,y3,area)\n        bary_x=(x1+x2+x3)/3.0\n        bary_y=(y1+y2+y3)/3.0\n        dx=bary_x-refinement_center[1]\n        dy=bary_y-refinement_center[2]\n        qdist=dx^2+dy^2\n        area>0.1*max(8.0e-16,qdist)\n    end\n\n    b           = SimplexGridBuilder(Generator=Triangulate)\n\n    # specify boundary nodes\n    length_0    = point!(b, 0.0, 0.0)\n    length_n    = point!(b, h_ndoping, 0.0)\n    length_ni   = point!(b, h_ndoping + h_intrinsic, 0.0)\n    length_nip  = point!(b, h_ndoping + h_intrinsic + h_pdoping, 0.0)\n    height_0    = point!(b, 0.0, height)\n    height_n    = point!(b, h_ndoping, height)\n\n    # for L shape\n    height_ni12 = point!(b, h_ndoping + h_intrinsic/2, height)\n    height_ni2  = point!(b, h_ndoping + h_intrinsic/2, height/2)\n    height_ni   = point!(b, h_ndoping + h_intrinsic, height/2)\n    height_nip  = point!(b, h_ndoping + h_intrinsic + h_pdoping, height/2)\n\n    # specify boundary regions\n    # metal interface\n    facetregion!(b, bregionDonor)\n    facet!(b, length_0, height_0)\n    facetregion!(b, bregionAcceptor)\n    facet!(b, length_nip, height_nip)\n\n    # no flux\n    facetregion!(b, bregionNoFlux)\n    facet!(b, length_0, length_nip)\n    facetregion!(b, bregionNoFlux)\n    facet!(b, height_0, height_n)\n    facetregion!(b, bregionNoFlux)\n    facet!(b, height_0, height_ni12)\n    facetregion!(b, bregionNoFlux)\n    facet!(b, height_ni12, height_ni2)\n    facetregion!(b, bregionNoFlux)\n    facet!(b, height_ni2, height_nip)\n\n    # inner interface\n    facetregion!(b, bregionJunction1)\n    facet!(b, length_n, height_n)\n    facetregion!(b, bregionJunction2)\n    facet!(b, length_ni, height_ni)\n\n    refinement_center = [h_ndoping + h_intrinsic/2, height/2]\n    # Activate unsuitable callback\n    options!(b,unsuitable=unsuitable)\n\n    # cell regions\n    cellregion!(b, regionDonor)\n    regionpoint!(b, h_ndoping-1.0e-6*cm, height/2-1.0e-6*cm)\n    cellregion!(b,regionIntrinsic)\n    regionpoint!(b, h_ndoping + h_intrinsic -1.0e-6*cm, height/2-1.0e-6*cm)\n    cellregion!(b,regionAcceptor)\n    regionpoint!(b, h_ndoping + h_intrinsic + h_pdoping -1.0e-6*cm, height/2-1.0e-6*cm)\n\n    options!(b,maxvolume=7.0e-16)\n\n    grid = simplexgrid(b)\n\n    if plotting\n        gridplot(grid, Plotter= Plotter, resolution=(600,400),linewidth=0.6)\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.tight_layout()","category":"page"},{"location":"examples/Non_RectangularGrid_2D/","page":"Example code for a 2D non rectangular grid.","title":"Example code for a 2D non rectangular grid.","text":"builderplot(b,Plotter=Plotter,resolution=(750,700))","category":"page"},{"location":"examples/Non_RectangularGrid_2D/","page":"Example code for a 2D non rectangular grid.","title":"Example code for a 2D non rectangular grid.","text":"end\n\nend # main\n\nend # module","category":"page"},{"location":"examples/Non_RectangularGrid_2D/","page":"Example code for a 2D non rectangular grid.","title":"Example code for a 2D non rectangular grid.","text":"","category":"page"},{"location":"examples/Non_RectangularGrid_2D/","page":"Example code for a 2D non rectangular grid.","title":"Example code for a 2D non rectangular grid.","text":"This page was generated using Literate.jl.","category":"page"},{"location":"backgroundinfo/#Mathematical-drift-diffusion-models","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"ChargeTransport.jl aims to discretize charge transport models based on drift-diffusion equations. The bipolar case is sometimes referred to as van Roosbroeck system. This nonlinear system of partial differential equations couples Poisson's equation to several continuity equations. The precise type and amount will vary with the specific application.","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"In this section, we would like to describe the mathematical theory a bit more in detail. We denote with alpha the charge carrier, with n_alpha its corresponding density in a device region mathbfOmega during a finite time interval 0 t_F.","category":"page"},{"location":"backgroundinfo/#Poisson's-equation","page":"Mathematical drift-diffusion models","title":"Poisson's equation","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Poisson's equation for the electric potential psi is given by","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"beginaligned\n- nabla cdot Bigl(varepsilon_s nabla psi(mathbfx t) Bigr) = q sum_alpha z_alpha Bigl( n_alpha(mathbfx t) - C_alpha(mathbfx) Bigr)\nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Here, varepsilon_s denotes the dielectric permittivity and $ q $ the elementary charge. The right-hand side of Poisson's equation, the space charge density, is the sum of charge carrier densities n_alpha multiplied by their respective charge numbers z_alpha and some corresponding fixed charges, the doping $ C_\\alpha $.","category":"page"},{"location":"backgroundinfo/#Continuity-equations","page":"Mathematical drift-diffusion models","title":"Continuity equations","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Poisson's equation is coupled to additional continuity equations for each charge carrier alpha, which describe the motion of free charge carriers in an electric field","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"beginaligned\nz_alpha q partial_t n_alpha +  nablacdot mathbfj_alpha\n\t=\n\tz_alpha q\tr_alpha\nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Here, the flux mathbfj_alpha refers to the the carrier's current density and r_alpha to some production/reduction rates. These rates may be chosen to represent different recombination or generation models such as Shockley-Read-Hall, Auger or direct recombination.","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"The amount and type of charge carriers will be dependent on the specific application. The standard semiconductor equations use electrons alpha=n and holes alpha=p.","category":"page"},{"location":"backgroundinfo/#Drift-diffusion-fluxes","page":"Mathematical drift-diffusion models","title":"Drift-diffusion fluxes","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Our code uses as independent variables the electrostatic potential psi as well as the quasi Fermi potentials varphi_alpha. The charge carrier densities n_alpha are linked to the corresponding quasi Fermi potentials via the state equations","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"beginaligned\nn_alpha = N_alpha mathcalF_alpha Bigl(eta_alpha(psi varphi_alpha) Bigr) quad eta_alpha = z_alpha fracq (varphi_alpha - psi) + E_alphak_B T\nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"where the physical parameters are defined in the list of notations. With this definition we can formulate the carrier current given by","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"beginaligned\n    mathbfj_alpha\n\t=\n    - (z_alpha)^2 q mu_alpha\n    n_alpha\n    nablavarphi_alpha\n    \nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"with the negative gradients of the quasi Fermi potentials as driving forces. Using the state equations one may rewrite these fluxes in a drift-diffusion form.","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"note: Note\nThe unknowns in ChargeTransport.jl are always defined as the quasi Fermi potentials $ \\varphi_\\alpha$ and the electric potential psi.","category":"page"},{"location":"backgroundinfo/#Boundary-conditions","page":"Mathematical drift-diffusion models","title":"Boundary conditions","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Currently, ohmic contacts, Schottky contacts and Schottky barrier lowering boundary conditions are implemented. For further model information, please look closer to the types, constructors and methods section.","category":"page"},{"location":"backgroundinfo/#Background-literature","page":"Mathematical drift-diffusion models","title":"Background literature","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"For a comprehensive overview of drift-diffusion models, semiconductor applications as well as the underlying numerical methods, we recommend the following sources:","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"P. Farrell, D. H. Doan, M. Kantner, J. Fuhrmann, T. Koprucki, and N. Rotundo. “Drift-Diffusion Models”. In: Optoelectronic Device Modeling and Simulation: Fundamentals, Materials, Nanostructures, LEDs, and Amplifiers. CRC Press Taylor & Francis Group, 2017, pp. 733–771.\nS. Selberherr. Analysis and Simulation of Semiconductor Devices. Springer-Verlag, 1984.\nS. M. Sze and K. K. Ng. Physics of Semiconductor Devices. Wiley, 2006.","category":"page"},{"location":"backgroundinfo/#notation","page":"Mathematical drift-diffusion models","title":"Notation","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"symbol physical quantity     symbol physical quantity\n$ \\alpha $ mobile charge carrier     $ n_\\alpha $ charge carrier density of $ \\alpha $\nvarepsilon_s dielectric permittivity     $ \\psi $ electrostatic potential\n$ q $ elementary charge     $ C_\\alpha $ doping/background charge\n$ z_\\alpha $ charge number for $ \\alpha $     $ r_\\alpha $ production/reaction rate for $ \\alpha $\n$ N_\\alpha $ effective density of states for $ \\alpha $     $ \\mathcal{F}_\\alpha $ statistics function\n$ \\varphi_\\alpha $ quasi Fermi potential for $ \\alpha $     $ E_\\alpha $ band-edge energy for $ \\alpha $\n$ k_B $ Boltzmann constant     $ T $ temperature\n$ \\mu_\\alpha $ mobility of carrier $ \\alpha $      ","category":"page"},{"location":"examples/Ex108_CIGS_WithTraps/#CIGS:-stationary-with-traps-and-Schottky-contacts.","page":"CIGS: stationary with traps and Schottky contacts.","title":"CIGS: stationary with traps and Schottky contacts.","text":"","category":"section"},{"location":"examples/Ex108_CIGS_WithTraps/","page":"CIGS: stationary with traps and Schottky contacts.","title":"CIGS: stationary with traps and Schottky contacts.","text":"(source code)","category":"page"},{"location":"examples/Ex108_CIGS_WithTraps/","page":"CIGS: stationary with traps and Schottky contacts.","title":"CIGS: stationary with traps and Schottky contacts.","text":"Simulating stationary charge transport for CIGS with hole traps and mixed Schottky/Ohmic contact conditions. Assume that SRH recombination only happens within a small regime.","category":"page"},{"location":"examples/Ex108_CIGS_WithTraps/","page":"CIGS: stationary with traps and Schottky contacts.","title":"CIGS: stationary with traps and Schottky contacts.","text":"module Ex108_CIGS_WithTraps\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot\n\n# function to initialize the grid for a possble extension to other p-i-n devices.\nfunction initialize_pin_grid(refinementfactor, h_ndoping, h_pdoping_left, h_pdoping_trap, h_pdoing_right)\n    coord_ndoping    = collect(range(0.0, stop = h_ndoping, length = 2 * refinementfactor))\n    coord_pdoping_left  = collect(range(h_ndoping, stop = (h_ndoping + h_pdoping_left), length = 3 * refinementfactor))\n    coord_pdoping_plus  = collect(range((h_ndoping + h_pdoping_left),\n                                        stop = (h_ndoping + h_pdoping_left + h_pdoping_trap),\n                                        length =  refinementfactor))\n    coord_pdoping_right = collect(range((h_ndoping + h_pdoping_left + h_pdoping_trap),\n                                        stop = (h_ndoping + h_pdoping_left + h_pdoping_trap + h_pdoing_right),\n                                        length = 3 * refinementfactor))\n    coord            = glue(coord_ndoping, coord_pdoping_left)\n    coord            = glue(coord, coord_pdoping_plus)\n    coord            = glue(coord, coord_pdoping_right)\n\n    return coord\nend\n\nfunction main(;n = 3, Plotter = PyPlot, plotting = false, verbose = false, test = false, AdditionalTrapSpecies = false)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionDonor          = 1                           # n doped region\n    regionAcceptorLeft   = 2                           # p doped region\n    regionAcceptorTrap   = 3                           # p doped region with trap\n    regionAcceptorRight  = 4                           # p doped region\n    regions              = [regionDonor, regionAcceptorLeft, regionAcceptorTrap, regionAcceptorRight]\n    numberOfRegions      = length(regions)\n\n    # boundary region numbers\n    bregionDonor         = 1\n    bregionAcceptor      = 2\n    bregionDALeft        = 3\n    bregionALeftATrap    = 4\n    bregionATrapARight   = 5\n\n    # grid\n    refinementfactor     = 2^(n-1)\n    h_ndoping            = 0.5    * μm\n    h_pdoping_left       = 1.0    * μm\n    h_pdoping_trap       = 0.1    * μm\n    h_pdoing_right       = 1.0    * μm\n    w_device             = 0.5    * μm  # width of device\n    z_device             = 1.0e-4 * cm  # depth of device\n    h_total              = h_ndoping + h_pdoping_left + h_pdoping_trap + h_pdoing_right\n    coord                = initialize_pin_grid(refinementfactor,\n                                               h_ndoping,\n                                               h_pdoping_left,\n                                               h_pdoping_trap,\n                                               h_pdoing_right)\n\n    grid                 = simplexgrid(coord)\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm], [h_ndoping], regionDonor) # n doped\n    cellmask!(grid, [h_ndoping], [h_ndoping + h_pdoping_left], regionAcceptorLeft) # p doped\n    cellmask!(grid, [h_ndoping + h_pdoping_left], [h_ndoping + h_pdoping_left + h_pdoping_trap], regionAcceptorTrap) # p doped with traps\n    cellmask!(grid, [h_ndoping + h_pdoping_left + h_pdoping_trap], [h_total], regionAcceptorRight) # p doped\n\n    bfacemask!(grid, [h_ndoping], [h_ndoping], bregionDALeft, tol = 1.0e-18)\n    bfacemask!(grid, [h_ndoping + h_pdoping_left], [h_ndoping + h_pdoping_left], bregionALeftATrap, tol = 1.0e-18)\n    bfacemask!(grid, [h_ndoping + h_pdoping_left + h_pdoping_trap], [h_ndoping + h_pdoping_left + h_pdoping_trap], bregionATrapARight, tol = 1.0e-18)\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend=:lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    iphin                = 1 # index electron quasi Fermi potential\n    iphip                = 2 # index hole quasi Fermi potential\n    if AdditionalTrapSpecies\n        iphit            = 3 # index trap quasi Fermi potential\n        numberOfCarriers = 3 # electrons, holes and traps\n    else\n        numberOfCarriers = 2 # electrons and holes\n    end\n\n    # physical data\n    T                 = 300.0                *  K\n\n    # band edge energies\n    Ec_ZnO            = 3.4                  *  eV\n    Ev_ZnO            = 0.0                  *  eV\n\n    Ec_CIGS           = 3.4                  *  eV\n    Ev_CIGS           = 2.3                  *  eV\n\n    EC                = [Ec_ZnO, Ec_CIGS, Ec_CIGS, Ec_CIGS]\n    EV                = [Ev_ZnO, Ev_CIGS, Ev_CIGS, Ev_CIGS]\n\n    # effective densities of states\n    Nc                = 4.351959895879690e17 / (cm^3)\n    Nv                = 9.139615903601645e18 / (cm^3)\n\n    NC                = [Nc, Nc, Nc, Nc]\n    NV                = [Nv, Nv, Nv, Nv]\n\n    # mobilities\n    mun_ZnO           = 100                  * (cm^2) / (V * s)\n    mup_ZnO           = 25                   * (cm^2) / (V * s)\n    mun_CIGS          = 100.0                * (cm^2) / (V * s)\n    mup_CIGS          = 25                   * (cm^2) / (V * s)\n\n    μn                = [mun_ZnO, mun_CIGS, mun_CIGS, mun_CIGS]\n    μp                = [mup_ZnO, mup_CIGS, mup_CIGS, mup_CIGS]\n\n    # relative dielectric permittivity\n    εr_ZnO            = 9                    *  1.0\n    εr_CIGS           = 13.6                 *  1.0\n\n    ε                 = [εr_ZnO, εr_CIGS, εr_CIGS, εr_CIGS]\n\n    # trap information\n    zt                = 1 # hole traps\n    Et                = 2.8                  *  eV\n    ET                = [0.0, 0.0, Et, 0.0]\n    Nt                = 1.0e18               / (cm^3)\n    NT                = [0, 0, Nt, 0]\n\n    mu_t              = 0                    * (cm^2) / (V * s)\n    μt                = [0.0, 0.0, mu_t, 0.0]\n\n    # recombination information parameters\n    ni_ZnO            = sqrt(Nc * Nv) * exp(-(Ec_ZnO - Ev_ZnO) / (2 * kB * T))   # intrinsic concentration\n    n0_ZnO            = Nc * Boltzmann( (Et-Ec_ZnO) / (kB*T) )                   # Boltzmann equilibrium concentration\n    p0_ZnO            = ni_ZnO^2 / n0_ZnO                                        # Boltzmann equilibrium concentration\n    ni_CIGS           = sqrt(Nc * Nv) * exp(-(Ec_CIGS - Ev_CIGS) / (2 * kB * T)) # intrinsic concentration\n    n0_CIGS           = Nc * Boltzmann( (Et-Ec_CIGS) / (kB*T) )                  # Boltzmann equilibrium concentration\n    p0_CIGS           = ni_CIGS^2 / n0_CIGS                                      # Boltzmann equilibrium concentration\n\n    p0                = [p0_ZnO, p0_CIGS, p0_CIGS, p0_CIGS]\n    n0                = [n0_ZnO, n0_CIGS, n0_CIGS, n0_CIGS]","category":"page"},{"location":"examples/Ex108_CIGS_WithTraps/","page":"CIGS: stationary with traps and Schottky contacts.","title":"CIGS: stationary with traps and Schottky contacts.","text":"set the lifetime value high in all other regions, such that SRH recombination can be neglected there","category":"page"},{"location":"examples/Ex108_CIGS_WithTraps/","page":"CIGS: stationary with traps and Schottky contacts.","title":"CIGS: stationary with traps and Schottky contacts.","text":"    SRH_LifeTime      = [1.0e100, 1.0e100, 1.0e-3*ns, 1.0e100]\n\n    Auger             = 1.0e-29  * cm^6 / s\n    Radiative         = 1.0e-10  * cm^3 / s\n\n    # Schottky contact information\n    An                = 4 * pi * q * mₑ * kB^2 / Planck_constant^3\n    Ap                = 4 * pi * q * mₑ * kB^2 / Planck_constant^3\n    vn                = An * T^2 / (q*Nc)\n    vp                = Ap * T^2 / (q*Nv)\n    barrier           = 0.7 * eV\n\n    # doping information\n    Nd                = 1.0e18 / (cm^3)\n    Na                = 5.5e15 / (cm^3)\n\n    # we will impose this applied voltage on one boundary\n    voltageAcceptor   = 1.0 * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # initialize Data instance and fill in data\n    data                                = Data(grid, numberOfCarriers)\n    data.modelType                      = Stationary # R = Rn = Rp, since the model type is stationary\n    if AdditionalTrapSpecies\n        data.F                          = [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n    else\n        data.F                         .= FermiDiracOneHalfTeSCA\n    end\n\n    data.bulkRecombination              = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = true,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    data.boundaryType[bregionAcceptor]  = SchottkyContact\n    data.boundaryType[bregionDonor]     = OhmicContact\n    data.fluxApproximation             .= ExcessChemicalPotential\n\n    if AdditionalTrapSpecies\n        # Here, we enable the traps and parse the respective index and the regions where the trap is defined.\n        enable_trap_carrier!(;data = data, trapCarrier = iphit, regions = [regionAcceptorTrap])\n    else\n        # pass trap data in stationary setting since there is no separate trap species\n        add_trap_density_Poisson!(data = data, zt = zt, Nt = NT)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    # physical parameters\n    params                                              = Params(grid, numberOfCarriers)\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = -1\n    params.chargeNumbers[iphip]                         =  1\n    if AdditionalTrapSpecies\n        params.chargeNumbers[iphit]                     =  zt\n    end\n\n    for ireg in 1:numberOfRegions           # interior region data\n\n        params.dielectricConstant[ireg]                 = ε[ireg] * ε0\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = NC[ireg]\n        params.densityOfStates[iphip, ireg]             = NV[ireg]\n        params.bandEdgeEnergy[iphin, ireg]              = EC[ireg]\n        params.bandEdgeEnergy[iphip, ireg]              = EV[ireg]\n        params.mobility[iphin, ireg]                    = μn[ireg]\n        params.mobility[iphip, ireg]                    = μp[ireg]\n\n        if AdditionalTrapSpecies\n            params.densityOfStates[iphit, ireg]         = NT[ireg]\n            params.bandEdgeEnergy[iphit, ireg]          = ET[ireg]\n            params.mobility[iphit, ireg]                = μt[ireg]\n        end\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = Radiative\n        params.recombinationSRHLifetime[iphin, ireg]    = SRH_LifeTime[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = SRH_LifeTime[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = n0[ireg]\n        params.recombinationSRHTrapDensity[iphip, ireg] = p0[ireg]\n        params.recombinationAuger[iphin, ireg]          = Auger\n        params.recombinationAuger[iphip, ireg]          = Auger\n\n    end\n\n    # doping -- since we do not set any doping for the traps it is automatically zero\n    params.doping[iphin, regionDonor]                   = Nd\n    params.doping[iphip, regionAcceptorLeft]            = Na\n    params.doping[iphip, regionAcceptorTrap]            = Na\n    params.doping[iphip, regionAcceptorRight]           = Na\n\n    # values for the schottky contacts\n    params.SchottkyBarrier[bregionAcceptor]             = barrier\n    params.bVelocity[iphin, bregionAcceptor]            = vn\n    params.bVelocity[iphip, bregionAcceptor]            = vp\n\n    data.params                                         = params\n    ctsys                                               = System(grid, data, unknown_storage=:sparse)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control              = SolverControl()\n    control.verbose      = verbose\n    control.tol_round    = 1.0e-7\n    control.damp_initial = 0.5\n    control.damp_growth  = 1.2\n    control.maxiters     = 30\n    control.max_round    = 3\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # solve thermodynamic equilibrium and update initial guess\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival   = solution\n\n    if plotting\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        if AdditionalTrapSpecies\n            # add labels for traps\n            label_energy[1, iphit] = \"\\$E_{\\\\tau}-q\\\\psi\\$\"; label_energy[2, iphit] = \"\\$ - q \\\\varphi_{\\\\tau}\\$\"\n            label_density[iphit]   = \"\\$n_{\\\\tau}\\$\";        label_solution[iphit]  = \"\\$ \\\\varphi_{\\\\tau}\\$\"\n        end\n\n        # ##### set legend for plotting routines #####\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"Equilibrium\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution,\"Equilibrium\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"Equilibrium\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Stationary bias loop\")\n    end\n    ################################################################################\n\n    endVoltage      = voltageAcceptor       # final bias value\n    biasValues      = collect(range(0, stop = endVoltage, length = 52))\n\n    IV              = zeros(0)\n    chargeDensities = zeros(0)\n\n    for i in eachindex(biasValues)\n\n        Δu = biasValues[i] # bias\n\n        # Apply new voltage: set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"bias: Δu = $(Δu) V\")\n        end\n\n        # solve time step problems with timestep Δt\n        solution = solve(ctsys, inival = inival, control = control)\n        inival   = solution\n\n        # save IV data\n        current = get_current_val(ctsys, solution)\n        push!(IV, w_device * z_device * current)\n\n        # store charge density in donor region (ZnO)\n        push!(chargeDensities, charge_density(ctsys, solution)[regionDonor])\n\n\n    end # bias loop\n\n    # compute static capacitance: check this is correctly computed\n    staticCapacitance = diff(chargeDensities) ./ diff(biasValues)\n\n    # plot solution and IV curve\n    if plotting\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage) V\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution,\"bias \\$\\\\Delta u\\$ = $(endVoltage) V\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage) V\", label_solution)\n        Plotter.figure()\n        plot_IV(Plotter, biasValues,IV, \"bias \\$\\\\Delta u\\$ = $(biasValues[end]) V\", plotGridpoints = true)\n        Plotter.figure()\n        plot_IV(Plotter, biasValues,chargeDensities, \"bias \\$\\\\Delta u\\$ = $(biasValues[end]) V\", plotGridpoints = true)\n        Plotter.title(\"Charge density in donor region\")\n        Plotter.ylabel(\"Charge density [C]\")\n        Plotter.figure()\n        plot_IV(Plotter, biasValues, staticCapacitance, \"bias \\$\\\\Delta u\\$ = $(biasValues[end]) V\", plotGridpoints = true)\n        Plotter.title(\"Static capacitance in donor region\")\n        Plotter.ylabel(\"Static capacitance [C/V]\")\n\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = sum(filter(!isnan, solution))/length(solution) # when using sparse storage, we get NaN values in solution\n    return testval\n\nend #  main\n\nfunction test()\n    testval                  = 1.484831264268335\n    testvalAdditionalSpecies = 1.1334257649339574\n\n    main(test = true, AdditionalTrapSpecies = false) ≈ testval && main(test = true, AdditionalTrapSpecies = true) ≈ testvalAdditionalSpecies\nend\n\nif test == false\n    println(\"This message should show when this module has successfully recompiled.\")\nend\n\n\nend # module","category":"page"},{"location":"examples/Ex108_CIGS_WithTraps/","page":"CIGS: stationary with traps and Schottky contacts.","title":"CIGS: stationary with traps and Schottky contacts.","text":"","category":"page"},{"location":"examples/Ex108_CIGS_WithTraps/","page":"CIGS: stationary with traps and Schottky contacts.","title":"CIGS: stationary with traps and Schottky contacts.","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/PSC_3D/#Illustrative-example-of-a-three-dimensional-simulation.","page":"Illustrative example of a three dimensional simulation.","title":"Illustrative example of a three dimensional simulation.","text":"","category":"section"},{"location":"examples/PSC_3D/","page":"Illustrative example of a three dimensional simulation.","title":"Illustrative example of a three dimensional simulation.","text":"(source code)","category":"page"},{"location":"examples/PSC_3D/","page":"Illustrative example of a three dimensional simulation.","title":"Illustrative example of a three dimensional simulation.","text":"This code shows the capability of 3D simulations with ChargeTransport.jl. For the sake of performance, we only do equilibrium calculations.","category":"page"},{"location":"examples/PSC_3D/","page":"Illustrative example of a three dimensional simulation.","title":"Illustrative example of a three dimensional simulation.","text":"Here, a one-dimensional and a three-dimensional simulation of the same device are performed.","category":"page"},{"location":"examples/PSC_3D/","page":"Illustrative example of a three dimensional simulation.","title":"Illustrative example of a three dimensional simulation.","text":"The parameters are based on the default parameter set of Ionmonger (with minor adjustments).","category":"page"},{"location":"examples/PSC_3D/","page":"Illustrative example of a three dimensional simulation.","title":"Illustrative example of a three dimensional simulation.","text":"module PSC_3D\n\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\n\nusing GLMakie\nusing PyPlot","category":"page"},{"location":"examples/PSC_3D/","page":"Illustrative example of a three dimensional simulation.","title":"Illustrative example of a three dimensional simulation.","text":"We strongly emphasize to use GLMakie for the visualization here.","category":"page"},{"location":"examples/PSC_3D/","page":"Illustrative example of a three dimensional simulation.","title":"Illustrative example of a three dimensional simulation.","text":"function main(;Plotter = GLMakie, plotting = false, test = false, verbose = false,\n              parameter_file = \"../parameter_files/Params_PSC_TiO2_MAPI_spiro.jl\", # choose the parameter file\n             )\n\n    PyPlot.close(\"all\")\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    include(parameter_file) # include the parameter file we specified\n\n    bregionNoFlux = 5\n    height        = 2.00e-5 * cm\n    width         = 3.00e-5 * cm\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n     if test == false\n        println(\"Set up grid and regions for 1D and 3D\")\n    end\n    ################################################################################\n\n    # 1D Grid\n    n                = 10\n    coord_ndoping    = collect(range(0.0, stop = h_ndoping, length = n))\n    coord_intrinsic  = collect(range(h_ndoping, stop = (h_ndoping + h_intrinsic), length = 2 * n))\n    coord_pdoping    = collect(range((h_ndoping + h_intrinsic), stop = (h_total), length = n))\n    coord            = glue(coord_ndoping, coord_intrinsic)\n    coord            = glue(coord, coord_pdoping)\n    grid1D           = simplexgrid(coord)\n\n    cellmask!(grid1D, [0.0 * μm],                 [h_ndoping],               regionDonor, tol = 1.0e-18)\n    cellmask!(grid1D, [h_ndoping],                [h_ndoping + h_intrinsic], regionIntrinsic, tol = 1.0e-18)\n    cellmask!(grid1D, [h_ndoping + h_intrinsic],  [h_total],                 regionAcceptor, tol = 1.0e-18)\n\n    bfacemask!(grid1D, [heightLayers[1]], [heightLayers[1]], bregionJ1) # first  inner interface\n    bfacemask!(grid1D, [heightLayers[2]], [heightLayers[2]], bregionJ2) # second inner interface\n\n    # 3D Grid\n    coord_height     = collect(range(0.0, stop = height, length = n))\n    coord_width      = collect(range(0.0, stop = width, length =  n))\n    grid3D           = simplexgrid(coord, coord_height, coord_width)\n\n    cellmask!(grid3D, [0.0, 0.0, 0.0],                   [h_ndoping, height, width],               regionDonor, tol = 1.0e-18)\n    cellmask!(grid3D, [h_ndoping, 0.0, 0.0],             [h_ndoping + h_intrinsic, height, width], regionIntrinsic, tol = 1.0e-18)\n    cellmask!(grid3D, [h_ndoping+h_intrinsic, 0.0, 0.0], [h_total, height, width],                 regionAcceptor, tol = 1.0e-18)\n\n    # metal interfaces [xmin, ymin, zmin], [xmax, ymax, zmax]\n    bfacemask!(grid3D, [0.0, 0.0, 0.0],     [0.0, height, width],     bregionDonor) # BregionNumber = 1\n    bfacemask!(grid3D, [h_total, 0.0, 0.0], [h_total, height, width], bregionAcceptor) # BregionNumber = 2\n\n    # interior interfaces\n    bfacemask!(grid3D, [heightLayers[1], 0.0, 0.0], [heightLayers[1], height, width], bregionJ1) # first  inner interface\n    bfacemask!(grid3D, [heightLayers[2], 0.0, 0.0], [heightLayers[2], height, width], bregionJ2) # second inner interface\n\n    # outer no flux interfaces\n    bfacemask!(grid3D, [0.0, 0.0, 0.0],    [h_total, 0.0, width],    bregionNoFlux)\n    bfacemask!(grid3D, [0.0, height, 0.0], [h_total, height, width], bregionNoFlux)\n    bfacemask!(grid3D, [0.0, 0.0, 0.0],    [h_total, height, 0.0],   bregionNoFlux)\n    bfacemask!(grid3D, [0.0, 0.0, width],  [h_total, height, width], bregionNoFlux)\n\n    if plotting == true # plotting is currently only tested with GLMakie and PyPlot\n        vis    = GridVisualizer(Plotter = Plotter, resolution=(1500,1500), layout=(3,2))\n        gridplot!(vis[1,1], grid1D)\n        if Plotter == PyPlot\n            gridplot!(vis[1,2], grid3D, linewidth=0.5, xplanes=[5.5e-7], zplanes=[1.5e-7])\n        elseif Plotter == GLMakie\n            gridplot!(vis[1,2], grid3D, zplane=1.0e-7,azim=20,elev=60,linewidth=0.5, scene3d=:Axis3, legend=:none)\n        end\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n       if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    # Note that we define the data struct with respect to the three-dimensional grid, since we also defined there the outer no flux boundary conditions.\n    data                               = Data(grid3D, numberOfCarriers)\n    data.modelType                     = Transient\n    data.F                             = [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = false,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n    data.boundaryType[bregionDonor]    = OhmicContact\n    data.boundaryType[bregionAcceptor] = OhmicContact\n\n    enable_ionic_carrier!(data, ionicCarrier = iphia, regions = [regionIntrinsic])\n\n    data.fluxApproximation            .= ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n      ################################################################################\n      if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                              = Params(grid3D, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = zn\n    params.chargeNumbers[iphip]                         = zp\n    params.chargeNumbers[iphia]                         = za\n\n    for ireg in 1:numberOfRegions # interior region data\n\n        params.dielectricConstant[ireg]                 = ε[ireg] * ε0\n\n        # effective DOS, band edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = Nn[ireg]\n        params.densityOfStates[iphip, ireg]             = Np[ireg]\n        params.densityOfStates[iphia, ireg]             = Na[ireg]\n\n        params.bandEdgeEnergy[iphin, ireg]              = En[ireg]\n        params.bandEdgeEnergy[iphip, ireg]              = Ep[ireg]\n        params.bandEdgeEnergy[iphia, ireg]              = Ea[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]    = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = trap_density!(iphin, ireg, params, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg] = trap_density!(iphip, ireg, params, EI[ireg])\n    end\n\n    # interior doping\n    params.doping[iphin, regionDonor]                   = Cn\n    params.doping[iphia, regionIntrinsic]               = Ca\n    params.doping[iphip, regionAcceptor]                = Cp\n\n    data.params                                         = params\n    ctsys1D                                             = System(grid1D, data, unknown_storage=:sparse)\n\n    data.params                                         = params\n    ctsys3D                                             = System(grid3D, data, unknown_storage=:sparse)\n\n    ipsi = data.index_psi\n\n    if test == false\n        show_params(ctsys1D)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Newton solver\")\n    end\n    ################################################################################\n\n    control              = SolverControl()\n    control.verbose      = verbose\n    control.maxiters     = 300\n    control.abstol       = 1.0e-10\n    control.reltol       = 1.0e-10\n    control.tol_round    = 1.0e-10\n    control.max_round    = 5\n    control.damp_initial = 0.5\n    control.damp_growth  = 1.61 # >= 1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    sol1D = equilibrium_solve!(ctsys1D, control = control, nonlinear_steps = 20)\n    sol3D = equilibrium_solve!(ctsys3D, control = control, nonlinear_steps = 20)\n\n    if plotting == true\n        #################################################\n        scalarplot!(vis[2,1], grid1D, sol1D[ipsi, :]; color=:blue, linewidth = 5, xlabel = \"space [m]\", ylabel = \"potential [V]\", title = \"Electric potential (1D)\")\n        scalarplot!(vis[2,2], grid3D, sol3D[ipsi, :]; scene3d=:Axis3, levels = 4, levelalpha = 0.9, outlinealpha = 0.00, xplanes = collect(range(0.0, stop = h_total, length = 100)), title = \"Electric potential (3D)\")\n\n        grids1D    = Array{typeof(grid1D), 1}(undef, numberOfRegions)\n        densityn1D = Array{typeof(sol1D[iphin, :]), 1}(undef, numberOfRegions)\n\n        grids3D    = Array{typeof(grid3D), 1}(undef, numberOfRegions)\n        densityn3D = Array{typeof(sol3D[iphin, :]), 1}(undef, numberOfRegions)\n        logDens3D  = Array{typeof(sol3D[iphin, :]), 1}(undef, numberOfRegions)\n\n        for ireg in 1:numberOfRegions\n            grids1D[ireg]    = subgrid(grid1D, [ireg])\n            densityn1D[ireg] = get_density(sol1D, ireg, ctsys1D, iphin)\n            #############################################################\n            grids3D[ireg]    = subgrid(grid3D, [ireg])\n            densityn3D[ireg] = get_density(sol3D, ireg, ctsys3D, iphin)\n            logDens3D[ireg]  = log.(densityn3D[ireg])\n        end\n\n        scalarplot!(vis[3,1], grids1D, grid1D, densityn1D; color=:green, linewidth = 5, yscale=:log, xlabel = \"space [m]\", ylabel = \"density [\\$\\\\frac{1}{m^3}\\$]\", title = \"Electron concentration (1D)\")\n        scalarplot!(vis[3,2], grids3D, grid3D, densityn3D; scene3d=:Axis3, levels = 4, levelalpha = 0.9, outlinealpha = 0.00, xplanes = collect(range(0.0, stop = h_total, length = 100)), title = \"Electron concentration (3D)\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = sum(filter(!isnan, sol1D))/length(sol1D) + sum(filter(!isnan, sol3D))/length(sol3D) # when using sparse storage, we get NaN values in solution\n\n    return testval\n\nend # main\n\n\nfunction test()\n    testval = -2.2213072819274533\n    main(test = true) ≈ testval\nend\n\nend # module","category":"page"},{"location":"examples/PSC_3D/","page":"Illustrative example of a three dimensional simulation.","title":"Illustrative example of a three dimensional simulation.","text":"","category":"page"},{"location":"examples/PSC_3D/","page":"Illustrative example of a three dimensional simulation.","title":"Illustrative example of a three dimensional simulation.","text":"This page was generated using Literate.jl.","category":"page"},{"location":"allindex/#Overview-–-Constants,-Types,-Constructors-and-Methods","page":"Types, Constructors and Methods","title":"Overview – Constants, Types, Constructors and Methods","text":"","category":"section"},{"location":"allindex/#Constants,-Types-and-Constructors","page":"Types, Constructors and Methods","title":"Constants, Types and Constructors","text":"","category":"section"},{"location":"allindex/","page":"Types, Constructors and Methods","title":"Types, Constructors and Methods","text":"Modules = [ChargeTransport]\nOrder=[:constant, :type]","category":"page"},{"location":"allindex/#Methods","page":"Types, Constructors and Methods","title":"Methods","text":"","category":"section"},{"location":"allindex/","page":"Types, Constructors and Methods","title":"Types, Constructors and Methods","text":"Modules = [ChargeTransport]\nOrder=[:function]","category":"page"},{"location":"allindex/#Description-of-Constant,-Types,-Constructors-and-Methods","page":"Types, Constructors and Methods","title":"Description of Constant, Types, Constructors and Methods","text":"","category":"section"},{"location":"allindex/#Constants,-Types-and-Constructors-2","page":"Types, Constructors and Methods","title":"Constants, Types and Constructors","text":"","category":"section"},{"location":"allindex/","page":"Types, Constructors and Methods","title":"Types, Constructors and Methods","text":"Modules = [ChargeTransport]\nOrder=[:constant, :type]","category":"page"},{"location":"allindex/#ChargeTransport.BarrierLoweringType","page":"Types, Constructors and Methods","title":"ChargeTransport.BarrierLoweringType","text":"Possible types for barrier lowering model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.BoundaryModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.BoundaryModelType","text":"Possible types of boundary models.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.CalculationType","page":"Types, Constructors and Methods","title":"ChargeTransport.CalculationType","text":"Possible types for calculation type.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.FluxApproximationType","page":"Types, Constructors and Methods","title":"ChargeTransport.FluxApproximationType","text":"Possible types of flux discretization schemes.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationModelType","text":"Possible types for generation model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InterfaceModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.InterfaceModelType","text":"Possible Types of interface model (interior boundary conditions).\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.ModelType","text":"Possible types which indicate, if we consider stationary or transient problem.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.OuterBoundaryModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.OuterBoundaryModelType","text":"Possible types of outer boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.QType","page":"Types, Constructors and Methods","title":"ChargeTransport.QType","text":"Type of charge carriers and the electric potential (corresponding to VoronoiFVM.jl).\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.SRHWithTrapsType","page":"Types, Constructors and Methods","title":"ChargeTransport.SRHWithTrapsType","text":"Possible types for SRH recombination without traps.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.SRHWithoutTrapsType","page":"Types, Constructors and Methods","title":"ChargeTransport.SRHWithoutTrapsType","text":"Possible type for SRH recombination without traps.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.StandardFuncSet","page":"Types, Constructors and Methods","title":"ChargeTransport.StandardFuncSet","text":"Type of statistics functions.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.BarrierLoweringOff","page":"Types, Constructors and Methods","title":"ChargeTransport.BarrierLoweringOff","text":"abstract type BarrierLoweringOff\n\nAbstract type for the neglection of Schottky barrier lowering as boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.BarrierLoweringOn","page":"Types, Constructors and Methods","title":"ChargeTransport.BarrierLoweringOn","text":"abstract type BarrierLoweringOn\n\nAbstract type for the choice of Schottky barrier lowering as boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.BulkRecombination","page":"Types, Constructors and Methods","title":"ChargeTransport.BulkRecombination","text":"mutable struct BulkRecombination\n\nA struct holding all necessary information for building bulk recombination. With help of this constructor we can read out the indices the user chooses for electron and hole quasi Fermi potentials.\n\niphin::Int64: Index for FVM construction of electron quasi Fermi potential.\n\niphip::Int64: Index for FVM construction of hole quasi Fermi potential.\n\nbulk_recomb_Auger::Bool: Boolean for present Auger recombination in bulk.\n\nbulk_recomb_radiative::Bool: Boolean for present radiative recombination in bulk.\n\nbulk_recomb_SRH::Union{Type{SRHOff}, Type{ChargeTransport.SRHStationary}, Type{SRHTrapsStationary}, Type{SRHTrapsTransient}}: DataType for present SRH recombination in bulk. This needs to be a Type due to cases with or without mobile traps.\n\nSRH_2species_trap::Union{Type{SRH2SpeciesPresentTrapDens}, Type{SRHOff}, Type{ChargeTransport.SRHStationary}}: Data type with which you can include a stationary trap density to the right-hand side of the Poisson equation. This stationary trap density corresponds to the number of unoccupied trap states.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Data","page":"Types, Constructors and Methods","title":"ChargeTransport.Data","text":"mutable struct Data{TFuncs<:Function, TVoltageFunc<:Function, TGenerationData<:Union{Array{Float64, 3}, Function, VecOrMat{Float64}}}\n\nA struct holding all data information including model and numerics information, but also all physical parameters for a drift-diffusion simulation of a semiconductor device.\n\nF::Vector{TFuncs} where TFuncs<:Function: An array with the corresponding distribution function mathcalF_alpha for all carriers alpha.\n\nqFModel::Union{Type{ContQF}, Type{DiscontQF}}: An datatype containing the information, whether at least on quasi Fermi potential is assumend to be continuous or discontinuous.\n\nboundaryType::Vector{Union{Type{InterfaceNone}, Type{InterfaceRecombination}, Type{MixedOhmicSchottkyContact}, Type{OhmicContact}, Type{SchottkyBarrierLowering}, Type{SchottkyContact}}}: An array of DataTypes with the type of boundary model for each boundary (interior and exterior).\n\ncontactVoltageFunction::Vector{TVoltageFunc} where TVoltageFunc<:Function: An array containing predefined functions for the applied bias in dependance of time at each outer boundary.\n\nbulkRecombination::BulkRecombination: A struct containing information concerning the bulk recombination model.\n\ngenerationData::Union{Array{Float64, 3}, Function, VecOrMat{Float64}}: A function/Array containing the user-specific photogeneration rate. It can be a function which is specified in the user example or an array which is read in and calculatd with, e.g., an external software.\n\nisContinuous::Vector{Bool}: An array containing information on whether charge carriers are continuous or discontinuous. This is needed for building the AbstractQuantities which handle the indices of charge carriers on different regions.\n\nchargeCarrierList::Vector{Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}}: This list stores all charge carriers with the correct type needed for VoronoiFVM.\n\nelectricCarrierList::Vector{Int64}: This list stores all electric carrier indices, i.e. the one of electrons and holes.\n\nionicCarrierList::Vector{ChargeTransport.IonicCarrier}: This list contains all defined ionic carriers as a struct of Type IonicCarrier with all needed information on the ionic carriers (can be either ions or ion vacancies).\n\ntrapCarrierList::Vector{ChargeTransport.TrapCarrier}: This list contains all defined trap carriers for the SRH recombination as a struct of Type TrapCarrier with all needed information on the trap carriers.\n\nAuxTrapValues::ChargeTransport.AuxiliaryStationaryTrapValues: A struct which contains auxiliary trap values for the stationary setting.\n\nindex_psi::Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}: This variable stores the index of the electric potential. Based on the user choice we have with this new type the opportunity to simulate discontinuous unknowns.\n\nbarrierLoweringInfo::ChargeTransport.BarrierLoweringSpecies: This is a struct containing all information necessary to simulate Schottky Barrier Lowering.\n\nfluxApproximation::Vector{Union{Type{DiffusionEnhanced}, Type{DiffusionEnhancedModifiedDrift}, Type{ExcessChemicalPotential}, Type{ExcessChemicalPotentialGraded}, Type{GeneralizedSG}, Type{ScharfetterGummel}, Type{ScharfetterGummelGraded}}}: A DataType for the flux discretization method.\n\ncalculationType::Union{Type{InEquilibrium}, Type{OutOfEquilibrium}}: A DataType for equilibrium or out of equilibrium calculations.\n\nmodelType::Union{Type{Stationary}, Type{Transient}}: A DataType for transient or stationary calculations.\n\ngenerationModel::Union{Type{GenerationBeerLambert}, Type{GenerationNone}, Type{GenerationUniform}, Type{GenerationUserDefined}}: A DataType for for generation model.\n\nλ1::Float64: An embedding parameter used to solve the nonlinear Poisson problem, where for λ1 = 0 the right hand-side is set to zero whereas for for λ1 = 1 we have a full space charge density.\n\nλ2::Float64: An embedding parameter for the generation rate.\n\nλ3::Float64: An embedding parameter for an electrochemical reaction.\n\ntempBEE1::Vector{Float64}: Within this template informations concerning the band-edge energy of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.\n\ntempBEE2::Vector{Float64}: See the description of tempBEE1.\n\ntempDOS1::Vector{Float64}: Within this template informations concerning the effective DOS of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.\n\ntempDOS2::Vector{Float64}: See the desciption of tempDOS2.\n\nparams::Params: A struct holding all region dependent parameter information. For more information see struct Params.\n\nparamsnodal::ParamsNodal: A struct holding all space dependent parameter information. For more information see struct ParamsNodal.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Data-Union{Tuple{TFuncs}, Tuple{Any, Any}} where TFuncs","page":"Types, Constructors and Methods","title":"ChargeTransport.Data","text":"Data(\n    grid,\n    numberOfCarriers;\n    contactVoltageFunction,\n    generationData,\n    statfunctions\n) -> Data{StandardFuncSet, _A, Vector{Float64}} where _A<:Function\n\n\nSimplified constructor for Data which only takes the grid and the numberOfCarriers as argument. Here, all necessary information including the physical parameters, but also some numerical information are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.DiffusionEnhanced","page":"Types, Constructors and Methods","title":"ChargeTransport.DiffusionEnhanced","text":"abstract type DiffusionEnhanced\n\nAbstract type for diffusion enhanced flux discretization, check M. Bessemoulin-Chatard, “A finite volume scheme for convection–diffusion equations with nonlinear diffusion derived from the Scharfetter–Gummel scheme”, Numerische Mathematik, vol. 121, pp. 637–670, 2012.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ExcessChemicalPotential","page":"Types, Constructors and Methods","title":"ChargeTransport.ExcessChemicalPotential","text":"abstract type ExcessChemicalPotential\n\nAbstract type for excess chemical potential flux discretization, check  Z. Yu, and R. Dutton, “SEDAN III – A one-dimensional device simulator”, http://www-tcad.stanford.edu/tcad/programs/sedan3.html, 1988.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ExcessChemicalPotentialGraded","page":"Types, Constructors and Methods","title":"ChargeTransport.ExcessChemicalPotentialGraded","text":"abstract type ExcessChemicalPotentialGraded\n\nAbstract type for excess chemical potential flux discretization for graded effective density of states and/or graded band-edge energies. This means, use this flux when at least one of these parameters is assumed to be space-dependent.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GeneralizedSG","page":"Types, Constructors and Methods","title":"ChargeTransport.GeneralizedSG","text":"abstract type GeneralizedSG\n\nAbstract type for generalized Scharfetter-Gummel flux discretization. This flux approximation results in an implicit equation which needs to be solved and is exact for all Blakemore type statistics functions with abritary γ, check T. Koprucki and K. Gärtner. “Discretization scheme for drift-diffusion equations with strong diffusion enhancement”. In: 12th International Conference on Numerical Simulation of Optoelectronic Devices (NUSOD). 2012, pp. 103–104.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationBeerLambert","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationBeerLambert","text":"abstract type GenerationBeerLambert\n\nAbstract type for Beer-Lambert generation. Note that this type is implemented, but not well tested yet.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationNone","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationNone","text":"abstract type GenerationNone\n\nAbstract type for no generation model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationUniform","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationUniform","text":"abstract type GenerationUniform\n\nAbstract type for uniform generation.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationUserDefined","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationUserDefined","text":"abstract type GenerationUserDefined\n\nAbstract type for user defined generation.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InEquilibrium","page":"Types, Constructors and Methods","title":"ChargeTransport.InEquilibrium","text":"abstract type InEquilibrium\n\nAbstract type for equilibrium calculations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InterfaceNone","page":"Types, Constructors and Methods","title":"ChargeTransport.InterfaceNone","text":"abstract type InterfaceNone\n\nAbstract type for no interface model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InterfaceRecombination","page":"Types, Constructors and Methods","title":"ChargeTransport.InterfaceRecombination","text":"abstract type InterfaceRecombination\n\nAbstract type for surface recombination mechanisms.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.MixedOhmicSchottkyContact","page":"Types, Constructors and Methods","title":"ChargeTransport.MixedOhmicSchottkyContact","text":"Abstract type for a mixed Ohmic and Schottky boundary model, resulting in all Dirichlet type conditions for electrons, holes and the electric potential.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.OhmicContact","page":"Types, Constructors and Methods","title":"ChargeTransport.OhmicContact","text":"Abstract type for ohmic contacts as outer boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.OutOfEquilibrium","page":"Types, Constructors and Methods","title":"ChargeTransport.OutOfEquilibrium","text":"abstract type OutOfEquilibrium\n\nAbstract type for out of equilibrium calculations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Params","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"mutable struct Params\n\nA struct holding the physical region dependent parameters for a drift-diffusion simulation of a semiconductor device.\n\nnumberOfNodes::Int64: Number of nodes used for the disretization of the domain mathbfOmega.\n\nnumberOfRegions::Int64: Number of subregions mathbfOmega_k within the domain mathbfOmega.\n\nnumberOfBoundaryRegions::Int64: Number of boundary regions (partial mathbfOmega)_k such that partial mathbfOmega = cup_k (partial mathbfOmega)_k. Note that here are inner and outer boundaries calculated.\n\nnumberOfCarriers::Int64: Number of moving charge carriers.\n\ninvertedIllumination::Int64: Parameter for the direction of illumination. If illumination is coming from the left, then set this value to 1. Otherwise, if the illumination comes from the right, set this value to -1.\n\ntemperature::Float64: A given constant temperature.\n\nUT::Float64: The thermal voltage, which reads  U_T = k_B T  q.\n\nγ::Float64: The parameter of the Blakemore statistics (needed for the generalizedSG flux).\n\nr0::Float64: Prefactor of electro-chemical reaction of internal boundary conditions.\n\nprefactor_SRH::Float64: Prefactor for stationary SRH recombination.\n\ngenerationPeak::Float64: Parameter for the shift of generation peak of the Beer-Lambert generation profile.\n\nSchottkyBarrier::Vector{Float64}: An array for the given Schottky barriers at present Schotkky contacts.\n\ncontactVoltage::Vector{Float64}: An array containing a contant value for the applied voltage.\n\nchargeNumbers::Vector{Float64}: An array with the corresponding charge numbers z_alpha for all carriers alpha.\n\nbBandEdgeEnergy::Matrix{Float64}: An array with the corresponding boundary band-edge energy values E_alpha in each region for each carrier alpha.\n\nbDensityOfStates::Matrix{Float64}: An array with the corresponding boundary effective density of states values N_alpha for each carrier alpha.\n\nbMobility::Matrix{Float64}: A 2D array with the corresponding boundary mobility values mu_alpha in each boundary region for each carrier alpha.\n\nbDoping::Matrix{Float64}: A 2D array with the corresponding boundary doping values for each carrier alpha.\n\nbVelocity::Matrix{Float64}: A 2D array with the corresponding boundary velocity values for each carrier alpha, when assuming Schottky contacts.\n\nbReactionCoefficient::Matrix{Float64}: An array to define the reaction coefficient at internal boundaries.\n\nrecombinationSRHvelocity::Matrix{Float64}: A 2D array with the corresponding recombination surface boundary velocity values for electrons and holes.\n\nbRecombinationSRHTrapDensity::Matrix{Float64}: A 2D array with the corresponding recombination surface boundary density values for electrons and holes.\n\nbRecombinationSRHLifetime::Matrix{Float64}: A 2D array with the corresponding recombination surface recombination velocities.\n\nbDensityEQ::Matrix{Float64}: A 2D array containing the equilibrium density of electric charge carriers at the boundary.\n\ndoping::Matrix{Float64}: A 2D array with the corresponding doping values for each carrier alpha on each region.\n\ndensityOfStates::Matrix{Float64}: A 2D array with the corresponding effective density of states values N_alpha for each carrier alpha on each region.\n\nbandEdgeEnergy::Matrix{Float64}: A 2D array with the corresponding band-edge energy values E_alpha for each carrier alpha on each region.\n\nmobility::Matrix{Float64}: A 2D array with the corresponding mobility values mu_alpha for each carrier alpha on each region.\n\nrecombinationSRHLifetime::Matrix{Float64}: A 2D array with the corresponding SRH lifetimes tau_n tau_p for electrons and holes.\n\nrecombinationSRHTrapDensity::Matrix{Float64}: A 2D array with the corresponding time-independent SRH trap densities n_tau p_tau for electrons and holes.\n\nrecombinationAuger::Matrix{Float64}: A 2D array with the corresponding Auger coefficients for electrons and holes.\n\ndielectricConstant::Vector{Float64}: A region dependent dielectric constant.\n\ndielectricConstantImageForce::Vector{Float64}: A region dependent image force dielectric constant.\n\ngenerationIncidentPhotonFlux::Vector{Float64}: A region dependent array for the prefactor in the generation process which is the incident photon flux.\n\ngenerationUniform::Vector{Float64}: A region dependent array for an uniform generation rate.\n\ngenerationAbsorption::Vector{Float64}: A region dependent array for the absorption coefficient in the generation process.\n\nrecombinationRadiative::Vector{Float64}: A region dependent array for the radiative recombination rate.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Params-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"Params(grid, numberOfCarriers) -> Params\n\n\nSimplified constructor for Params which only takes the grid and the numberOfCarriers as argument.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.ParamsNodal","page":"Types, Constructors and Methods","title":"ChargeTransport.ParamsNodal","text":"mutable struct ParamsNodal\n\nA struct holding the physical nodal, i.e. space-dependent parameters for a drift-diffusion simulation of a semiconductor device.\n\ndielectricConstant::Vector{Float64}: A node dependent dielectric constant.\n\ndoping::Vector{Float64}: A 1D array with the corresponding doping values on each node.\n\nmobility::Matrix{Float64}: A 2D array with the corresponding mobility values mu_alpha for each carrier alpha on each node.\n\ndensityOfStates::Matrix{Float64}: A 2D array with the corresponding effective density of states values N_alpha for each carrier alpha on each node.\n\nbandEdgeEnergy::Matrix{Float64}: A 2D array with the corresponding band-edge energy values E_alpha for each carrier alpha on each node.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ParamsNodal-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.ParamsNodal","text":"ParamsNodal(grid, numberOfCarriers) -> ParamsNodal\n\n\nSimplified constructor for ParamsNodal which only takes the grid and the numberOfCarriers as argument.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.ScharfetterGummel","page":"Types, Constructors and Methods","title":"ChargeTransport.ScharfetterGummel","text":"abstract type ScharfetterGummel\n\nAbstract type for Scharfetter-Gummel flux discretization. Choose this one, when the Boltzmann statistics function is chosen as statistics, check D. Scharfetter and H. Gummel, “Large-signal analysis of a silicon Read diode oscillator”, IEEE Trans. Electr. Dev., vol. 16, pp. 64–77, 1969.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ScharfetterGummelGraded","page":"Types, Constructors and Methods","title":"ChargeTransport.ScharfetterGummelGraded","text":"abstract type ScharfetterGummelGraded\n\nAbstract type for Scharfetter-Gummel flux discretization for graded effective density of states and/or graded band-edge energies. This means, use this flux when at least one of these parameters is assumed to be space-dependent.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.SchottkyContact","page":"Types, Constructors and Methods","title":"ChargeTransport.SchottkyContact","text":"Abstract type for schottky contacts as boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Stationary","page":"Types, Constructors and Methods","title":"ChargeTransport.Stationary","text":"abstract type Stationary\n\nAbstract type for stationary simulations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.System","page":"Types, Constructors and Methods","title":"ChargeTransport.System","text":"mutable struct System\n\nA struct holding all information necessary for a drift-diffusion type system.\n\ndata::Data: A struct holding all data information, see Data\n\nfvmsys::VoronoiFVM.AbstractSystem: A struct holding system information for the finite volume system.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.System-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.System","text":"System(grid, data; unknown_storage)\n\n\nSystem constructor which builds all necessary information needed based on the input parameters with special regard to the quasi Fermi potential model. This is the main struct in which all information on the input data, but also on the solving system, are stored.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Transient","page":"Types, Constructors and Methods","title":"ChargeTransport.Transient","text":"abstract type Transient\n\nAbstract type for transient simulations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.TrapCarrier","page":"Types, Constructors and Methods","title":"ChargeTransport.TrapCarrier","text":"mutable struct TrapCarrier\n\nA struct holding all information necessary for enabling traps in the SRH recombination. With help of this constructor we can read out the index the user chooses for trap quasi Fermi potentials and the respective regions in which they are defined.\n\ntrapCarrier::Int64: Index of trap carrier user defines.\n\nregions::Vector{Int64}: Corresponding regions where trap carrier is assumed to be present.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#Methods-2","page":"Types, Constructors and Methods","title":"Methods","text":"","category":"section"},{"location":"allindex/","page":"Types, Constructors and Methods","title":"Types, Constructors and Methods","text":"Modules = [ChargeTransport]\nOrder=[:function]","category":"page"},{"location":"allindex/#ChargeTransport.Blakemore-Tuple{Real, Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.Blakemore","text":"Blakemore(x::Real, γ::Real) -> Any\n\n\nThe Blakemore approximation 1(exp(-x) + γ) with variable real scalar γ, see J. S. Blakemore. “The Parameters of Partially Degenerate Semiconductors”. In: Proceedings of the Physical Society. Section A 65 (1952), pp. 460–461.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Boltzmann-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.Boltzmann","text":"Boltzmann(x::Real) -> Any\n\n\nThe Boltzmann statistics function exp(x).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.FermiDiracMinusOne-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.FermiDiracMinusOne","text":"FermiDiracMinusOne(x::Real) -> Any\n\n\nThe Fermi-Dirac integral of order -1 which reads 1(exp(-x) + 1), see J.S. Blakemore, Approximations for Fermi-Dirac integrals, especially the function F_12 (eta) used to describe electron density in a semiconductor, Solid-State Electronics 25 (11) (1982) 1067 – 1076.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.FermiDiracOneHalfBednarczyk-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.FermiDiracOneHalfBednarczyk","text":"FermiDiracOneHalfBednarczyk(x::Real) -> Any\n\n\nThe incomplete Fermi-Dirac integral of order 1/2, implemented according to [Bednarczyk1978, \"The Approximation of the Fermi-Dirac integral F_12(eta)\"].\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.FermiDiracOneHalfTeSCA-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.FermiDiracOneHalfTeSCA","text":"FermiDiracOneHalfTeSCA(x::Real) -> Any\n\n\nThe incomplete Fermi-Dirac integral of order 1/2, implemented according to the software package TeSCA, see https://wias-berlin.de/software/index.jsp?lang=1&id=TeSCA.\n\nModified to use log1p(x)=log(1+x).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.RHSContinuityEquations!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.RHSContinuityEquations!","text":"RHSContinuityEquations!(f, u, node, data)\n\n\nFunction which builds right-hand side of electric charge carriers.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.RHSPoisson!-NTuple{5, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.RHSPoisson!","text":"RHSPoisson!(f, u, node, data, ipsi) -> Any\n\n\nFunction which builds right-hand side of Poisson equation, i.e. which builds the space charge density.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.add_trap_density_Poisson!-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.add_trap_density_Poisson!","text":"add_trap_density_Poisson!(; data, zt, Nt)\n\n\nThis method includes traps for a simplified model, where the trap carriers are not considered as additional carrier with an own continuity equation. In this case the trap density is additionally added to the right-hand side of Poisson equation.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.bflux!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.bflux!","text":"bflux!(f, u, bedge, data)\n\n\nMaster bflux! function. This is the function which enters VoronoiFVM and hands over for each boundary the flux within the boundary.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.breaction!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.breaction!","text":"breaction!(f, u, bnode, data) -> Any\n\n\nMaster breaction! function. This is the function which enters VoronoiFVM and hands over for each boundary the chosen boundary model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{OhmicContact}}","page":"Types, Constructors and Methods","title":"ChargeTransport.breaction!","text":"breaction!(f, u, bnode, data, _::Type{OhmicContact})\n\n\nCreates ohmic boundary conditions via a penalty approach with penalty parameter delta. For example, the right-hand side for the electrostatic potential psi is implemented as\n\nfpsi  = -qdelta   ( (p - N_a) - (n - N_d) ),\n\nassuming a bipolar semiconductor. In general, we have for some given charge number z_alpha\n\nfpsi =  -qdelta  sum_alpha z_alpha  (n_alpha - C_alpha) \n\nwhere C_alpha corresponds to some doping w.r.t. the species alpha.\n\nThe boundary conditions for electrons and holes are dirichlet conditions, where\n\nvarphi_alpha = U`\n\nwith U as an applied voltage.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{SchottkyBarrierLowering}}","page":"Types, Constructors and Methods","title":"ChargeTransport.breaction!","text":"breaction!(\n    f,\n    u,\n    bnode,\n    data,\n    _::Type{SchottkyBarrierLowering}\n) -> Any\n\n\nCreates Schottky boundary conditions with additional lowering which are modelled as\n\npsi = - phi_Sq  + sqrt -frac q  nabla_boldsymbolnu psi_mathrmR4pi varepsilon_mathrmi + U,\n\nwhere psi_mathrmR denotes the electric potential with standard Schottky contacts and the same space charge density as psi and where varepsilon_mathrmi corresponds to the image force dielectric constant.\n\nTo solve for this additional boundary conditions the projected gradient nabla_boldsymbolnu psi_mathrmR is stored within a boundary species and calculated in the method generic_operator!().\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.bstorage!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.bstorage!","text":"bstorage!(f, u, bnode, data) -> Any\n\n\nMaster bstorage! function. This is the function which enters VoronoiFVM and hands over for each boundary the time-dependent part of the chosen boundary model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.build_system-Tuple{Any, Any, Any, Type{ContQF}}","page":"Types, Constructors and Methods","title":"ChargeTransport.build_system","text":"build_system(\n    grid,\n    data,\n    unknown_storage,\n    _::Type{ContQF}\n) -> System\n\n\nThe core of the system constructor. Here, the system for continuous quasi Fermi potentials is build.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.build_system-Tuple{Any, Any, Any, Type{DiscontQF}}","page":"Types, Constructors and Methods","title":"ChargeTransport.build_system","text":"build_system(\n    grid,\n    data,\n    unknown_storage,\n    _::Type{DiscontQF}\n) -> System\n\n\nThe core of the system constructor. Here, the system for discontinuous quasi Fermi potentials is build.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.charge_density-NTuple{8, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.charge_density","text":"charge_density(\n    psi0,\n    phi,\n    UT,\n    EVector,\n    chargeNumbers,\n    dopingVector,\n    dosVector,\n    FVector\n) -> Any\n\n\nCompute the charge density, i.e. the right-hand side of Poisson's equation.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.charge_density-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.charge_density","text":"charge_density(ctsys, sol) -> Any\n\n\nCompute the charge density for each region separately.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.degenerateLimit-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.degenerateLimit","text":"degenerateLimit(x) -> Any\n\n\nDegenerate limit of incomplete Fermi-Dirac integral of order 1/2.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.electroNeutralSolution!-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.electroNeutralSolution!","text":"electroNeutralSolution!(ctsys; Newton) -> Any\n\n\nCompute the electro-neutral solution for the Boltzmann approximation. It is obtained by setting the left-hand side in the Poisson equation equal to zero and solving for psi. The charge carriers may obey different statitics functions. Currently, this one is not well tested for the case of charge carriers beyond electrons and holes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.enable_ionic_carrier!-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.enable_ionic_carrier!","text":"enable_ionic_carrier!(data; ionicCarrier, regions)\n\n\nThis method takes the user information concerning present ionic charge carriers, builds a struct of Type IonicCarrier and add this struct to the ionicCarrierList.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.enable_trap_carrier!-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.enable_trap_carrier!","text":"enable_trap_carrier!(; data, trapCarrier, regions)\n\n\nThis method takes the user information concerning present trap charge carriers, builds a struct of Type TrapCarrier and add this struct to the trapCarrierList.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction!-Tuple{Any, VoronoiFVM.BNode, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction!","text":"etaFunction!(u, bnode::VoronoiFVM.BNode, data, icc) -> Any\n\n\nThe argument of the statistics function for boundary nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction!-Tuple{Any, VoronoiFVM.Node, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction!","text":"etaFunction!(u, node::VoronoiFVM.Node, data, icc) -> Any\n\n\nThe argument of the statistics function for interior nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction-NTuple{5, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction","text":"etaFunction(psi, phi, UT, E, z) -> Any\n\n\nThe argument of the statistics function for given varphi_alpha and psi\n\nz_alpha  U_T  ( (varphi_alpha - psi) + E_alpha  q )\n\nThe parameters E_alpha and z_alpha are given as vectors. This function may be used to compute the charge density, i.e. the right-hand side of the Poisson equation.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction-Tuple{Any, Any, Any, Any, Any, Bool}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction","text":"etaFunction(\n    u,\n    data,\n    node,\n    region,\n    icc,\n    in_region::Bool\n) -> Any\n\n\nThe argument of the distribution function for floats.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction-Tuple{Any, Int64, Any, Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction","text":"etaFunction(\n    sol,\n    ireg::Int64,\n    ctsys,\n    icc::Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}\n) -> Any\n\n\nThe argument of the statistics function for a given solution on a given interior region.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.flux!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.flux!","text":"flux!(f, u, edge, data) -> Any\n\n\nMaster flux functions which enters VoronoiFVM. Flux discretization scheme is chosen in two steps. First, we need to see, if we are in or out of equilibrium. If, InEquilibrium, then no flux is passed. If outOfEquilibrium, we choose the flux approximation which the user chose for each charge carrier. For the displacement flux we use a finite difference approach.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.generic_operator!-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.generic_operator!","text":"generic_operator!(f, u, fvmsys) -> Any\n\n\nGeneric operator to save the projected gradient of electric potential (for system with standard Schotty contacts). Note that this currently only working in one dimension!\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_BEE!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}, VoronoiFVM.Node, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_BEE!","text":"get_BEE!(\n    icc::Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}},\n    node::VoronoiFVM.Node,\n    data\n) -> Any\n\n\nDefining locally the band-edge energy for interior nodes (analougesly for boundary nodes and edges).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_DOS!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}, VoronoiFVM.Node, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_DOS!","text":"get_DOS!(\n    icc::Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}},\n    node::VoronoiFVM.Node,\n    data\n) -> Any\n\n\nDefining locally the effective DOS for interior nodes (analogously for boundary nodes and edges).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_current_val-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_current_val","text":"Calculates current for time dependent problem.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_current_val-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_current_val","text":"Calculates current for stationary problem.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.BNode, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_density!","text":"get_density!(u, bnode::VoronoiFVM.BNode, data, icc) -> Any\n\n\nFor given potentials, compute corresponding densities for interior nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.Edge, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_density!","text":"get_density!(\n    u,\n    edge::VoronoiFVM.Edge,\n    data,\n    icc\n) -> Tuple{Any, Any}\n\n\nFor given potentials, compute corresponding densities for edges.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.Node, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_density!","text":"get_density!(u, node::VoronoiFVM.Node, data, icc) -> Any\n\n\nFor given potentials, compute corresponding densities for interior nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_density-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_density","text":"get_density(sol, data, icc, ireg; inode) -> Any\n\n\nThe densities for given potentials  varphi_alpha and psi\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_density-Tuple{Any, Int64, Any, Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_density","text":"get_density(\n    sol,\n    ireg::Int64,\n    ctsys,\n    icc::Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}\n) -> Any\n\n\nFor given potentials, compute corresponding densities for given interior region corresponding to a homogeneous set of parameters.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plotDiffusionEnhancements-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.plotDiffusionEnhancements","text":"plotDiffusionEnhancements(; Plotter)\n\n\nPlot diffusion enhancements.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plotDistributions-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.plotDistributions","text":"plotDistributions(; Plotter)\n\n\nPlot different distribution integrals.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_IV-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_IV","text":"plot_IV(\n    Plotter,\n    biasValues,\n    IV,\n    title;\n    plotGridpoints\n) -> Any\n\n\nMethod for showing the total current. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_densities-NTuple{5, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_densities","text":"plot_densities(\n    Plotter,\n    ctsys,\n    solution,\n    title,\n    label_density;\n    plotGridpoints\n) -> Any\n\n\nPlotting routine, where the charge carrier densities are depicted in dependence of space. The case of heterojunctions is tested, but yet multidimensional plottings are not included. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_doping-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_doping","text":"plot_doping(Plotter, ctsys, label_density) -> Any\n\n\nPossibility to plot the considered doping. This is especially useful for making sure that the interior and the boundary doping agree.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ParamsNodal}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_doping","text":"Plot doping for nodal dependent doping.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_electroNeutralSolutionBoltzmann-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_electroNeutralSolutionBoltzmann","text":"plot_electroNeutralSolutionBoltzmann(\n    Plotter,\n    grid,\n    psi0;\n    plotGridpoints\n) -> Any\n\n\nPlotting routine for depicting the electroneutral potential. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_energies-NTuple{5, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_energies","text":"plot_energies(\n    Plotter,\n    ctsys,\n    solution,\n    title,\n    label_energy;\n    plotGridpoints\n) -> Any\n\n\nWith this method it is possible to plot the energies\n\nE_alpha - q psi quad textwrt space\n\nThe case of heterojunctions is tested, but yet multidimensional plottings are not included.\n\nOne input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_energies-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_energies","text":"plot_energies(Plotter, ctsys, label_BEE)\n\n\nWith this method it is possible to depict the band-edge energies E_alpha. This can be useful for debugging when dealing with heterojunctions.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_solution-NTuple{5, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_solution","text":"plot_solution(\n    Plotter,\n    ctsys,\n    solution,\n    title,\n    label_solution;\n    plotGridpoints\n) -> Any\n\n\nMethod for plotting the solution vectors: the electrostatic potential psi as well as the charge carriers. The case of heterojunctions is tested, but yet multidimensional plottings are not included. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.printJacobi-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.printJacobi","text":"printJacobi(node, sys)\n\n\nFirst try of debugger. Print the Jacobi matrix for a given node, i.e. the number of node in the grid and not the excact coordinate. This is only done for the one dimensional case so far.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.reaction!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.reaction!","text":"reaction!(f, u, node, data)\n\n\nMaster reaction! function. This is the function which enters VoronoiFVM and hands over reaction terms for concrete calculation type and bulk recombination model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{InEquilibrium}}","page":"Types, Constructors and Methods","title":"ChargeTransport.reaction!","text":"reaction!(f, u, node, data, _::Type{InEquilibrium})\n\n\nReaction in case of equilibrium, i.e. no generation and recombination is considered.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}","page":"Types, Constructors and Methods","title":"ChargeTransport.reaction!","text":"reaction!(f, u, node, data, _::Type{OutOfEquilibrium})\n\n\nSets up the right-hand sides. Assuming a bipolar semiconductor the right-hand side for the electrostatic potential becomes   fψ  = - q ((p - N_a) - (n - N_d) ) = - q  sum  n_alpha  (n_alpha - C_alpha) for some doping C_alpha w.r.t. to the species alpha. The right-hand sides for the charge carriers read as fn_alpha =  - z_alpha  q (G -  R) for all charge carriers n_alpha. The recombination includes radiative, Auger and Shockley-Read-Hall recombination. For latter recombination process the stationary simplification is implemented. The recombination is only implemented for electron and holes and assumes that the electron index is 1 and the hole index is 2.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.set_bulk_recombination-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.set_bulk_recombination","text":"set_bulk_recombination(\n;\n    iphin,\n    iphip,\n    bulk_recomb_Auger,\n    bulk_recomb_radiative,\n    bulk_recomb_SRH\n)\n\n\nCorresponding constructor for the bulk recombination model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.set_plotting_labels-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.set_plotting_labels","text":"set_plotting_labels(\n    data\n) -> Tuple{Any, Any, Matrix{String}, Any}\n\n\nMethod which can be used to construct the arrays parsed to the plotting routines for labeling. The description for electrons and holes are predefined. If one wishes to extend by labels for, e.g. mobile ionic carriers or traps, this can be done within the main file.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.storage!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.storage!","text":"storage!(f, u, node, data) -> Any\n\n\nMaster storage! function. This is the function which enters VoronoiFVM and hands over a storage term, if we consider transient problem.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.storage!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}","page":"Types, Constructors and Methods","title":"ChargeTransport.storage!","text":"storage!(\n    f,\n    u,\n    node,\n    data,\n    _::Type{OutOfEquilibrium}\n) -> Float64\n\n\nThe storage term for time-dependent problems. Currently, for the time-dependent current densities the implicit Euler scheme is used. Hence, we have fn_alpha =  z_alpha  q _t n_alpha and for the electrostatic potential fψ = 0.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.trap_density!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.trap_density!","text":"trap_density!(icc, ireg, params, Et)\n\n\nCompute trap densities for a given trap energy. [Currently, only done for the Boltzmann statistics and for region dependent parameters.]\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.zeroVoltage-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.zeroVoltage","text":"Function in case of an applied voltage equal to zero at one boundary.\n\n\n\n\n\n","category":"method"},{"location":"examples/Ex103_PSC_IVMeasurement/#PSC-device-with-ions-and-different-I-V-scan-protocols-(1D).","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"","category":"section"},{"location":"examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"Simulating a three layer PSC device Ti02| MAPI | spiro-OMeTAD with mobile ions where the ion vacancy accumulation is limited by the Fermi-Dirac integral of order -1.","category":"page"},{"location":"examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"The time-dependent simulations are performed with abrupt interfaces. Two different I-V measurement protocols are included and the corresponding solution vectors and the I-V curve after the scan can be depicted.","category":"page"},{"location":"examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"module Ex103_PSC_IVMeasurement\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot\n\nfunction main(;n = 3, Plotter = PyPlot, plotting = false, verbose = false, test = false,\n    parameter_file = \"../parameter_files/Params_PSC_TiO2_MAPI_spiro.jl\", # choose the parameter file\n    otherScanProtocol = false) # you can choose between two scan protocols\n\n    PyPlot.close(\"all\")\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    include(parameter_file) # include the parameter file we specified\n\n    # contact voltage\n    voltageAcceptor = 1.2 * V\n\n    # primary data for I-V scan protocol\n    scanrate        = 1.0 * V/s\n    number_tsteps   = 31\n    endVoltage      = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    tend            = endVoltage/scanrate\n\n    # Define scan protocol function\n    function linearScanProtocol(t)\n        if t == Inf\n            0.0\n        else\n            scanrate * t\n        end\n    end\n\n    # Apply zero voltage on left boundary and a linear scan protocol on right boundary\n    contactVoltageFunction = [zeroVoltage, linearScanProtocol]\n\n    # Instead of a linear scan protocol, we can also apply other scan protocols which we\n    # define by our own and parse to the model generator via the struct Data\n    if otherScanProtocol\n        # scan protocol parameter\n        number_tsteps = 40\n        frequence     = 10.0 * Hz\n        amplitude     = 0.2  * V\n        tend          = 1/frequence\n\n        # Define sinusoidal applied voltage\n        function sinusoidalScanProtocol(t)\n            if t == Inf\n                0.0\n            else\n                amplitude * sin(2.0 * pi * frequence * t)\n            end\n        end\n\n        # Apply zero voltage on left boundary and a linear scan protocol on right boundary\n        contactVoltageFunction = [zeroVoltage, sinusoidalScanProtocol]\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    δ          = 4*n        # the larger, the finer the mesh\n    t          = 0.5*(cm)/δ # tolerance for geomspace and glue (with factor 10)\n    k          = 1.5        # the closer to 1, the closer to the boundary geomspace\n\n    coord_n_u  = collect(range(0.0, h_ndoping/2, step=h_ndoping/(0.8*δ)))\n    coord_n_g  = geomspace(h_ndoping/2, h_ndoping,\n                           h_ndoping/(0.7*δ), h_ndoping/(1.1*δ),\n                           tol=t)\n    coord_i_g1 = geomspace(h_ndoping, h_ndoping+h_intrinsic/k,\n                           h_intrinsic/(2.8*δ), h_intrinsic/(2.1*δ),\n                           tol=t)\n    coord_i_g2 = geomspace(h_ndoping+h_intrinsic/k, h_ndoping+h_intrinsic,\n                            h_intrinsic/(2.1*δ), h_intrinsic/(2.8*δ),\n                           tol=t)\n    coord_p_g  = geomspace(h_ndoping+h_intrinsic, h_ndoping+h_intrinsic+h_pdoping/2,\n                           h_pdoping/(1.6*δ), h_pdoping/(1.6*δ),\n                           tol=t)\n    coord_p_u  = collect(range(h_ndoping+h_intrinsic+h_pdoping/2, h_ndoping+h_intrinsic+h_pdoping, step=h_pdoping/(1.3*δ)))\n\n    coord      = glue(coord_n_u, coord_n_g,  tol=10*t)\n    coord      = glue(coord,     coord_i_g1, tol=10*t)\n    coord      = glue(coord,     coord_i_g2, tol=10*t)\n    coord      = glue(coord,     coord_p_g,  tol=10*t)\n    coord      = glue(coord,     coord_p_u,  tol=10*t)\n    grid       = ExtendableGrids.simplexgrid(coord)\n\n    # set different regions in grid\n    cellmask!(grid,  [0.0 * μm],        [heightLayers[1]], regionDonor, tol = 1.0e-18)     # n-doped region   = 1\n    cellmask!(grid,  [heightLayers[1]], [heightLayers[2]], regionIntrinsic, tol = 1.0e-18) # intrinsic region = 2\n    cellmask!(grid,  [heightLayers[2]], [heightLayers[3]], regionAcceptor, tol = 1.0e-18)  # p-doped region   = 3\n\n    # bfacemask! for setting different boundary regions\n    bfacemask!(grid, [0.0],             [0.0],             bregionDonor, tol = 1.0e-18)     # outer left boundary\n    bfacemask!(grid, [h_total],         [h_total],         bregionAcceptor, tol = 1.0e-18)  # outer right boundary\n    bfacemask!(grid, [heightLayers[1]], [heightLayers[1]], bregionJ1, tol = 1.0e-18) # first  inner interface\n    bfacemask!(grid, [heightLayers[2]], [heightLayers[2]], bregionJ2, tol = 1.0e-18) # second inner interface\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend=:lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    # Currently, the way to go is to pass a contact voltage function exactly here.\n    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Transient\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F                             = [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = false,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n\n    # With this method, the user enable the ionic carrier parsed to ionicCarrier and gives\n    # gives the information on which regions this ionic carrier is defined.\n    # In this application ion vacancies only live in active perovskite layer.\n    enable_ionic_carrier!(data, ionicCarrier = iphia, regions = [regionIntrinsic])\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation            .= ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                              = Params(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = zn\n    params.chargeNumbers[iphip]                         = zp\n    params.chargeNumbers[iphia]                         = za\n\n    for ireg in 1:numberOfRegions # region data\n\n        params.dielectricConstant[ireg]                 = ε[ireg] * ε0\n\n        # effective DOS, band edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = Nn[ireg]\n        params.densityOfStates[iphip, ireg]             = Np[ireg]\n        params.densityOfStates[iphia, ireg]             = Na[ireg]\n\n        params.bandEdgeEnergy[iphin, ireg]              = En[ireg]\n        params.bandEdgeEnergy[iphip, ireg]              = Ep[ireg]\n        params.bandEdgeEnergy[iphia, ireg]              = Ea[ireg]\n\n        params.mobility[iphin, ireg]                    = μn[ireg]\n        params.mobility[iphip, ireg]                    = μp[ireg]\n        params.mobility[iphia, ireg]                    = μa[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]    = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = trap_density!(iphin, ireg, params, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg] = trap_density!(iphip, ireg, params, EI[ireg])\n    end\n\n    # doping\n    params.doping[iphin, regionDonor]                   = Cn\n    params.doping[iphia, regionIntrinsic]               = Ca\n    params.doping[iphip, regionAcceptor]                = Cp\n\n    data.params                                         = params\n    ctsys                                               = System(grid, data, unknown_storage=:sparse)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    if plotting == true\n        ################################################################################\n        println(\"Plot electroneutral potential, band-edge energies and doping\")\n        ################################################################################\n        label_solution, label_density, label_energy, label_BEE = set_plotting_labels(data)\n\n        # add labels for anion vacancy\n        label_energy[1, iphia] = \"\\$E_a-q\\\\psi\\$\"; label_energy[2, iphia] = \"\\$ - q \\\\varphi_a\\$\"; label_BEE[iphia] = \"\\$E_a\\$\"\n        label_density[iphia]   = \"\\$ n_a \\$\";      label_solution[iphia]  = \"\\$ \\\\varphi_a\\$\"\n\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control              = SolverControl()\n    control.verbose      = verbose\n    control.max_round    = 5\n    control.damp_initial = 0.1\n    control.damp_growth  = 1.21 # >= 1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # calculate equilibrium solution and as initial guess\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival   = solution\n\n    if plotting\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"Equilibrium\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution,\"Equilibrium\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"Equilibrium\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"IV Measurement loop\")\n    end\n    ################################################################################\n\n    # with fixed timestep sizes we can calculate the times a priori\n    tvalues    = range(0, stop = tend, length = number_tsteps)\n\n    # for saving I-V data\n    IV         = zeros(0) # for IV values\n\n    for istep = 2:number_tsteps\n\n        t  = tvalues[istep]                                    # Actual time\n        Δu = contactVoltageFunction[bregionAcceptor](t) # Applied voltage\n        Δt = t - tvalues[istep-1]                              # Time step size\n\n        # Apply new voltage by setting non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: t = $(t) s\")\n        end\n\n        # Solve time step problems with timestep Δt. inival plays the role of the solution\n        # from last timestep\n        solution = solve(ctsys; inival = inival, control = control, tstep = Δt)\n        # get I-V data\n        current  = get_current_val(ctsys, solution, inival, Δt)\n\n        push!(IV, current)\n\n        inival = solution\n\n    end # time loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    # here in res the biasValues and the corresponding current are stored.\n    # res = [biasValues IV];\n\n    if plotting\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage)\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution,\"bias \\$\\\\Delta u\\$ = $(endVoltage)\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage)\", label_solution)\n    end\n\n    biasValues = contactVoltageFunction[bregionAcceptor].(tvalues)\n\n    if plotting\n        Plotter.figure()\n        Plotter.plot(tvalues, biasValues, marker =\"o\")\n        Plotter.xlabel(\"time [s]\")\n        Plotter.ylabel(\"bias [V]\")\n        Plotter.figure()\n        plot_IV(Plotter, biasValues[2:end], IV, \"bias \\$\\\\Delta u\\$ = $(endVoltage)\")\n    end\n\n    testval = sum(filter(!isnan, solution))/length(solution) # when using sparse storage, we get NaN values in solution\n    return testval\n\n\nend #  main\n\nfunction test()\n    testval = -0.6302819608784171; testvalOther = -1.123710261723505\n    main(test = true, otherScanProtocol = false) ≈ testval && main(test = true, otherScanProtocol = true) ≈ testvalOther\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"","category":"page"},{"location":"examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"PSC/#Perovskite-solar-cell","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"We simulate charge transport in perovskite solar cells (PSCs), where we have apart from holes and electrons also ionic charge carriers. Here, we assume to have three domains, denoted by mathbfOmega = mathbfOmega_textHTL cup mathbfOmega_textintr cup mathbfOmega_textETL   The unknowns are the quasi Fermi potentials of electrons holes and anion vacancies varphi_n varphi_p varphi_a as well as the electric potential psi. The underlying PDEs are given by","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"beginaligned\n\t- nabla cdot (varepsilon_s nabla psi) = q Big( (p(psi varphi_p) - C_p ) - (n(psi varphi_n) - C_n) Big)\n\tq partial_t n(psi varphi_n) - nabla cdot mathbfj_n = qBigl(G(mathbfx) - R(np) Bigr) \n\tq partial_t p(psi varphi_p) + nabla cdot mathbfj_p = Bigl(G(mathbfx) - R(np) Bigr)\nendaligned","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"for mathbfx in mathbfOmega_textHTL cup  mathbfOmega_textETL  t in 0 t_F. In the middle, intrinsic region ($ \\mathbf{x} \\in \\mathbf{\\Omega}_{\\text{intr}} $), we have","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"beginaligned\n\t- nabla cdot (varepsilon_s nabla psi) = q Big( p(psi varphi_p)  - n(psi varphi_n) + a(psi varphi_a) - C_a Big)\nq partial_t n(psi varphi_n)\t- nabla cdot mathbfj_n = Bigl(G(mathbfx) - R(np) Bigr) \n\tq partial_t p(psi varphi_p) + nabla cdot mathbfj_p = Bigl(G(mathbfx) - R(np) Bigr)\n\tq partial_t a(psi varphi_a) + nabla cdot mathbfj_a = 0\nendaligned","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"see Abdel2021.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Differences to the previous example include","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"an additional charge carrier (the anion vacancy)\nparameter jumps across heterojunctions\nthe transient case\na generation rate G\nhigher dimensional problem.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"A quick survey on how to use ChargeTransport.jl to adjust the input parameters such that these features can be simulated will be given in the following.","category":"page"},{"location":"PSC/#Example-1:-Graded-interfaces","page":"Perovskite solar cell","title":"Example 1: Graded interfaces","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"By default, we assume abrupt inner interfaces. If one wishes to simulate graded interfaces, where for example the effective density of states and the band-edge energy may vary, we refer to this or this example.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"We sketch the relevant parts here. First, we need to define two additional thin interface layers","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"# region numbers\nregionDonor     = 1       # n doped region\nregionJunction1 = 2\nregionIntrinsic = 3       # intrinsic region\nregionJunction2 = 4\nregionAcceptor  = 5       # p doped region","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"which need to be taken into account by the initialization of the grid.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Second, since we allow varying parameters within the thin interface layers, the flux discretization scheme needs to be chosen accordingly and we need to construct a nodally dependent parameter struct","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"data.fluxApproximation = ScharfetterGummelGraded\n\nparamsnodal            = ParamsNodal(grid, numberOfCarriers)","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Finally, we introduce graded parameters. Currently, only a linear grading is implemented.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"paramsnodal.bandEdgeEnergy[iphin, :] = grading_parameter!(paramsnodal.bandEdgeEnergy[iphin, :],\n                                                         coord, regionTransportLayers, regionJunctions,\n                                                         h, heightLayers, lengthLayers, EC)","category":"page"},{"location":"PSC/#Example-2:-Linear-IV-scan-protocol","page":"Perovskite solar cell","title":"Example 2: Linear IV scan protocol","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Here, we summarize the main parts of this example. Define three charge carriers.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"iphin                    = 2 # electrons\niphip                    = 1 # holes\niphia                    = 3 # anion vacancies\nnumberOfCarriers         = 3","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Consider the transient problem and enable the ionic charge carriers only in the active layer:","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"data.modelType           = Transient\nenable_ionic_carrier!(data, ionicCarrier = iphia, regions = [regionIntrinsic])","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Following specification is needed for a linear I-V scan protocol.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"scanrate                 = 1.0 * V/s\nnumber_tsteps            = 31\nendVoltage               = voltageAcceptor # bias goes until the given voltage at acceptor boundary\ntend                     = endVoltage/scanrate","category":"page"},{"location":"PSC/#Variant-A:-Solve-the-transient-problem-manually","page":"Perovskite solar cell","title":"Variant A: Solve the transient problem manually","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"## with fixed timestep sizes we can calculate the times a priori\ntvalues                    = range(0, stop = tend, length = number_tsteps)\n\nfor istep = 2:number_tsteps\n\n    t  = tvalues[istep]                  # current time\n    Δu = t * scanrate                    # applied voltage\n    Δt = t - tvalues[istep-1]            # time step\n    set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n    solution = solve(ctsys, inival = inival, control = control, tstep = Δt) # provide time step\n    inival   = solution\n\nend","category":"page"},{"location":"PSC/#Variant-B:-Use-internal-time-stepping","page":"Perovskite solar cell","title":"Variant B: Use internal time stepping","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"To make use of internal time stepping, the scan protocol need to be previously defined, e.g.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"function linearScanProtocol(t)\n    if t == Inf\n        0.0\n    else\n        scanrate * t\n    end\nend\n\n## Apply zero voltage on left boundary and a linear scan protocol on right boundary\ncontactVoltageFunction = [zeroVoltage, linearScanProtocol]","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"And then, need to be parsed into the data construction method","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"data = Data(grid, numberOfCarriers, contactVoltageFunction = contactVoltageFunction)","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"This makes it possible to use the internal time solving method","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"sol = solve(ctsys, inival = inival, times=(0.0, tend), control = control)","category":"page"},{"location":"PSC/#Example-3:-Illumination","page":"Perovskite solar cell","title":"Example 3: Illumination","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Add uniform illumination to the previous code by setting","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"data.generationModel = GenerationUniform","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"and specify the uniform generation rate in each region, i.e.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"for ireg in 1:numberOfRegions\n    params.generationUniform[ireg] = generationUniform[ireg]\nend","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"for given data stored in generationUniform. If one wishes to use the Beer-Lambert generation, then the corresponding code would be","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"data.generationModel                          = GenerationBeerLambert\n\nfor ireg in 1:numberOfRegions\n    params.generationIncidentPhotonFlux[ireg] = incidentPhotonFlux[ireg]\n    params.generationAbsorption[ireg]         = absorption[ireg]\nend\n\nparams.generationPeak                         = generationPeak","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"If one wishes to invert the illumination, one needs to define","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"params.invertedIllumination                   = -1","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"where this value is by default set to one (for light entering from the left). Furthermore, we recommend performing a time loop while increasing the generation rate and afterwards applying the scan protocol with a full generation due to numerical stability, see this example or this one.","category":"page"},{"location":"PSC/#Example-4:-Multi-dimensional-problems","page":"Perovskite solar cell","title":"Example 4: Multi-dimensional problems","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"It is also possible to perform multi-dimensional simulations.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"For a 2D mesh you may use a structured grid via ExtendableGrids.jl or an unstructured mesh via the Julia wrapper Triangulate.jl for Jonathan Richard Shewchuk's Triangle mesh generator. Respective examples can be likewise found within this package.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Lastly, with help of the TetGen.jl wrapper, three dimensional tetrahedral meshes can be generated, see this example.","category":"page"},{"location":"examples/Ex101_PIN/#GaAs-diode-(1D).","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"","category":"section"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"We simulate charge transport in a GaAs pin diode, where we use the van Roosbroeck system of equations as charge transport model. The unknowns are given by the quasi Fermi potentials of electrons and holes varphi_n, varphi_p and the electric potential psi. The simulations are performed out of equilibrium and for the stationary problem.","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"module Ex101_PIN\n\nusing ChargeTransport  # drift-diffusion solver\nusing ExtendableGrids  # grid initializer\nusing PyPlot           # solution visualizer\n\n# This function is used to initialize the grid for a possible extension to other p-i-n devices.\nfunction initialize_pin_grid(refinementfactor, h_ndoping, h_intrinsic, h_pdoping)\n    coord_ndoping    = collect(range(0.0, stop = h_ndoping, length = 3 * refinementfactor))\n    coord_intrinsic  = collect(range(h_ndoping, stop = (h_ndoping + h_intrinsic), length = 3 * refinementfactor))\n    coord_pdoping    = collect(range((h_ndoping + h_intrinsic), stop = (h_ndoping + h_intrinsic + h_pdoping), length = 3 * refinementfactor))\n    coord            = glue(coord_ndoping, coord_intrinsic)\n    coord            = glue(coord, coord_pdoping)\n\n    return coord\nend\n\n\nfunction main(;n = 3, Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage=:sparse)\n\n    Plotter.close(\"all\")\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionAcceptor   = 1          # p doped region\n    regionIntrinsic  = 2          # intrinsic region\n    regionDonor      = 3          # n doped region\n    regions          = [regionAcceptor, regionIntrinsic, regionDonor]\n    numberOfRegions  = length(regions)\n\n    # boundary region numbers\n    # Note that by convention we have 1 for the left boundary and 2 for the right boundary. If\n    # adding additional interior boundaries, continue with 3, 4, ...\n    bregionAcceptor  = 1\n    bregionDonor     = 2\n    bregionJunction1 = 3\n    bregionJunction2 = 4\n\n    # grid\n    refinementfactor = 2^(n-1)\n    h_pdoping        = 2.0    * μm\n    h_intrinsic      = 2.0    * μm\n    h_ndoping        = 2.0    * μm\n    h_total          = h_pdoping + h_intrinsic + h_ndoping\n    w_device         = 0.5    * μm  # width of device\n    z_device         = 1.0e-4 * cm  # depth of device\n    coord            = initialize_pin_grid(refinementfactor,\n                                           h_pdoping,\n                                           h_intrinsic,\n                                           h_ndoping)\n\n    grid             = simplexgrid(coord)\n\n    # cellmask! for defining the subregions and assigning region number\n    cellmask!(grid, [0.0 * μm],                [h_pdoping],                           regionAcceptor)  # p-doped region = 1\n    cellmask!(grid, [h_pdoping],               [h_pdoping + h_intrinsic],             regionIntrinsic) # intrinsic region = 2\n    cellmask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic + h_ndoping], regionDonor)     # n-doped region = 3\n\n    # bfacemask! for setting different boundary regions. At exterior boundaries they are\n    # automatically set by ExtendableGridsjl. Thus, there the following two lines are actually\n    # unneccesarry, but are only written for completeness.\n    bfacemask!(grid, [0.0],                     [0.0],                     bregionAcceptor)     # outer left boundary\n    bfacemask!(grid, [h_total],                 [h_total],                 bregionDonor)  # outer right boundary\n    bfacemask!(grid, [h_pdoping],               [h_pdoping],               bregionJunction1) # first  inner interface\n    bfacemask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic], bregionJunction2) # second inner interface\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend=:lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin            = 1 # electron quasi Fermi potential\n    iphip            = 2 # hole quasi Fermi potential\n    numberOfCarriers = 2","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"We define the physical data.","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    Ec               = 1.424                *  eV\n    Ev               = 0.0                  *  eV\n    Nc               = 4.351959895879690e17 / (cm^3)\n    Nv               = 9.139615903601645e18 / (cm^3)\n    mun              = 8500.0               * (cm^2) / (V * s)\n    mup              = 400.0                * (cm^2) / (V * s)\n    εr               = 12.9                 *  1.0              # relative dielectric permittivity of GAs\n    T                = 300.0                *  K\n\n    # recombination parameters\n    Auger            = 1.0e-29              * cm^6 / s\n    SRH_TrapDensity  = 1.0e10               / cm^3\n    SRH_LifeTime     = 1.0                  * ns\n    Radiative        = 1.0e-10              * cm^3 / s\n\n    # doping\n    dopingFactorNd   = 1.0\n    dopingFactorNa   = 0.46\n    Nd               = dopingFactorNd * Nc\n    Na               = dopingFactorNa * Nv\n\n    # intrinsic concentration\n    ni               = sqrt(Nc * Nv) * exp(-(Ec - Ev) / (2 * kB * T))\n\n    # contact voltage: we impose an applied voltage only on one boundary.\n    # At the other boundary the applied voltage is zero.\n    voltageAcceptor  = 1.5                  * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"We initialize the Data instance and fill in predefined data.","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    data                               = Data(grid, numberOfCarriers)\n\n    # Following variable declares, if we want to solve stationary or transient problem\n    data.modelType                     = Stationary\n\n    # Following choices are possible for F: Boltzmann, FermiDiracOneHalfBednarczyk,\n    # FermiDiracOneHalfTeSCA, FermiDiracMinusOne, Blakemore\n    data.F                            .= Boltzmann\n\n    # Here, we need to specify which numbers are associated with electron and hole quasi\n    # Fermi potential. Further, the desired recombination processes can be chosen here.\n    # Note that, if you choose a SRH recombination you can further specify a transient SRH\n    # recombination by the method enable_trap_carrier! and adjusting the modelType. Otherwise, by\n    # default we use the stationary model for this type of recombination.\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = true,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Following choices are possible for boundary model: For contacts currently only\n    # OhmicContact and SchottkyContact are possible. For inner boundaries we have\n    # InterfaceNone, InterfaceRecombination.\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n\n    # Following choices are possible for the flux discretization scheme: ScharfetterGummel,\n    # ScharfetterGummelGraded, ExcessChemicalPotential, ExcessChemicalPotentialGraded,\n    # DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation            .= ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"Define the Params struct. Params contains all necessary physical parameters. If one wants to simulate space-dependent variables, one additionally needs to generate a ParamsNodal struct, see Ex102.","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    params                                              = Params(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = -1\n    params.chargeNumbers[iphip]                         =  1\n\n    for ireg in 1:numberOfRegions # region data\n\n        params.dielectricConstant[ireg]                 = εr * ε0\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = Nc\n        params.densityOfStates[iphip, ireg]             = Nv\n        params.bandEdgeEnergy[iphin, ireg]              = Ec\n        params.bandEdgeEnergy[iphip, ireg]              = Ev\n        params.mobility[iphin, ireg]                    = mun\n        params.mobility[iphip, ireg]                    = mup\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = Radiative\n        params.recombinationSRHLifetime[iphin, ireg]    = SRH_LifeTime\n        params.recombinationSRHLifetime[iphip, ireg]    = SRH_LifeTime\n        params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity\n        params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity\n        params.recombinationAuger[iphin, ireg]          = Auger\n        params.recombinationAuger[iphip, ireg]          = Auger\n\n    end\n\n    # doping\n    params.doping[iphin, regionDonor]                   = Nd     # data.doping   = [0.0  Na;\n    params.doping[iphin, regionIntrinsic]               = ni     #                  ni  0.0;\n    params.doping[iphip, regionAcceptor]                = Na     #                  Nd  0.0]","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"Region dependent params is now a substruct of data which is again a substruct of the system and will be parsed in next step.","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    data.params                                         = params","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"In the last step, we initialize our system with previous data which is likewise dependent on the parameters. It is important that this is in the end, otherwise our VoronoiFVMSys is not dependent on the data we initialized but rather on default data.","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    ctsys                                               = System(grid, data, unknown_storage=unknown_storage)\n\n    if test == false\n        # Here we can show region dependent physical parameters. show_params() only supports\n        # region dependent parameters, but, if one wishes to print nodal dependent parameters,\n        # currently this is possible with println(ctsys.data.paramsnodal). We neglected here,\n        # since in most applications where the numberOfNodes is >> 10 this would results in a\n        # large output in the terminal.\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    if plotting == true\n        ################################################################################\n        println(\"Plot electroneutral potential, band-edge energies and doping\")\n        ################################################################################\n        # set legend for plotting routines. Either you can use the predefined labels or write your own.\n        label_solution, label_density, label_energy, label_BEE = set_plotting_labels(data)\n\n        psi0 = electroNeutralSolution!(ctsys)\n        PyPlot.figure()\n        plot_energies(Plotter, ctsys, label_BEE)\n        Plotter.figure()\n        plot_doping(Plotter, ctsys, label_density)\n        Plotter.figure()\n        plot_electroNeutralSolutionBoltzmann(Plotter, grid, psi0, ;plotGridpoints=true)\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control              = SolverControl()\n    control.verbose      = verbose\n    control.maxiters     = 50\n    control.abstol       = 1.0e-14\n    control.reltol       = 1.0e-14\n    control.tol_round    = 1.0e-8\n    control.damp_initial = 0.5\n    control.max_round    = 3\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # calculate equilibrium solution and as initial guess\n    solution  = equilibrium_solve!(ctsys, control = control)\n    inival    = solution\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################\n\n    maxBias    = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    biasValues = range(0, stop = maxBias, length = 32)\n    IV         = zeros(0)\n\n    for Δu in biasValues\n\n        if test == false\n            println(\"bias value: Δu = \", Δu, \" V\")\n        end\n\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        solution  = solve(ctsys; inival = inival, control = control)\n        inival   .= solution\n\n        # Note that the old way of solving will be soon removed (see current API changes in VoronoiFVM)","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"solve!(solution, inival, ctsys, control = control, tstep = Inf) inival .= solution","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"        # get I-V data\n        current = get_current_val(ctsys, solution)\n\n        push!(IV,  abs.(w_device * z_device * ( current)) )\n\n    end # bias loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    # plot solution and IV curve\n    if plotting\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution,  \"Applied voltage Δu = $(biasValues[end])\", label_energy,   plotGridpoints = false)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution,  \"Applied voltage Δu = $(biasValues[end])\", label_solution, plotGridpoints = true)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"Applied voltage Δu = $(biasValues[end])\", label_density,  plotGridpoints = true)\n        Plotter.figure()\n        plot_IV(Plotter, biasValues,IV,  \"Applied voltage Δu = $(biasValues[end])\", plotGridpoints = true)\n    end\n\n    testval = solution[15]\n    return testval\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\nend #  main\n\nfunction test()\n    testval = 1.5068426833371802\n    main(test = true, unknown_storage=:dense) ≈ testval && main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when the PIN module has successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"plot/#Plotting-Routines","page":"Plotting Routines","title":"Plotting Routines","text":"","category":"section"},{"location":"plot/","page":"Plotting Routines","title":"Plotting Routines","text":"The same design as in VoronoiFVM.jl is used: To avoid dependencies for this package, the plot methods defined in this package have as their first argument the module of the plotting package used.","category":"page"},{"location":"plot/","page":"Plotting Routines","title":"Plotting Routines","text":"Currently, only PyPlot was tested.","category":"page"},{"location":"examples/Ex201_PSC_tensorGrid/#PSC-device-on-2D-domain-(Tensor-grid).","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"","category":"section"},{"location":"examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"(source code)","category":"page"},{"location":"examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"Simulating a three layer PSC device PCBM | MAPI | Pedot with mobile ions. The simulations are performed in 2D on a tensor grid, out of equilibrium and with abrupt interfaces.","category":"page"},{"location":"examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"module Ex201_PSC_tensorGrid\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot\n\nfunction main(;n = 3, Plotter = PyPlot, plotting = false, verbose = false, test = false,\n              parameter_file = \"../parameter_files/Params_PSC_PCBM_MAPI_Pedot.jl\", # choose the parameter file)\n              )\n\n    PyPlot.close(\"all\")\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    include(parameter_file) # include the parameter file we specified\n\n    bregionNoFlux   = 3\n    height          = 5.00e-6 * cm\n\n    # contact voltage\n    voltageAcceptor = 1.2 * V\n\n    # primary data for I-V scan protocol\n    scanrate        = 0.4 * V/s\n    number_tsteps   = 31\n    endVoltage      = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n\n    # with fixed timestep sizes we can calculate the times a priori\n    tend            = endVoltage/scanrate\n    tvalues         = range(0, stop = tend, length = number_tsteps)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    δ            = 4*n        # the larger, the finer the mesh\n    t            = 0.5*(cm)/δ # tolerance for geomspace and glue (with factor 10)\n    k            = 1.5        # the closer to 1, the closer to the boundary geomspace\n\n    coord_n_u    = collect(range(0.0, h_ndoping/2, step=h_ndoping/(0.6*δ)))\n    coord_n_g    = geomspace(h_ndoping/2, h_ndoping,\n                             h_ndoping/(0.7*δ), h_ndoping/(1.1*δ),\n                             tol=t)\n    coord_i_g1   = geomspace(h_ndoping, h_ndoping+h_intrinsic/k,\n                             h_intrinsic/(5.1*δ), h_intrinsic/(1.0*δ),\n                             tol=t)\n    coord_i_g2   = geomspace(h_ndoping+h_intrinsic/k, h_ndoping+h_intrinsic,\n                             h_intrinsic/(1.0*δ), h_intrinsic/(5.1*δ),\n                             tol=t)\n    coord_p_g    = geomspace(h_ndoping+h_intrinsic, h_ndoping+h_intrinsic+h_pdoping/2,\n                             h_pdoping/(1.3*δ), h_pdoping/(0.3*δ),\n                             tol=t)\n    coord_p_u    = collect(range(h_ndoping+h_intrinsic+h_pdoping/2, h_ndoping+h_intrinsic+h_pdoping, step=h_pdoping/(0.6*δ)))\n\n    coord        = glue(coord_n_u, coord_n_g,  tol=10*t)\n    coord        = glue(coord,     coord_i_g1, tol=10*t)\n    coord        = glue(coord,     coord_i_g2, tol=10*t)\n    coord        = glue(coord,     coord_p_g,  tol=10*t)\n    coord_length = glue(coord,     coord_p_u,  tol=10*t)\n\n    height_L     = geomspace(0.0, height/2, height/(0.4*δ), height/(0.4*δ))\n    height_R     = geomspace(height/2, height, height/(0.4*δ), height/(0.4*δ))\n    coord_height = glue(height_L, height_R, tol = 10*t)\n\n    grid         = simplexgrid(coord_length, coord_height)\n\n    # specify inner regions\n    cellmask!(grid, [0.0, 0.0],                     [h_ndoping, height],               regionDonor, tol = 1.0e-18)\n    cellmask!(grid, [h_pdoping, 0.0],               [h_ndoping + h_intrinsic, height], regionIntrinsic, tol = 1.0e-18)\n    cellmask!(grid, [h_ndoping + h_intrinsic, 0.0], [h_total, height],                 regionAcceptor, tol = 1.0e-18)\n\n    # specifiy outer regions\n    # metal interfaces\n    bfacemask!(grid, [0.0, 0.0], [0.0, height], bregionDonor)            # BregionNumber = 1\n    bfacemask!(grid, [h_total, 0.0], [h_total, height], bregionAcceptor) # BregionNumber = 2\n\n    # no flux interfaces [xmin, ymin], [xmax, ymax]\n    bfacemask!(grid, [0.0, 0.0], [h_total, 0.0], bregionNoFlux)          # BregionNumber = 3\n    bfacemask!(grid, [0.0, height], [h_total, height], bregionNoFlux)    # BregionNumber = 3\n\n    if plotting\n        gridplot(grid, Plotter= Plotter, resolution=(600,400),linewidth=0.5, legend=:lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in data\n    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Transient\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F                             = [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = false,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n\n    # Present ionic vacancies in perovskite layer\n    enable_ionic_carrier!(data, ionicCarrier = iphia, regions = [regionIntrinsic])\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation            .= ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                              = Params(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = zn\n    params.chargeNumbers[iphip]                         = zp\n    params.chargeNumbers[iphia]                         = za\n\n    for ireg in 1:numberOfRegions # region data\n\n        params.dielectricConstant[ireg]                 = ε[ireg] * ε0\n\n        # effective DOS, band edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = Nn[ireg]\n        params.densityOfStates[iphip, ireg]             = Np[ireg]\n        params.densityOfStates[iphia, ireg]             = Na[ireg]\n\n        params.bandEdgeEnergy[iphin, ireg]              = En[ireg]\n        params.bandEdgeEnergy[iphip, ireg]              = Ep[ireg]\n        params.bandEdgeEnergy[iphia, ireg]              = Ea[ireg]\n\n        params.mobility[iphin, ireg]                    = μn[ireg]\n        params.mobility[iphip, ireg]                    = μp[ireg]\n        params.mobility[iphia, ireg]                    = μa[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]    = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = trap_density!(iphin, ireg, params, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg] = trap_density!(iphip, ireg, params, EI[ireg])\n\n    end\n\n    # interior doping\n    params.doping[iphin, regionDonor]                   = Cn\n    params.doping[iphia, regionIntrinsic]               = Ca\n    params.doping[iphip, regionAcceptor]                = Cp\n\n    data.params                                         = params\n    ctsys                                               = System(grid, data, unknown_storage=:sparse)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control              = SolverControl()\n    control.verbose      = verbose\n    control.maxiters     = 300\n    control.max_round    = 5\n    control.damp_initial = 0.1\n    control.damp_growth  = 1.21 # >= 1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium for Boltzmann\")\n    end\n    ################################################################################\n\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival   = solution\n\n    if plotting # currently, plotting the solution was only tested with PyPlot.\n        ipsi = data.index_psi\n        X = grid[Coordinates][1,:]\n        Y = grid[Coordinates][2,:]\n\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[ipsi, :])\n        Plotter.title(\"Electrostatic potential \\$ \\\\psi \\$ (Equilibrium)\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        Plotter.tight_layout()\n        ################\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[iphin,:] )\n        Plotter.title(\"quasi Fermi potential \\$ \\\\varphi_n \\$ (Equilibrium)\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        Plotter.tight_layout()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"I-V Measurement Loop\")\n    end\n    ################################################################################\n\n    # for saving I-V data\n    IV            = zeros(0) # for IV values\n    biasValues    = zeros(0) # for bias values\n\n    for istep = 2:number_tsteps\n\n        t  = tvalues[istep]       # Actual time\n        Δu = t * scanrate         # Applied voltage\n        Δt = t - tvalues[istep-1] # Time step size\n\n        # Apply new voltage; set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: t = $(t) s\")\n        end\n\n        solution = solve(ctsys, inival = inival, control = control, tstep = Δt)\n\n        # get I-V data\n        current  = get_current_val(ctsys, solution, inival, Δt)\n\n        push!(IV, current)\n        push!(biasValues, Δu)\n\n        inival   = solution\n    end # time loop\n\n    if plotting\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[ipsi, :])\n        Plotter.title(\"Electrostatic potential \\$ \\\\psi \\$ at end time\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        ################\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[iphin,:] )\n        Plotter.title(\"quasi Fermi potential \\$ \\\\varphi_n \\$ at end time\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        ################\n        Plotter.figure()\n        Plotter.plot(biasValues, IV.*(cm)^2/height, label = \"\",  linewidth= 3, marker = \"o\")\n        PyPlot.grid()\n        Plotter.ylabel(\"total current [A]\") #\n        Plotter.xlabel(\"Applied Voltage [V]\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = sum(filter(!isnan, solution))/length(solution) # when using sparse storage, we get NaN values in solution\n    return testval\n\nend #  main\n\nfunction test()\n    testval = -0.5818799192233242\n    main(test = true) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"","category":"page"},{"location":"examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/#GaAs-diode-with-spatially-varying-doping-(1D).","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"","category":"section"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"Simulating charge transport in a GaAs pin diode. This means the PDE problem corresponds to the van Roosbroeck system of equations. The simulations are performed out of equilibrium and for the stationary problem. A special feature here is that the doping is node-dependent.","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"module Ex102_PIN_nodal_doping\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot\n\nfunction main(;Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage=:sparse)\n\n    Plotter.close(\"all\")\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionAcceptor   = 1          # p doped region\n    regionIntrinsic  = 2          # intrinsic region\n    regionDonor      = 3          # n doped region\n    regions          = [regionAcceptor, regionIntrinsic, regionDonor]\n    numberOfRegions  = length(regions)\n\n    # boundary region numbers\n    # Note that by convention we have 1 for the left boundary and 2 for the right boundary. If\n    # adding additional interior boundaries, continue with 3, 4, ...\n    bregionAcceptor  = 1\n    bregionDonor     = 2\n    bregionJunction1 = 3\n    bregionJunction2 = 4\n\n    h_pdoping        = 0.1    * μm\n    h_intrinsic      = 0.1    * μm\n    h_ndoping        = 0.1    * μm\n    h_total          = h_pdoping + h_intrinsic + h_ndoping\n    w_device         = 0.1    * μm  # width of device\n    z_device         = 1.0e-5 * cm  # depth of device\n\n    coord            = range(0.0, stop = h_ndoping + h_intrinsic + h_pdoping, length = 25)\n    coord            = collect(coord)\n    grid             = simplexgrid(coord)\n    numberOfNodes    = length(coord)\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm],                [h_pdoping],                           regionAcceptor,  tol = 1.0e-15)    # p-doped region = 1\n    cellmask!(grid, [h_pdoping],               [h_pdoping + h_intrinsic],             regionIntrinsic, tol = 1.0e-15)    # intrinsic region = 2\n    cellmask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic + h_ndoping], regionDonor,     tol = 1.0e-15)    # n-doped region = 3\n\n    # bfacemask! for setting different boundary regions\n    bfacemask!(grid, [0.0],                     [0.0],                     bregionAcceptor)     # outer left boundary\n    bfacemask!(grid, [h_total],                 [h_total],                 bregionDonor)  # outer right boundary\n    bfacemask!(grid, [h_pdoping],               [h_pdoping],               bregionJunction1) # first  inner interface\n    bfacemask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic], bregionJunction2) # second inner interface\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend=:lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin              = 1 # electron quasi Fermi potential\n    iphip              = 2 # hole quasi Fermi potential\n    numberOfCarriers   = 2\n\n    # Define the physical data.\n    Ec                 = 1.424                *  eV\n    Ev                 = 0.0                  *  eV\n    Nc                 = 4.351959895879690e17 / (cm^3)\n    Nv                 = 9.139615903601645e18 / (cm^3)\n    mun                = 8500.0               * (cm^2) / (V * s)\n    mup                = 400.0                * (cm^2) / (V * s)\n    εr                 = 12.9                 *  1.0              # relative dielectric permittivity of GAs\n    T                  = 300.0                *  K\n\n    # recombination parameters\n    SRH_TrapDensity_n  = 4.760185435081902e5    / cm^3\n    SRH_TrapDensity_p  = 9.996936448738406e6    / cm^3\n    SRH_LifeTime       = 1.0                    * ps\n\n    # contact voltage\n    voltageAcceptor    = 1.4 * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"We initialize the Data instance and fill in predefined data.","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Stationary\n\n    # Possible choices for F: Boltzmann, FermiDiracOneHalfBednarczyk,\n    # FermiDiracOneHalfTeSCA, FermiDiracMinusOne, Blakemore\n    data.F                            .= Boltzmann\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                bulk_recomb_Auger = false,\n                                                                bulk_recomb_radiative = false,\n                                                                bulk_recomb_SRH = true)\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation            .= ScharfetterGummel\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"Define the Params and ParamsNodal struct.","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"    params                                              = Params(grid, numberOfCarriers)\n    paramsnodal                                         = ParamsNodal(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = -1\n    params.chargeNumbers[iphip]                         =  1\n\n    for ireg in 1:numberOfRegions           # region data\n\n        params.dielectricConstant[ireg]                 = εr * ε0\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = Nc\n        params.densityOfStates[iphip, ireg]             = Nv\n        params.bandEdgeEnergy[iphin, ireg]              = Ec\n        params.bandEdgeEnergy[iphip, ireg]              = Ev\n        params.mobility[iphin, ireg]                    = mun\n        params.mobility[iphip, ireg]                    = mup\n\n        # recombination parameters\n        params.recombinationSRHLifetime[iphin, ireg]    = SRH_LifeTime\n        params.recombinationSRHLifetime[iphip, ireg]    = SRH_LifeTime\n        params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity_n\n        params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity_p\n\n    end\n\n    # initialize the space dependent doping (see FarrellPeschka2019, Computers & Mathematics with Applications, 2019).\n    NDoping  = 1.0e17  / cm^3\n    κ        = 500.0\n    for icoord = 1:numberOfNodes\n        paramsnodal.doping[icoord] = NDoping * 0.5 * ( 1.0  +  tanh( (0.1 - coord[icoord]/μm) *κ )  - ( 1.0 + tanh( (coord[icoord]/μm - 0.2) * κ )) )\n    end\n\n    data.params      = params\n    data.paramsnodal = paramsnodal\n\n    ctsys            = System(grid, data, unknown_storage=unknown_storage)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    if test == false\n        show_params(ctsys)\n    end\n\n    if plotting == true\n        ################################################################################\n        println(\"Plot doping\")\n        ################################################################################\n        Plotter.figure()\n        plot_doping(Plotter, grid, paramsnodal)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control           = SolverControl()\n    control.verbose   = verbose\n    control.abstol    = 1.0e-14\n    control.reltol    = 1.0e-14\n    control.max_round = 5\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium for Boltzmann\")\n    end\n    ################################################################################\n\n    # calculate equilibrium solution and as initial guess\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival   = solution\n\n    if plotting\n        # set legend for plotting routines. Either you can use the predefined labels or write your own.\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        Plotter.figure()\n        plot_energies(Plotter,  ctsys, solution, \"Equilibrium\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"Equilibrium\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter,  ctsys, solution, \"Equilibrium\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################\n\n    maxBias    = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    biasValues = range(0, stop = maxBias, length = 41)\n    IV         = zeros(0)\n\n    for Δu in biasValues\n\n        if test == false\n            println(\"bias value: Δu  = \", Δu, \" V\")\n        end\n\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        solution  = solve(ctsys; inival = inival, control = control)\n        inival   .= solution\n\n        # Note that the old way of solving will be soon removed (see current API changes in VoronoiFVM)","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"solve!(solution, inival, ctsys, control = control, tstep = Inf) inival .= solution","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"        # get IV curve\n        factory = TestFunctionFactory(ctsys)\n\n        # testfunction zero in bregionAcceptor and one in bregionDonor\n        tf      = testfunction(factory, [bregionAcceptor], [bregionDonor])\n        I       = integrate(ctsys, tf, solution)\n\n        push!(IV,  abs.(w_device * z_device * (I[iphin] + I[iphip])))\n\n    end # bias loop\n\n\n    if plotting # plot solution and IV curve\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"Applied voltage Δu = $(biasValues[end])\",  label_energy)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"Applied voltage Δu = $(biasValues[end])\",  label_solution, plotGridpoints = true)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"Applied voltage Δu = $(biasValues[end])\", label_density,  plotGridpoints = true)\n        Plotter.figure()\n        plot_IV(Plotter, biasValues,IV, \"Applied voltage Δu = $(biasValues[end])\", plotGridpoints = true)\n    end\n\n    testval = solution[15]\n    return testval\n\nend #  main\n\nfunction test()\n    testval = 1.4676876548796856\n    main(test = true, unknown_storage=:dense) ≈ testval && main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when the PIN module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Ex109_Traps/#GaAs-diode:-transient-with-traps-(1D).","page":"GaAs diode: transient with traps (1D).","title":"GaAs diode: transient with traps (1D).","text":"","category":"section"},{"location":"examples/Ex109_Traps/","page":"GaAs diode: transient with traps (1D).","title":"GaAs diode: transient with traps (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex109_Traps/","page":"GaAs diode: transient with traps (1D).","title":"GaAs diode: transient with traps (1D).","text":"Simulating transient charge transport in a GaAs p-i-n diode with an electron trap.","category":"page"},{"location":"examples/Ex109_Traps/","page":"GaAs diode: transient with traps (1D).","title":"GaAs diode: transient with traps (1D).","text":"module Ex109_Traps\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot\n\n# function to initialize the grid for a possble extension to other p-i-n devices.\nfunction initialize_pin_grid(refinementfactor, h_ndoping, h_intrinsic, h_pdoping)\n    coord_ndoping   = collect(range(0.0, stop = h_ndoping, length = 3 * refinementfactor))\n    coord_intrinsic = collect(range(h_ndoping, stop = (h_ndoping + h_intrinsic), length = 3 * refinementfactor))\n    coord_pdoping   = collect(range((h_ndoping + h_intrinsic),\n                                     stop = (h_ndoping + h_intrinsic + h_pdoping),\n                                     length = 3 * refinementfactor))\n    coord           = glue(coord_ndoping, coord_intrinsic)\n    coord           = glue(coord, coord_pdoping)\n\n    return coord\nend\n\nfunction main(;n = 3, Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage=:sparse)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionAcceptor   = 1                           # p doped region\n    regionIntrinsic  = 2                           # intrinsic region\n    regionDonor      = 3                           # n doped region\n    regions          = [regionAcceptor, regionIntrinsic, regionDonor]\n    numberOfRegions  = length(regions)\n\n    # boundary region numbers\n    bregionAcceptor  = 1\n    bregionDonor     = 2\n    bregionJunction1 = 3\n    bregionJunction2 = 4\n\n    # grid\n    refinementfactor = 2^(n-1)\n    h_pdoping        = 2.0    * μm\n    h_intrinsic      = 2.0    * μm\n    h_ndoping        = 2.0    * μm\n    h_total          = h_pdoping + h_intrinsic + h_ndoping\n    w_device         = 0.5    * μm  # width of device\n    z_device         = 1.0e-4 * cm  # depth of device\n\n    coord            = initialize_pin_grid(refinementfactor,\n                                           h_pdoping,\n                                           h_intrinsic,\n                                           h_ndoping)\n\n    grid             = simplexgrid(coord)\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm],                 [h_pdoping],               regionAcceptor)  # p-doped\n    cellmask!(grid, [h_pdoping],                [h_pdoping + h_intrinsic], regionIntrinsic) # intrinsic\n    cellmask!(grid, [h_pdoping + h_intrinsic],  [h_total],                 regionDonor)     # n-doped\n\n    bfacemask!(grid, [h_pdoping],               [h_pdoping],               bregionJunction1, tol = 1.0e-18)\n    bfacemask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic], bregionJunction2, tol = 1.0e-18)\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend=:lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    iphin            = 1 # index electron quasi Fermi potential\n    iphip            = 2 # index hole quasi Fermi potential\n    iphit            = 3 # index trap quasi Fermi potential\n    numberOfCarriers = 3 # electrons, holes and traps\n\n    # physical data\n    Ec               = 1.424                             *  eV\n    Ev               = 0.0                               *  eV\n    Et               = 0.6                               *  eV\n    Nc               = 4.351959895879690e17              / (cm^3)\n    Nv               = 9.139615903601645e18              / (cm^3)\n    Nt               = 1e16                              / (cm^3)\n    mun              = 8500.0                            * (cm^2) / (V * s)\n    mup              = 400.0                             * (cm^2) / (V * s)\n    mut              = 0.0                               * (cm^2) / (V * s)  # such that there is no flux\n    εr               = 12.9                              *  1.0              # relative dielectric permittivity of GAs\n    T                = 300.0                             *  K\n\n    # recombination parameters\n    ni               = sqrt(Nc * Nv) * exp(-(Ec - Ev) / (2 * kB * T))        # intrinsic concentration\n    n0               = Nc * Boltzmann( (Et-Ec) / (kB*T) )                    # Boltzmann equilibrium concentration\n    p0               = ni^2 / n0                                             # Boltzmann equilibrium concentration\n    Auger            = 1.0e-29                           * cm^6 / s          # 1.0e-41\n    SRH_LifeTime     = 1.0e-3                            * ns\n    Radiative        = 1.0e-10                           * cm^3 / s          # 1.0e-16\n    G                = 1.0e25                            / (cm^3 * s)\n\n    # doping -- trap doping will not be set and thus automatically zero\n    dopingFactorNd   = 1.0\n    dopingFactorNa   = 0.46\n    Nd               = dopingFactorNd * Nc\n    Na               = dopingFactorNa * Nv\n\n    # contact voltage\n    voltageAcceptor  = 1.5                               * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in data\n    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Transient\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F                            .= [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = true,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Here, we enable the traps and parse the respective index and the regions where the trap is defined.\n    enable_trap_carrier!(;data = data, trapCarrier = iphit, regions = regions)\n\n    # Possible choices: GenerationNone, GenerationUniform\n    data.generationModel               = GenerationUniform\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation            .= ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                              = Params(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = -1\n    params.chargeNumbers[iphip]                         =  1\n    params.chargeNumbers[iphit]                         = -1 # trap charge number determines whether hole or electron trap is used\n\n    for ireg in 1:numberOfRegions           # region data\n\n        params.dielectricConstant[ireg]                 = εr * ε0\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = Nc\n        params.densityOfStates[iphip, ireg]             = Nv\n        params.densityOfStates[iphit, ireg]             = Nt\n        params.bandEdgeEnergy[iphin, ireg]              = Ec\n        params.bandEdgeEnergy[iphip, ireg]              = Ev\n        params.bandEdgeEnergy[iphit, ireg]              = Et\n        params.mobility[iphin, ireg]                    = mun\n        params.mobility[iphip, ireg]                    = mup\n        params.mobility[iphit, ireg]                    = mut\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = Radiative\n        params.recombinationSRHLifetime[iphin, ireg]    = SRH_LifeTime\n        params.recombinationSRHLifetime[iphip, ireg]    = SRH_LifeTime\n        params.recombinationSRHTrapDensity[iphin, ireg] = n0\n        params.recombinationSRHTrapDensity[iphip, ireg] = p0\n        params.recombinationAuger[iphin, ireg]          = Auger\n        params.recombinationAuger[iphip, ireg]          = Auger\n        params.generationUniform[ireg]                  = G\n\n    end\n\n    # doping\n    params.doping[iphin, regionDonor]                   = Nd\n    params.doping[iphin, regionIntrinsic]               = ni\n    params.doping[iphip, regionIntrinsic]               = 0.0\n    params.doping[iphip, regionAcceptor]                = Na\n\n    data.params                                         = params\n    ctsys                                               = System(grid, data, unknown_storage=unknown_storage)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control                = SolverControl()\n    control.verbose        = verbose\n    control.tol_round      = 1.0e-4\n    control.damp_initial   = 0.5\n    control.damp_growth    = 1.61\n    control.max_round      = 3\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # solve thermodynamic equilibrium and update initial guess\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival   = solution\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    if plotting\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        # add labels for traps\n        label_energy[1, iphit] = \"\\$E_{\\\\tau}-q\\\\psi\\$\"; label_energy[2, iphit] = \"\\$ - q \\\\varphi_{\\\\tau}\\$\"\n        label_density[iphit]   = \"\\$n_{\\\\tau}\\$\";        label_solution[iphit]  = \"\\$ \\\\varphi_{\\\\tau}\\$\"\n\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"Equilibrium\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution,\"Equilibrium\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"Equilibrium\", label_solution)\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Loop for putting generation on\")\n    end\n    ################################################################################\n\n    # Scan rate and time steps\n    scanrate      = 1.0 * V/s\n    number_tsteps = 25\n    endVoltage    = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n\n    # with fixed timestep sizes we can calculate the times\n    # a priori\n    tend          = endVoltage/scanrate\n    tvalues       = range(0.0, stop = tend, length = number_tsteps)\n    Δt            = tvalues[2] - tvalues[1]","category":"page"},{"location":"examples/Ex109_Traps/","page":"GaAs diode: transient with traps (1D).","title":"GaAs diode: transient with traps (1D).","text":"these values are needed for putting the generation slightly on","category":"page"},{"location":"examples/Ex109_Traps/","page":"GaAs diode: transient with traps (1D).","title":"GaAs diode: transient with traps (1D).","text":"    I             = collect(20:-1:0.0)\n    LAMBDA        = 10 .^ (-I)\n\n    IV            = zeros(0) # for IV values\n    biasValues    = zeros(0) # for bias values\n\n    for istep = 1:length(I)-1\n\n        # turn slowly generation on\n        data.λ2   = LAMBDA[istep + 1]\n\n        if test == false\n            println(\"increase generation with λ2 = $(data.λ2)\")\n        end\n\n        solution = solve(ctsys, inival = inival, control = control)\n        inival   = solution\n\n    end # generation loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"IV Measurement loop\")\n    end\n    ################################################################################\n\n    for istep = 2:number_tsteps\n\n        t  = tvalues[istep]          # Actual time\n        Δu = t * scanrate            # Applied voltage\n        Δt = t - tvalues[istep-1]    # Time step size\n\n        # Apply new voltage: set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: t = $(t) s\")\n        end\n\n        solution = solve(ctsys, inival = inival, control = control, tstep = Δt)\n\n        # get I-V data\n        current  = get_current_val(ctsys, solution, inival, Δt)\n\n        push!(IV, w_device * z_device * current)\n        push!(biasValues, Δu)\n\n        inival   = solution\n\n    end # bias loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    # plot solution and IV curve\n    if plotting\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage), \\$ t=$(tvalues[number_tsteps])\\$\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution,\"bias \\$\\\\Delta u\\$ = $(endVoltage), \\$ t=$(tvalues[number_tsteps])\\$\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage), \\$ t=$(tvalues[number_tsteps])\\$\", label_solution)\n        Plotter.figure()\n        plot_IV(Plotter, biasValues,IV, \"bias \\$\\\\Delta u\\$ = $(biasValues[end])\", plotGridpoints = true)\n    end\n\n    testval = sum(filter(!isnan, solution))/length(solution) # when using sparse storage, we get NaN values in solution\n    return testval\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\nend #  main\n\nfunction test()\n    testval = 0.9699245385329192\n    main(test = true, unknown_storage=:dense) ≈ testval && main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when the PIN module has successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex109_Traps/","page":"GaAs diode: transient with traps (1D).","title":"GaAs diode: transient with traps (1D).","text":"","category":"page"},{"location":"examples/Ex109_Traps/","page":"GaAs diode: transient with traps (1D).","title":"GaAs diode: transient with traps (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Ex106_PSC_SurfaceRecombination/#PSC-device-with-surface-recombination-(1D).","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"","category":"section"},{"location":"examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"Simulating a three layer PSC device PCBM | MAPI | Pedot with mobile ions with a linear scan protocol.","category":"page"},{"location":"examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"Here, the surface recombination at internal boundaries is tested.","category":"page"},{"location":"examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"module Ex106_PSC_SurfaceRecombination\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot\n\nfunction main(;n = 6, Plotter = PyPlot, plotting = false,\n               verbose = false, test = false,\n               parameter_file = \"../parameter_files/Params_PSC_PCBM_MAPI_Pedot.jl\", # choose the parameter file\n              )\n\n    Plotter.close(\"all\")\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    include(parameter_file) # include the parameter file we specified\n\n    # contact voltage\n    voltageAcceptor = 1.2 * V\n\n    # primary data for I-V scan protocol\n    scanrate   = 1.0 * V/s\n    ntsteps    = 31\n    vend       = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    tend       = vend/scanrate\n\n    # with fixed timestep sizes we can calculate the times a priori\n    tvalues    = range(0, stop = tend, length = ntsteps)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    δ          = 4*n        # the larger, the finer the mesh\n    t          = 0.5*(cm)/δ # tolerance for geomspace and glue (with factor 10)\n    k          = 1.5        # the closer to 1, the closer to the boundary geomspace\n\n    coord_n_u  = collect(range(0.0, h_ndoping/2, step=h_ndoping/(0.8*δ)))\n    coord_n_g  = geomspace(h_ndoping/2, h_ndoping,\n                           h_ndoping/(0.7*δ), h_ndoping/(1.1*δ),\n                           tol=t)\n    coord_i_g1 = geomspace(h_ndoping, h_ndoping+h_intrinsic/k,\n                           h_intrinsic/(5.1*δ), h_intrinsic/(1.1*δ),\n                           tol=t)\n    coord_i_g2 = geomspace(h_ndoping+h_intrinsic/k, h_ndoping+h_intrinsic,\n                            h_intrinsic/(1.1*δ), h_intrinsic/(5.1*δ),\n                           tol=t)\n    coord_p_g  = geomspace(h_ndoping+h_intrinsic, h_ndoping+h_intrinsic+h_pdoping/2,\n                           h_pdoping/(1.3*δ), h_pdoping/(0.6*δ),\n                           tol=t)\n    coord_p_u  = collect(range(h_ndoping+h_intrinsic+h_pdoping/2, h_ndoping+h_intrinsic+h_pdoping, step=h_pdoping/(0.8*δ)))\n\n    coord      = glue(coord_n_u, coord_n_g,  tol=10*t)\n    coord      = glue(coord,     coord_i_g1, tol=10*t)\n    coord      = glue(coord,     coord_i_g2, tol=10*t)\n    coord      = glue(coord,     coord_p_g,  tol=10*t)\n    coord      = glue(coord,     coord_p_u,  tol=10*t)\n    grid       = ExtendableGrids.simplexgrid(coord)\n\n    # set different regions in grid\n    cellmask!(grid,  [0.0 * μm],        [heightLayers[1]], regionDonor, tol = 1.0e-18)     # n-doped region   = 1\n    cellmask!(grid,  [heightLayers[1]], [heightLayers[2]], regionIntrinsic, tol = 1.0e-18) # intrinsic region = 2\n    cellmask!(grid,  [heightLayers[2]], [heightLayers[3]], regionAcceptor, tol = 1.0e-18)  # p-doped region   = 3\n\n    # bfacemask! for setting different boundary regions\n    bfacemask!(grid, [0.0],             [0.0],             bregionDonor, tol = 1.0e-18)     # outer left boundary\n    bfacemask!(grid, [h_total],         [h_total],         bregionAcceptor, tol = 1.0e-18)  # outer right boundary\n    bfacemask!(grid, [heightLayers[1]], [heightLayers[1]], bregionJ1, tol = 1.0e-18) # first  inner interface\n    bfacemask!(grid, [heightLayers[2]], [heightLayers[2]], bregionJ2, tol = 1.0e-18) # second inner interface\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend=:lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in data\n    data                                = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                      = Transient\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F                              = [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n\n    data.bulkRecombination              = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = false,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[bregionAcceptor]  = OhmicContact\n    data.boundaryType[bregionJ1]        = InterfaceRecombination\n    data.boundaryType[bregionJ2]        = InterfaceRecombination\n    data.boundaryType[bregionDonor]     = OhmicContact\n\n    # Present ionic vacancies in perovskite layer\n    enable_ionic_carrier!(data, ionicCarrier = iphia, regions = [regionIntrinsic])\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation             .= ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                                = Params(grid, numberOfCarriers)\n\n    params.temperature                                    = T\n    params.UT                                             = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                           = zn\n    params.chargeNumbers[iphip]                           = zp\n    params.chargeNumbers[iphia]                           = za\n\n    for ireg in 1:numberOfRegions ## interior region data\n\n        params.dielectricConstant[ireg]                   = ε[ireg] * ε0\n\n        # effective dos, band edge energy and mobilities\n        params.densityOfStates[iphin, ireg]               = Nn[ireg]\n        params.densityOfStates[iphip, ireg]               = Np[ireg]\n        params.densityOfStates[iphia, ireg]               = Na[ireg]\n\n        params.bandEdgeEnergy[iphin, ireg]                = En[ireg]\n        params.bandEdgeEnergy[iphip, ireg]                = Ep[ireg]\n        params.bandEdgeEnergy[iphia, ireg]                = Ea[ireg]\n\n        params.mobility[iphin, ireg]                      = μn[ireg]\n        params.mobility[iphip, ireg]                      = μp[ireg]\n        params.mobility[iphia, ireg]                      = μa[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]               = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]      = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]      = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg]   = trap_density!(iphin, ireg, params, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg]   = trap_density!(iphip, ireg, params, EI[ireg])\n    end\n\n    ##############################################################\n    # inner boundary region data (we choose the intrinsic values)\n    params.bDensityOfStates[iphin, bregionJ1]             = Nn[regionIntrinsic]\n    params.bDensityOfStates[iphip, bregionJ1]             = Np[regionIntrinsic]\n\n    params.bDensityOfStates[iphin, bregionJ2]             = Nn[regionIntrinsic]\n    params.bDensityOfStates[iphip, bregionJ2]             = Np[regionIntrinsic]\n\n    params.bBandEdgeEnergy[iphin, bregionJ1]              = En[regionIntrinsic]\n    params.bBandEdgeEnergy[iphip, bregionJ1]              = Ep[regionIntrinsic]\n\n    params.bBandEdgeEnergy[iphin, bregionJ2]              = En[regionIntrinsic]\n    params.bBandEdgeEnergy[iphip, bregionJ2]              = Ep[regionIntrinsic]\n\n    # for surface recombination\n    params.recombinationSRHvelocity[iphin, bregionJ1]     = 1.0e1  * cm / s\n    params.recombinationSRHvelocity[iphip, bregionJ1]     = 1.0e5  * cm / s\n\n    params.bRecombinationSRHTrapDensity[iphin, bregionJ1] = params.recombinationSRHTrapDensity[iphin, regionIntrinsic]\n    params.bRecombinationSRHTrapDensity[iphip, bregionJ1] = params.recombinationSRHTrapDensity[iphip, regionIntrinsic]\n\n    params.recombinationSRHvelocity[iphin, bregionJ2]     = 1.0e7  * cm / s\n    params.recombinationSRHvelocity[iphip, bregionJ2]     = 1.0e1  * cm / s\n\n    params.bRecombinationSRHTrapDensity[iphin, bregionJ2] = params.recombinationSRHTrapDensity[iphin, regionIntrinsic]\n    params.bRecombinationSRHTrapDensity[iphip, bregionJ2] = params.recombinationSRHTrapDensity[iphip, regionIntrinsic]\n\n    ##############################################################\n\n    # interior doping\n    params.doping[iphin,  regionDonor]                    = Cn\n    params.doping[iphip,  regionAcceptor]                 = Cp\n    params.doping[iphia,  regionIntrinsic]                = Ca\n\n    data.params                                           = params\n    ctsys                                                 = System(grid, data, unknown_storage=:sparse)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control              = SolverControl()\n    control.verbose      = verbose\n    control.damp_initial = 0.9\n    control.damp_growth  = 1.61 # >= 1\n    control.max_round    = 5\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival   = solution\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"I-V Measurement Loop\")\n    end\n    ################################################################################\n\n    # for saving I-V data\n    IV         = zeros(0) # for IV values\n    biasValues = zeros(0) # for bias values\n\n    for istep = 2:ntsteps\n\n        t  = tvalues[istep]       # Actual time\n        Δu = t * scanrate         # Applied voltage\n        Δt = t - tvalues[istep-1] # Time step size\n\n        # Apply new voltage (set non-equilibrium values)\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: Δt = $(t)\")\n        end\n\n        solution = solve(ctsys, inival = inival, control = control, tstep = Δt)\n        inival   = solution\n\n        # get I-V data\n        current  = get_current_val(ctsys, solution, inival, Δt)\n\n        push!(IV, current)\n        push!(biasValues, Δu)\n\n        if plotting\n            label_solution, label_density, label_energy = set_plotting_labels(data)\n            label_solution[iphia]  = \"\\$ \\\\varphi_a\\$\"\n\n            PyPlot.clf()\n            plot_solution(Plotter, ctsys, solution, \"bias \\$\\\\Delta u\\$ = $(Δu)\", label_solution)\n            PyPlot.pause(0.5)\n        end\n\n    end # time loop\n\n    ##res = [biasValues, IV]\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = sum(filter(!isnan, solution))/length(solution) # when using sparse storage, we get NaN values in solution\n    return testval\n\n\nend # main\n\nfunction test()\n    testval = -0.5963272869004673\n    main(test = true) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"","category":"page"},{"location":"examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"GaAs/#van-Roosbroeck-system","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"In both of the following examples, we solve the van Roosbroeck equations, a system of partial differential equations which describe current flow in a bipolar multi layer device:","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"beginaligned\n\t- nabla cdot (varepsilon_s nabla psi) = q Big( (p(psi varphi_p) - C_p ) - (n(psi varphi_n) - C_n) Big)\n\tq partial_t n(psi varphi_n) -nabla cdot mathbfj_n = -qR(np) \n\tq partial_t p(psi varphi_p) + nabla cdot mathbfj_p = -qR(np)\nendaligned","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Ohmic contacts will be used as boundary conditions. We will proceed as follows","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Step 1: Initialize grid","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Step 2: Initialize physical model","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Step 3: Solve the problem in equilibrium","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Step 4: Solve the problem for an applied bias","category":"page"},{"location":"GaAs/#Example-1:-Stationary-1D-problem-(region-doping)","page":"van Roosbroeck system","title":"Example 1: Stationary 1D problem (region doping)","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"We consider a three-layer GaAs p-i-n device in one dimension. We will explain the PIN example in greater detail.","category":"page"},{"location":"GaAs/#Step-1:-Initialize-grid","page":"van Roosbroeck system","title":"Step 1: Initialize grid","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"We have three layers and two external boundaries. We would like to solve the van Roosbroeck system on a uniform mesh with local grid refinement. We declare subregions and external boundaries.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"## region numbers\nregionAcceptor   = 1          # p doped region\nregionIntrinsic  = 2          # intrinsic region\nregionDonor      = 3          # n doped region\nregions          = [regionAcceptor, regionIntrinsic, regionDonor]\nnumberOfRegions  = length(regions)\n\n## boundary region numbers\n# Note that by convention we have 1 for the left boundary and 2 for the right boundary. If\n# adding additional interior boundaries, continue with 3, 4, ...\nbregionAcceptor  = 1\nbregionDonor     = 2\nbregionJunction1 = 3\nbregionJunction2 = 4\n\n## grid\nrefinementfactor = 2^(n-1)\nh_pdoping        = 2.0    * μm\nh_intrinsic      = 2.0    * μm\nh_ndoping        = 2.0    * μm\nh_total          = h_pdoping + h_intrinsic + h_ndoping\nw_device         = 0.5    * μm  # width of device\nz_device         = 1.0e-4 * cm  # depth of device\ncoord            = initialize_pin_grid(refinementfactor,\n                                        h_pdoping,\n                                        h_intrinsic,\n                                        h_ndoping)\n\ngrid             = simplexgrid(coord)\n\n## cellmask! for defining the subregions and assigning region number\ncellmask!(grid, [0.0 * μm],                [h_pdoping],                           regionAcceptor)  # p-doped region = 1\ncellmask!(grid, [h_pdoping],               [h_pdoping + h_intrinsic],             regionIntrinsic) # intrinsic region = 2\ncellmask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic + h_ndoping], regionDonor)     # n-doped region = 3\n\n## bfacemask! for setting different boundary regions. At exterior boundaries they are automatically set by\n## ExtendableGridsjl. Thus, there the following two lines are actually unneccesarry, but are only written for completeness.\nbfacemask!(grid, [0.0],                     [0.0],                     bregionAcceptor)     # outer left boundary\nbfacemask!(grid, [h_total],                 [h_total],                 bregionDonor)  # outer right boundary\nbfacemask!(grid, [h_pdoping],               [h_pdoping],               bregionJunction1) # first  inner interface\nbfacemask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic], bregionJunction2) # second inner interface","category":"page"},{"location":"GaAs/#Step-2:-Initialize-physical-model","page":"van Roosbroeck system","title":"Step 2: Initialize physical model","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Next, we choose relevant physical models such as the underlying statistics function or the recombination model. Additional options are stated in the comments. Furthermore, we define the charge carrier indices. The index for the electrostatic potential is set automatically to numberOfCarriers + 1.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"# Set indices for the quasi Fermi potentials\niphin                  = 1    # electrons\niphip                  = 2    # holes\nnumberOfCarriers       = 2\n\n# Initialize Data instance\ndata                   = Data(grid, numberOfCarriers)\n\n# Solve the stationary problem instead of the transient one\ndata.modelType         = Stationary\n\n# Choose statistical relation between density and qF potential\n# options: Boltzmann, FermiDiracOneHalfBednarczyk,\n#          FermiDiracOneHalfTeSCA FermiDiracMinusOne, Blakemore\ndata.F                .= Boltzmann\n\n# Enable/Disable recombination processes, the default is stationary SRH recombination.\ndata.bulkRecombination = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                 bulk_recomb_Auger = true,\n                                                 bulk_recomb_radiative = true,\n                                                 bulk_recomb_SRH = true)\n\n# choose boundary models\n# exterior boundaries: OhmicContact and SchottkyContact\n# interior boundaries: InterfaceModelNone, InterfaceModelSurfaceReco.\ndata.boundaryType[bregionAcceptor] = OhmicContact\ndata.boundaryType[bregionDonor]    = OhmicContact\n\n# choose flux discretization scheme: ScharfetterGummel ScharfetterGummelGraded,\n# ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\ndata.fluxApproximation            .= ExcessChemicalPotential","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Next, we fill in pre-defined or externally read in parameter values.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"# params contains all necessary physical parameters\nparams                                              = Params(grid, numberOfCarriers)\nparams.temperature                                  = T\nparams.UT                                           = (kB * params.temperature) / q\nparams.chargeNumbers[iphin]                         = -1\nparams.chargeNumbers[iphip]                         =  1\n\nfor ireg in 1:numberOfRegions           # region data\n\n    params.dielectricConstant[ireg]                 = εr  * ε0\n\n    # effective DOS, band-edge energy and mobilities\n    params.densityOfStates[iphin, ireg]             = Nc\n    params.densityOfStates[iphip, ireg]             = Nv\n    params.bandEdgeEnergy[iphin, ireg]              = Ec\n    params.bandEdgeEnergy[iphip, ireg]              = Ev\n    params.mobility[iphin, ireg]                    = mun\n    params.mobility[iphip, ireg]                    = mup\n\n    # recombination parameters\n    params.recombinationRadiative[ireg]             = Radiative\n    params.recombinationSRHLifetime[iphin, ireg]    = SRH_LifeTime\n    params.recombinationSRHLifetime[iphip, ireg]    = SRH_LifeTime\n    params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity\n    params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity\n    params.recombinationAuger[iphin, ireg]          = Auger\n    params.recombinationAuger[iphip, ireg]          = Auger\n\nend\n\n# doping\nparams.doping[iphin, regionDonor]                   = Nd\nparams.doping[iphin, regionIntrinsic]               = ni\nparams.doping[iphip, regionIntrinsic]               = 0.0\nparams.doping[iphip, regionAcceptor]                = Na\n\n# Initialize a ChargeTransport struct\ndata.params   = params\nctsys         = System(grid, data, unknown_storage=unknown_storage)","category":"page"},{"location":"GaAs/#Step-3:-Solve-the-problem-in-equilibrium","page":"van Roosbroeck system","title":"Step 3: Solve the problem in equilibrium","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Solve the equilibrium. Note that control refers to the SolverControl parameters given in VoronoiFVM.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"solution = equilibrium_solve!(ctsys, control = control)\ninival   = solution","category":"page"},{"location":"GaAs/#Step-4:-Solve-the-problem-for-an-applied-bias","page":"van Roosbroeck system","title":"Step 4: Solve the problem for an applied bias","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Starting from the equilibrium solution, we increase the applied voltage.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"maxBias    = voltageAcceptor # bias at acceptor boundary\nbiasValues = range(0, stop = maxBias, length = 32)\n\nfor Δu in biasValues\n    set_contact!(ctsys, bregionAcceptor, Δu = Δu) # non equilibrium bc\n    solution  = solve(ctsys; inival = inival, control = control)\n    inival   .= solution\nend","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"note: Note\nTo be consistent with the latest changes of VoronoiFVM, please do not use the solve!() function anymore. Otherwise, you will get deprecation warnings.","category":"page"},{"location":"GaAs/#Step-5:-Postprocessing","page":"van Roosbroeck system","title":"Step 5: Postprocessing","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"By adding the following line to the previous loop","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"current = get_current_val(ctsys, solution)","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"we have the possibility to calculate the total current.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Moreover, there are several different plotting routines, see ct_plotting.jl.","category":"page"},{"location":"GaAs/#Example-2:-Stationary-1D-problem-(nodal-doping)","page":"van Roosbroeck system","title":"Example 2: Stationary 1D problem (nodal doping)","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Now, instead of using regionwise doping it is possible to apply a nodal doping. (This is indeed also possible for other physical parameters, see the description of ParamsNodal.) For this, go to previous Step 2, where you build your parameter set and adjust the doping initialization (code snippet is from this example)","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"paramsnodal = ParamsNodal(grid, numberOfCarriers)\n\n# initialize the space dependent doping\nNDoping = 1.0e17  / cm^3; κ = 500.0\nfor icoord = 1:numberOfNodes\n    t1 = tanh( (0.1 - coord[icoord]/μm) *κ )\n    t2 = 1.0 + tanh( (coord[icoord]/μm - 0.2) * κ )\n    paramsnodal.doping[icoord] = NDoping * 0.5 * ( 1.0  +  t1  - t2 )\nend\n\ndata.paramsnodal  = paramsnodal","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/#Three-layer-PSC-device-with-graded-interfaces-and-Ohmic-contacts-(1D).","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"","category":"section"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"Simulating a three layer PSC device Ti02| MAPI | spiro-OMeTAD without mobile ions. The simulations are performed out of equilibrium, stationary and with two junctions between perovskite layer and transport layers, to which we refer as graded interfaces. Hence, a graded flux discretization with space dependent band-edge energies and density of states is tested here. The difference here is that we adjusted the order of indexing the quasi Fermi potentials.","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"The parameters are based on the default parameter set of Ionmonger (with minor adjustments), such that we can likewise compare with the software Driftfusion, see https://github.com/barnesgroupICL/Driftfusion/blob/Methods-IonMonger-Comparison/Inputfiles/IonMongerdefault_bulk.csv","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"module Ex105_PSC_gradedFlux\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot\n\n# function for grading the physical parameters\nfunction grading_parameter!(physicalParameter, coord, regionTransportLayers, regionJunctions, h, heightLayers, lengthLayers, values)\n    for ireg in regionTransportLayers\n\n        xcoord                     = lengthLayers[ireg]:lengthLayers[ireg+1]\n        physicalParameter[xcoord] .= values[ireg]\n\n    end\n\n    for ireg in regionJunctions\n\n        xcoord   = lengthLayers[ireg]:lengthLayers[ireg+1]\n        left     = lengthLayers[ireg]-3\n        junction = h[ireg]\n        right    = lengthLayers[ireg+2]-3\n\n        gradient = ( physicalParameter[right] - physicalParameter[left] ) / junction\n\n        for index in xcoord\n            physicalParameter[index] = physicalParameter[left] + (coord[index] - heightLayers[ireg-1]) * gradient\n        end\n\n    end\n\n    return physicalParameter\nend\n\nfunction main(;n = 2, Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage=:sparse)\n\n    PyPlot.close(\"all\")\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionDonor           = 1          # n doped region\n    regionJunction1       = 2\n    regionIntrinsic       = 3          # intrinsic region\n    regionJunction2       = 4\n    regionAcceptor        = 5          # p doped region\n    regions               = [regionDonor, regionJunction1, regionIntrinsic, regionJunction2, regionAcceptor]\n    regionTransportLayers = [regionDonor, regionIntrinsic, regionAcceptor]\n    regionJunctions       = [regionJunction1, regionJunction2]\n    numberOfRegions       = length(regions)\n\n    # boundary region numbers\n    bregionDonor          = 1\n    bregionAcceptor       = 2\n    bregionDJ1            = 3\n    bregionJ1I            = 4\n    bregionIJ2            = 5\n    bregionJ2A            = 6\n\n    # grid\n    h_ndoping             = 9.90e-6 * cm\n    h_junction1           = 1.0e-7  * cm\n    h_intrinsic           = 4.00e-5 * cm\n    h_junction2           = 1.0e-7  * cm\n    h_pdoping             = 1.99e-5 * cm\n    h_total               = h_ndoping + h_junction1 + h_intrinsic + h_junction2 + h_pdoping\n    h                     = [h_ndoping, h_junction1, h_intrinsic, h_junction2, h_pdoping]\n    heightLayers          = [h_ndoping,\n                             h_ndoping + h_junction1,\n                             h_ndoping + h_junction1 + h_intrinsic,\n                             h_ndoping + h_junction1 + h_intrinsic + h_junction2,\n                             h_ndoping + h_junction1 + h_intrinsic + h_junction2 + h_pdoping]\n    refinementfactor      = 2^(n-1)\n\n    coord_ndoping         = collect(range(0.0, stop = h_ndoping, length = 4 * refinementfactor))\n    length_n              = length(coord_ndoping)\n    coord_junction1       = collect(range(h_ndoping,\n                                         stop = h_ndoping + h_junction1,\n                                         length = 3 * refinementfactor))\n    coord_intrinsic       = collect(range(h_ndoping + h_junction1,\n                                         stop = (h_ndoping + h_junction1 + h_intrinsic),\n                                         length = 10 * refinementfactor))\n    coord_junction2       = collect(range(h_ndoping + h_junction1 + h_intrinsic,\n                                         stop = (h_ndoping + h_junction1 + h_intrinsic + h_junction2),\n                                         length = 3 * refinementfactor))\n    coord_pdoping         = collect(range((h_ndoping + h_junction1 + h_intrinsic + h_junction2),\n                                          stop = (h_ndoping + h_junction1 + h_intrinsic + h_junction2 + h_pdoping),\n                                          length = 4 * refinementfactor))\n\n    coord                 = glue(coord_ndoping, coord_junction1)\n    length_j1             = length(coord)\n    coord                 = glue(coord, coord_intrinsic)\n    length_i              = length(coord)\n    coord                 = glue(coord, coord_junction2)\n    length_j2             = length(coord)\n    coord                 = glue(coord, coord_pdoping)\n\n    grid                  = simplexgrid(coord)\n    numberOfNodes         = length(coord)\n    lengthLayers          = [1, length_n, length_j1, length_i, length_j2, numberOfNodes]\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm],        [heightLayers[1]], regionDonor)      # n-doped region   = 1\n    cellmask!(grid, [heightLayers[1]], [heightLayers[2]], regionJunction1)  # first junction   = 2\n    cellmask!(grid, [heightLayers[2]], [heightLayers[3]], regionIntrinsic)  # intrinsic region = 3\n    cellmask!(grid, [heightLayers[3]], [heightLayers[4]], regionJunction2)  # sec. junction    = 4\n    cellmask!(grid, [heightLayers[4]], [heightLayers[5]], regionAcceptor)   # p-doped region   = 5","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"inner interfaces","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"    bfacemask!(grid, [heightLayers[1]], [heightLayers[1]], bregionDJ1)\n    bfacemask!(grid, [heightLayers[2]], [heightLayers[2]], bregionJ1I)\n    bfacemask!(grid, [heightLayers[3]], [heightLayers[3]], bregionIJ2)\n    bfacemask!(grid, [heightLayers[4]], [heightLayers[4]], bregionJ2A)\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend=:lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin            = 2 # electron quasi Fermi potential\n    iphip            = 1 # hole quasi Fermi potential\n    numberOfCarriers = 2\n\n    # temperature\n    T                = 300.0                 *  K\n\n    # band edge energies\n    Ec_d             = -4.0                  *  eV\n    Ev_d             = -6.0                  *  eV\n\n    Ec_i             = -3.7                  *  eV\n    Ev_i             = -5.4                  *  eV\n\n    Ec_a             = -3.1                  *  eV\n    Ev_a             = -5.1                  *  eV\n\n    # these parameters at the junctions for E_\\alpha and N_\\alpha will be overwritten.\n    Ec_j1            = Ec_d;     Ec_j2     = Ec_i\n    Ev_j1            = Ev_d;     Ev_j2     = Ev_i\n\n    EC               = [Ec_d, Ec_j1, Ec_i, Ec_j2, Ec_a]\n    EV               = [Ev_d, Ev_j1, Ev_i, Ev_j2, Ev_a]\n\n    # effective densities of state\n    Nc_d             = 5.0e19                / (cm^3)\n    Nv_d             = 5.0e19                / (cm^3)\n\n    Nc_i             = 8.1e18                / (cm^3)\n    Nv_i             = 5.8e18                / (cm^3)\n\n    Nc_a             = 5.0e19                / (cm^3)\n    Nv_a             = 5.0e19                / (cm^3)\n\n    Nc_j1            = Nc_d;     Nc_j2      = Nc_i\n    Nv_j1            = Nv_d;     Nv_j2      = Nv_i\n\n    NC               = [Nc_d, Nc_j1, Nc_i, Nc_j2, Nc_a]\n    NV               = [Nv_d, Nv_j1, Nv_i, Nv_j2, Nv_a]\n\n    # mobilities\n    μn_d             = 3.89                  * (cm^2) / (V * s)\n    μp_d             = 3.89                  * (cm^2) / (V * s)\n\n    μn_i             = 6.62e1                * (cm^2) / (V * s)\n    μp_i             = 6.62e1                * (cm^2) / (V * s)\n\n    μn_a             = 3.89e-1               * (cm^2) / (V * s)\n    μp_a             = 3.89e-1               * (cm^2) / (V * s)\n\n    μn_j1            = μn_d;     μn_j2      = μn_i\n    μp_j1            = μp_d;     μp_j2      = μp_i\n\n    μn               = [μn_d, μn_j1, μn_i, μn_j2, μn_a]\n    μp               = [μp_d, μp_j1, μp_i, μp_j2, μp_a]\n\n    # relative dielectric permittivity\n    ε_d              = 10.0                  *  1.0\n    ε_i              = 24.1                  *  1.0\n    ε_a              = 3.0                   *  1.0\n\n    ε_j1             = ε_d;       ε_j2      = ε_a\n\n    ε                = [ε_d, ε_j1, ε_i, ε_j2, ε_a]\n\n    # radiative recombination\n    r0_d             = 0.0e+0               * cm^3 / s\n    r0_i             = 1.0e-12              * cm^3 / s\n    r0_a             = 0.0e+0               * cm^3 / s\n\n    r0_j1            = r0_i;      r0_j2     = r0_i\n\n    r0               = [r0_d, r0_j1, r0_i, r0_j2, r0_a]\n\n    # life times and trap densities\n    τn_d             = 1.0e100              * s\n    τp_d             = 1.0e100              * s\n\n    τn_i             = 3.0e-10              * s\n    τp_i             = 3.0e-8               * s\n    τn_a             = τn_d\n    τp_a             = τp_d\n\n    τn_j1            = τn_i;     τn_j2      = τn_a\n    τp_j1            = τp_i;     τp_j2      = τp_a\n\n    τn               = [τn_d, τn_j1, τn_i, τn_j2, τn_a]\n    τp               = [τp_d, τp_j1, τp_i, τp_j2, τp_a]\n\n    # SRH trap energies (needed for calculation of trap_density! (SRH))","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"Eid             = -5.0                 * eV Eii             = -4.55                * eV Ei_a             = -4.1                 * eV","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"Eij1            = Eid;      Eij2     = Eii","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"EI               = [Eid, Eij1, Eii, Eij2, Ei_a]","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"    # reference densities\n    nτ_d             = 7.94e8             /m^3\n    pτ_d             = 7.94e8             /m^3\n\n    nτ_i             = 4.26e10            /m^3\n    pτ_i             = 3.05e10            /m^3\n    nτ_a             = nτ_d\n    pτ_a             = pτ_d\n\n    nτ_j1            = nτ_i;     nτ_j2      = nτ_a\n    pτ_j1            = pτ_i;     pτ_j2      = pτ_a\n\n    nτ               = [nτ_d, nτ_j1, nτ_i, nτ_j2, nτ_a]\n    pτ               = [pτ_d, pτ_j1, pτ_i, pτ_j2, pτ_a]\n\n    # Auger recombination\n    Auger            = 0.0\n\n    # doping (doping values are from Driftfusion)\n    Nd               = 1.03e18             / (cm^3)\n    Na               = 1.03e18             / (cm^3)\n    Ni_acceptor      = 8.32e7              / (cm^3)\n\n    # contact voltage\n    voltageAcceptor  = 1.2                 * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Stationary\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F                            .= Boltzmann\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = false,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[bregionDonor]    = OhmicContact\n    data.boundaryType[bregionAcceptor] = OhmicContact\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation            .= ScharfetterGummelGraded\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    # for region dependent parameters\n    params                                = Params(grid, numberOfCarriers)\n    # for space dependent parameters\n    paramsnodal                           = ParamsNodal(grid, numberOfCarriers)\n\n    params.temperature                    = T\n    params.UT                             = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]           = -1\n    params.chargeNumbers[iphip]           =  1\n\n    # nodal band-edge energies\n    paramsnodal.bandEdgeEnergy[iphin, :]  = grading_parameter!(paramsnodal.bandEdgeEnergy[iphin, :],\n                                                              coord, regionTransportLayers, regionJunctions, h,\n                                                              heightLayers, lengthLayers, EC)\n    paramsnodal.bandEdgeEnergy[iphip, :]  = grading_parameter!(paramsnodal.bandEdgeEnergy[iphip, :],\n                                                              coord, regionTransportLayers, regionJunctions, h,\n                                                              heightLayers, lengthLayers, EV)\n    # nodal effective density of states\n    paramsnodal.densityOfStates[iphin, :] = grading_parameter!(paramsnodal.densityOfStates[iphin, :],\n                                                              coord, regionTransportLayers, regionJunctions, h,\n                                                              heightLayers, lengthLayers, NC)\n    paramsnodal.densityOfStates[iphip, :] = grading_parameter!(paramsnodal.densityOfStates[iphip, :],\n                                                              coord, regionTransportLayers, regionJunctions, h,\n                                                              heightLayers, lengthLayers, NV)\n\n    for ireg in 1:numberOfRegions  ## region dependent data\n\n        # mobility\n        params.mobility[iphin, ireg]                    = μn[ireg]\n        params.mobility[iphip, ireg]                    = μp[ireg]\n\n        params.dielectricConstant[ireg]                 = ε[ireg] * ε0\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]    = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = nτ[ireg]\n        params.recombinationSRHTrapDensity[iphip, ireg] = pτ[ireg]\n        params.recombinationAuger[iphin, ireg]          = Auger\n        params.recombinationAuger[iphip, ireg]          = Auger\n\n    end\n\n    # doping\n    params.doping[iphin, regionDonor]      = Nd\n    params.doping[iphip, regionIntrinsic]  = Ni_acceptor\n    params.doping[iphip, regionAcceptor]   = Na\n\n    data.params                            = params\n    data.paramsnodal                       = paramsnodal\n    ctsys                                  = System(grid, data, unknown_storage=unknown_storage)\n\n    # print data\n    if test == false\n        show_params(ctsys)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control              = SolverControl()\n    control.verbose      = verbose\n    control.maxiters     = 200\n    control.abstol       = 1.0e-13\n    control.reltol       = 1.0e-13\n    control.tol_round    = 1.0e-13\n    control.damp_initial = 0.5\n    control.damp_growth  = 1.61 # >= 1\n    control.max_round    = 5\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival   = solution\n\n    if plotting\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        Plotter.figure()\n        plot_energies(Plotter,  ctsys, solution, \"Equilibrium\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"Equilibrium\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter,  ctsys, solution, \"Equilibrium\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################\n\n    maxBias    = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    biasValues = range(0, stop = maxBias, length = 13)\n\n    for Δu in biasValues\n        if test == false\n            println(\"Bias value: Δu = $(Δu) V\")\n        end\n\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        solution = solve(ctsys, inival = inival, control = control)\n        inival   = solution\n\n    end # bias loop\n\n    # plotting\n    if plotting\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"Applied voltage Δu = $maxBias\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"Applied voltage Δu = $maxBias\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"Applied voltage Δu = $maxBias\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = solution[data.index_psi, 20]\n    return testval\n\nend #  main\n\nfunction test()\n    testval = -3.982748467515117\n    main(test = true, unknown_storage=:dense) ≈ testval && main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Ex107_MoS2_withIons_BarrierLowering/#MoS2-with-moving-defects-and-Schottky-Barrier-Lowering.","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"","category":"section"},{"location":"examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"(source code)","category":"page"},{"location":"examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"Memristor simulation with additional moving positively charged defects and Schottky barrier lowering at the contacts.","category":"page"},{"location":"examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"module Ex107_MoS2_withIons_BarrierLowering\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot\n\nfunction main(;Plotter = PyPlot, plotting = false, verbose = false, test = false, barrierLowering = true)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid, regions and time mesh\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionflake  = 1\n\n    # boundary region numbers\n    bregionLeft  = 1\n    bregionRight = 2\n\n    # grid\n    h_flake      = 1.0 * μm # length of the conducting channel","category":"page"},{"location":"examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"non-uniform grid","category":"page"},{"location":"examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"    coord1       = geomspace(0.0,       h_flake/2, 5e-4 * h_flake, 2e-2 * h_flake)\n    coord2       = geomspace(h_flake/2, h_flake,   2e-2 * h_flake, 5e-4 * h_flake)\n    coord        = glue(coord1, coord2)\n\n    grid         = simplexgrid(coord)\n\n    # set region in grid\n    cellmask!(grid, [0.0], [h_flake], regionflake, tol = 1.0e-18)\n\n    if plotting\n        gridplot(grid, Plotter = Plotter)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of unknowns\n    iphin            = 1 # electron quasi Fermi potential\n    iphip            = 2 # hole quasi Fermi potential\n    iphix            = 3\n\n    numberOfCarriers = 3 # electrons, holes and ions","category":"page"},{"location":"examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"We define the physical data","category":"page"},{"location":"examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"    T                = 300.0             *  K\n    εr               = 9.0               *  1.0                   # relative dielectric permittivity\n    εi               = 1.0 * εr                                   # image force dielectric permittivity\n\n    Ec               = - 4.0             *  eV\n    Ev               = - 5.3             *  eV\n    Ex               = - 4.38            *  eV\n\n    Nc               = 2 * ( 2 * pi * 0.55 * mₑ * kB * T/(Planck_constant^2) )^(3/2) /m^3\n    Nv               = 2 * ( 2 * pi * 0.71 * mₑ * kB * T/(Planck_constant^2) )^(3/2) /m^3\n    Nx               = 1.0e28               / (m^3)\n\n    μn               = 1e-4                * (m^2) / (V * s)\n    μp               = 1e-4                * (m^2) / (V * s)\n    μx               = 0.8e-13             * (m^2) / (V * s)\n\n    # Schottky contact\n    barrierLeft      = 0.225                *  eV\n    barrierRight     = 0.215                *  eV\n    An               = 4 * pi * q * 0.55 * mₑ * kB^2 / Planck_constant^3\n    Ap               = 4 * pi * q * 0.71 * mₑ * kB^2 / Planck_constant^3\n    vn               = An * T^2 / (q*Nc)\n    vp               = Ap * T^2 / (q*Nv)\n\n    Nd               = 1.0e17               / (m^3) # doping\n\n    Area             = 2.1e-11 *  m^2                # Area of electrode","category":"page"},{"location":"examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"Scan protocol information","category":"page"},{"location":"examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"    endTime          = 9.6    * s\n    amplitude        = 12.0   * V\n    scanrate         = 4*amplitude/endTime\n\n    # Define scan protocol function\n    function scanProtocol(t)\n\n        if    0.0 <= t  && t <= endTime/4\n            biasVal = 0.0 + scanrate * t\n        elseif  t >= endTime/4  && t <= 3*endTime/4\n            biasVal = amplitude .- scanrate *(t-endTime/4)\n        elseif  t >= 3*endTime/4 && t <= endTime\n            biasVal = - amplitude .+ scanrate * (t-3*endTime/4)\n        else\n            biasVal = 0.0\n        end\n\n        return biasVal\n\n    end","category":"page"},{"location":"examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"Apply zero voltage on left boundary and a linear scan protocol on right boundary","category":"page"},{"location":"examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"    contactVoltageFunction = [zeroVoltage, scanProtocol]\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n     if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    data                            = Data(grid, numberOfCarriers, contactVoltageFunction = contactVoltageFunction)\n    data.modelType                  = Transient\n    data.F                          = [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n    data.bulkRecombination          = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                              bulk_recomb_Auger = false,\n                                                              bulk_recomb_radiative = false,\n                                                              bulk_recomb_SRH = false)\n    if barrierLowering\n        data.boundaryType[bregionLeft]  = SchottkyBarrierLowering\n        data.boundaryType[bregionRight] = SchottkyBarrierLowering\n    else\n        data.boundaryType[bregionLeft]  = SchottkyContact\n        data.boundaryType[bregionRight] = SchottkyContact\n    end\n\n    data.fluxApproximation         .= ExcessChemicalPotential\n\n    enable_ionic_carrier!(data, ionicCarrier = iphix, regions = [regionflake])\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                        = Params(grid, numberOfCarriers)\n\n    params.temperature                            = T\n    params.UT                                     = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                   = -1\n    params.chargeNumbers[iphip]                   =  1\n    params.chargeNumbers[iphix]                   =  2\n\n    for ireg in 1:length([regionflake])           # region data\n\n        params.dielectricConstant[ireg]           = εr * ε0\n        params.dielectricConstantImageForce[ireg] = εi * ε0\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg]       = Nc\n        params.densityOfStates[iphip, ireg]       = Nv\n        params.bandEdgeEnergy[iphin, ireg]        = Ec\n        params.bandEdgeEnergy[iphip, ireg]        = Ev\n        params.mobility[iphin, ireg]              = μn\n        params.mobility[iphip, ireg]              = μp\n        params.densityOfStates[iphix, ireg]       = Nx\n        params.bandEdgeEnergy[iphix, ireg]        = Ex\n        params.mobility[iphix, ireg]              = μx\n    end\n\n    params.SchottkyBarrier[bregionLeft]           = barrierLeft\n    params.SchottkyBarrier[bregionRight]          = barrierRight\n    params.bVelocity[iphin, bregionLeft]          = vn\n    params.bVelocity[iphin, bregionRight]         = vn\n    params.bVelocity[iphip, bregionLeft]          = vp\n    params.bVelocity[iphip, bregionRight]         = vp\n\n    # interior doping\n    params.doping[iphin, regionflake]             = Nd\n\n    data.params                                   = params\n    ctsys                                         = System(grid, data, unknown_storage=:sparse)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control              = SolverControl()\n    if verbose == true\n        control.verbose  = verbose\n    else\n        control.verbose  = \"eda\" # still print the time values\n    end\n    if test == true\n        control.verbose  = false # do not show time values in testing case\n    end\n    control.damp_initial = 0.9\n    control.damp_growth  = 1.61 # >= 1\n    control.max_round    = 5\n\n    control.abstol       = 1.0e-9\n    control.reltol       = 1.0e-9\n    control.tol_round    = 1.0e-9\n\n    control.Δu_opt       = Inf\n    control.Δt           = 1.0e-4\n    control.Δt_min       = 1.0e-5\n    control.Δt_max       = 5.0e-2\n    control.Δt_grow      = 1.05\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # initialize solution and starting vectors\n    solEQ  = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 0)\n    inival  = solEQ\n\n    if plotting\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n        label_energy[1, iphix] = \"\\$E_x-q\\\\psi\\$\"; label_energy[2, iphix] = \"\\$ - q \\\\varphi_x\\$\"\n        label_density[iphix]   = \"\\$ n_x\\$\";       label_solution[iphix]  = \"\\$ \\\\varphi_x\\$\"\n\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solEQ,\"Equilibrium\", label_density)\n        Plotter.legend()\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solEQ, \"Equilibrium\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n     if test == false\n        println(\"IV Measurement loop\")\n    end\n    ################################################################################\n\n    sol = solve(ctsys, inival = inival, times=(0.0, endTime), control = control)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    #########  IV curve calculation\n    ################################################################################\n\n    IV            = zeros(0) # for saving I-V data\n\n    tvalues       = sol.t\n    number_tsteps = length(tvalues)\n    biasValues    = scanProtocol.(tvalues)\n\n    factory       = TestFunctionFactory(ctsys)\n    tf            = testfunction(factory, [bregionLeft], [bregionRight])\n\n    push!(IV, 0.0)\n    for istep = 2:number_tsteps\n        Δt       = tvalues[istep] - tvalues[istep-1] # Time step size\n        inival   = sol[istep-1]\n        solution = sol[istep]\n\n        I        = integrate(ctsys, tf, solution, inival, Δt)\n\n        current = 0.0\n        for ii = 1:numberOfCarriers+1\n            current = current + I[ii]\n        end\n\n        push!(IV, current)\n\n    end\n\n    if plotting\n        Plotter.figure()\n        Plotter.plot(tvalues, biasValues, marker = \"x\")\n        Plotter.xlabel(\"time [s]\")\n        Plotter.ylabel(\"voltage [V]\")\n        Plotter.grid()\n\n        Plotter.figure()\n        Plotter.semilogy(biasValues, abs.(Area .* IV), linewidth = 5, color = \"black\")\n        Plotter.grid()\n        Plotter.xlabel(\"applied bias [V]\")\n        Plotter.ylabel(\"total current [A]\")\n    end\n\n\n    testval = sum(filter(!isnan, solEQ))/length(solEQ)\n    return testval\n\nend #  main\n\nfunction test()\n   main(test = true, barrierLowering = true) ≈ -1692.2303837883194\nend\n\n\nend # module","category":"page"},{"location":"examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"","category":"page"},{"location":"examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"This page was generated using Literate.jl.","category":"page"},{"location":"general/#ChargeTransport.jl-–-Simulating-charge-transport-in-semiconductors","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"","category":"section"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"(Image: Build status) (Image: ) (Image: )","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"ChargeTransport.jl simulates charge transport in semiconductors. To this end, it discretizes the semiconductor drift-diffusion equations via the Voronoi finite volume method as implemented in VoronoiFVM.jl.","category":"page"},{"location":"general/#Special-features","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"Special features","text":"","category":"section"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"heterostructures\n1D, 2D and 3D simulations\nstationary and transient simulations\nIV curves and scan protocols\nan arbitrary amount of charge carriers (electrons, heavy holes, light holes, ions, ...)\nthermodynamically consistent, physics preserving numerical methods\ndifferent charge carrier statistics per species (Boltzmann, Blakemore, Fermi-Dirac)\nAuger, radiative, Shockley-Read-Hall recombination including transient traps\nuniform and Beer-Lambert generation","category":"page"},{"location":"general/#Installation-and-first-steps","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"Installation and first steps","text":"","category":"section"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"The installation can easily be done via the Julia REPL with the following commands","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"julia> using Pkg\njulia> Pkg.add(\"ChargeTransport\")","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"We recommend to have a look at the example files:","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"Pages = [\n    \"GaAs.md\",\n    \"PSC.md\",\n    ]\nDepth = 2","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"You can load an example as follows","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"julia> include(\"Ex103_PSC.jl\")\njulia> Ex103_PSC.main()\njulia> Ex103_PSC.main(plotting = true) # show plots","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"Since the examples are encapsulated into modules, you can load as many examples as you wish. If you would like to modify one of the examples, consider using Revise.jl and includet.","category":"page"},{"location":"general/#Literature","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"Literature","text":"","category":"section"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"The simulations in the following papers are based on ChargeTransport.jl:","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"[1] D. Abdel, P. Farrell and J. Fuhrmann. Assessing the quality of the excess chemical potential flux scheme for degenerate semiconductor device simulation. Optical and Quantum Electronics 53 (163) (2021).","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"[2] D. Abdel, P. Vágner, J. Fuhrmann and P. Farrell. Modelling charge transport in perovskite solar cells: Potential-based and limiting ion depletion. Electrochimica Acta 390 (2021).","category":"page"},{"location":"","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"},{"location":"nbhtml/PSC_example/#PSC_example","page":"PSC example","title":"PSC_example.jl","text":"","category":"section"},{"location":"nbhtml/PSC_example/","page":"PSC example","title":"PSC example","text":"Download this Pluto.jl notebook.","category":"page"},{"location":"nbhtml/PSC_example/","page":"PSC example","title":"PSC example","text":"<iframe style=\"height:20000px\" width=\"100%\" src=\"../PSC_example.html\"> </iframe>","category":"page"}]
}
