var documenterSearchIndex = {"docs":
[{"location":"GeneralInformation/#generalDescription","page":"Code overview","title":"Code overview","text":"","category":"section"},{"location":"GeneralInformation/","page":"Code overview","title":"Code overview","text":"The following flow chart explains what needs to be defined when designing new examples. The important information is stored in the Data struct with the most important components listed here.","category":"page"},{"location":"GeneralInformation/","page":"Code overview","title":"Code overview","text":"(Image: Code Structure)","category":"page"},{"location":"examples/Grid_3D/#Example-code-for-a-3D-grid.","page":"Example code for a 3D grid.","title":"Example code for a 3D grid.","text":"","category":"section"},{"location":"examples/Grid_3D/","page":"Example code for a 3D grid.","title":"Example code for a 3D grid.","text":"(source code)","category":"page"},{"location":"examples/Grid_3D/","page":"Example code for a 3D grid.","title":"Example code for a 3D grid.","text":"This code provides an unstructured grid for a three-dimensional domain with an additional hole within the the device. The grid is produced with TetGen.jl.","category":"page"},{"location":"examples/Grid_3D/","page":"Example code for a 3D grid.","title":"Example code for a 3D grid.","text":"module Grid_3D\n\nusing ExtendableGrids\nusing GridVisualize\n\n# For using this example, one additionally needs to add TetGen. SimplexGridFactory is a wrapper for using this meshgenerator.\n#using SimplexGridFactory\n#using TetGen\n#using GLMakie\n\nfunction main(;Plotter = nothing, plotting = true) # plotting is currently only tested with GLMakie and PyPlot\n\n    cm       = 0.01\n    builder3d=let\n\n        b=SimplexGridBuilder(Generator=TetGen)\n\n        # region numbers\n        regionDonor      = 1                           # n doped region\n        regionIntrinsic  = 2                           # intrinsic region\n        regionAcceptor   = 3                           # p doped region\n\n        # boundary region numbers\n        bregionDonor     = 1\n        bregionAcceptor  = 2\n        bregionJunction1 = 3\n        bregionJunction2 = 4\n        bregionNoFlux    = 5\n\n        # grid\n        h_ndoping        = 9.90e-6 * cm\n        h_intrinsic      = 4.00e-5 * cm + 2.0e-7 * cm\n        h_pdoping        = 1.99e-5 * cm\n        height           = 3.00e-5 * cm\n        width            = 3.00e-5 * cm\n\n        # lower area (nregion)\n        Area1length_0    = point!(b, 0.0, 0.0, 0.0)\n        Area1length_n    = point!(b, h_ndoping, 0.0, 0.0)\n        Area1width_n     = point!(b, h_ndoping, width, 0)\n        Area1width_0     = point!(b, 0, width, 0)\n\n        # upper area (nregion)\n        Area2length_0    = point!(b, 0.0, 0.0, height)\n        Area2length_n    = point!(b, h_ndoping, 0.0, height)\n        Area2height_n    = point!(b, h_ndoping, width, height)\n        Area2height_0    = point!(b, 0, width, height)\n\n        # lower area (iregion)\n        Area1length_ni   = point!(b, h_ndoping + h_intrinsic, 0.0, 0.0)\n        Area1width_ni    = point!(b, h_ndoping + h_intrinsic, width, 0)\n        # upper area (iregion)\n        Area2length_ni   = point!(b, h_ndoping + h_intrinsic, 0.0, height)\n        Area2height_ni   = point!(b, h_ndoping + h_intrinsic, width, height)\n\n        # lower area (pregion)\n        Area1length_nip  = point!(b, h_ndoping + h_intrinsic + h_pdoping, 0.0, 0.0)\n        Area1width_nip   = point!(b, h_ndoping + h_intrinsic + h_pdoping, width, 0)\n        # upper area (pregion)\n        Area2length_nip  = point!(b, h_ndoping + h_intrinsic + h_pdoping, 0.0, height)\n        Area2height_nip  = point!(b, h_ndoping + h_intrinsic + h_pdoping, width, height)\n\n        # n-region\n        facetregion!(b, bregionNoFlux) # surface below\n        facet!(b,Area1length_0 ,Area1length_n ,Area1width_n ,Area1width_0)\n        facetregion!(b, bregionNoFlux) # surface up\n        facet!(b,Area2length_0 ,Area2length_n ,Area2height_n ,Area2height_0)\n        facetregion!(b, bregionNoFlux) # surface front\n        facet!(b,Area1length_0 ,Area1length_n ,Area2length_n ,Area2length_0)\n        facetregion!(b, bregionNoFlux) # surface back\n        facet!(b,Area1width_n ,Area1width_0 ,Area2height_0 ,Area2height_n)\n\n        # i-region\n        facetregion!(b, bregionNoFlux) # surface below\n        facet!(b,Area1length_n ,Area1length_ni ,Area1width_ni ,Area1width_n)\n        facetregion!(b, bregionNoFlux) # surface up\n        facet!(b,Area2length_n ,Area2length_ni ,Area2height_ni ,Area2height_n)\n        facetregion!(b, bregionNoFlux) # surface front\n        facet!(b,Area1length_n ,Area1length_ni ,Area2length_ni ,Area2length_n)\n        facetregion!(b, bregionNoFlux) # surface back\n        facet!(b,Area1width_ni ,Area1width_n ,Area2height_n ,Area2height_ni)\n\n        # p-region\n        facetregion!(b, bregionNoFlux) # untere Oberfläche\n        facet!(b,Area1length_ni ,Area1length_nip ,Area1width_nip ,Area1width_ni)\n        facetregion!(b, bregionNoFlux) # surface up\n        facet!(b,Area2length_ni ,Area2length_nip ,Area2height_nip ,Area2height_ni)\n        facetregion!(b, bregionNoFlux) # surface front\n        facet!(b,Area1length_ni ,Area1length_nip ,Area2length_nip ,Area2length_ni)\n        facetregion!(b, bregionNoFlux) # surface back\n        facet!(b,Area1width_nip ,Area1width_ni ,Area2height_ni ,Area2height_nip)\n\n        # inner interfaces\n        facetregion!(b,bregionJunction1) # inner interface n/i\n        facet!(b,Area1length_n ,Area1width_n ,Area2height_n ,Area2length_n)\n        facetregion!(b,bregionJunction2) # inner interface i/n\n        facet!(b,Area1length_ni ,Area1width_ni ,Area2height_ni ,Area2length_ni)\n\n        facetregion!(b,bregionDonor) # metalinterface left\n        facet!(b,Area1width_0 ,Area1length_0 ,Area2length_0 ,Area2height_0)\n        facetregion!(b,bregionAcceptor) # metalinterface right\n        facet!(b,Area1width_nip ,Area1length_nip ,Area2length_nip ,Area2height_nip)\n\n        distance = 8.0e-6*cm\n\n        hp1=point!(b,h_ndoping + h_intrinsic/2 - distance ,width/2 - distance, height/2 - distance)\n        hp2=point!(b,h_ndoping + h_intrinsic/2 + distance ,width/2 - distance, height/2 - distance)\n        hp3=point!(b,h_ndoping + h_intrinsic/2 + distance ,width/2 + distance, height/2 - distance)\n        hp4=point!(b,h_ndoping + h_intrinsic/2 - distance, width/2 + distance, height/2 - distance)\n        hp5=point!(b,h_ndoping + h_intrinsic/2 - distance, width/2 - distance, height/2 + distance)\n        hp6=point!(b,h_ndoping + h_intrinsic/2 + distance, width/2 - distance, height/2 + distance)\n        hp7=point!(b,h_ndoping + h_intrinsic/2 + distance, width/2 + distance, height/2 + distance)\n        hp8=point!(b,h_ndoping + h_intrinsic/2 - distance, width/2 + distance, height/2 + distance)\n\n        facetregion!(b,6)\n        facet!(b, hp1, hp2, hp3, hp4)\n        facet!(b, hp5, hp6, hp7, hp8)\n        facet!(b, hp1, hp2, hp6, hp5)\n        facet!(b, hp2, hp3, hp7, hp6)\n        facet!(b, hp3, hp4, hp8, hp7)\n        facet!(b, hp4, hp1, hp5, hp8)\n        holepoint!(b, h_ndoping + h_intrinsic/2, width/2, height/2)\n\n        cellregion!(b, regionDonor)\n        regionpoint!(b, h_ndoping-2.0e-6*cm, width/2-2.0e-6*cm, height/2-2.0e-6*cm)\n        cellregion!(b, regionIntrinsic)\n        regionpoint!(b, h_ndoping+h_intrinsic-6.0e-6*cm, width/2-6.0e-6*cm, height/2-6.0e-6*cm)\n        cellregion!(b, regionAcceptor)\n        regionpoint!(b, h_ndoping+h_intrinsic+h_pdoping-6.0e-6*cm, width/2-6.0e-6*cm, height/2-6.0e-6*cm)\n\n        options!(b, maxvolume=1.0e-24)\n\n        b\n\n    end;\n\n    grid = simplexgrid(builder3d)\n\n    if plotting == true # plotting is currently only tested with GLMakie and PyPlot\n        gridplot(Plotter = Plotter, grid,zplane=1.50e-7,azim=20,elev=60,linewidth=0.5, legend=:lt)\n    end\n\nend # main\n\nend # module","category":"page"},{"location":"examples/Grid_3D/","page":"Example code for a 3D grid.","title":"Example code for a 3D grid.","text":"","category":"page"},{"location":"examples/Grid_3D/","page":"Example code for a 3D grid.","title":"Example code for a 3D grid.","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/PSC_2D_unstructuredGrid/#PSC-device-on-2D-domain-(unstructured-grid).","page":"PSC device on 2D domain (unstructured grid).","title":"PSC device on 2D domain (unstructured grid).","text":"","category":"section"},{"location":"examples/PSC_2D_unstructuredGrid/","page":"PSC device on 2D domain (unstructured grid).","title":"PSC device on 2D domain (unstructured grid).","text":"(source code)","category":"page"},{"location":"examples/PSC_2D_unstructuredGrid/","page":"PSC device on 2D domain (unstructured grid).","title":"PSC device on 2D domain (unstructured grid).","text":"Simulating a three layer PSC device Pedot| MAPI | PCBM with mobile ions. The simulations are performed in 2D on an unstructured grid, out of equilibrium and with abrupt interfaces.","category":"page"},{"location":"examples/PSC_2D_unstructuredGrid/","page":"PSC device on 2D domain (unstructured grid).","title":"PSC device on 2D domain (unstructured grid).","text":"The paramters are from Calado et al.: https://github.com/barnesgroupICL/Driftfusion/blob/master/Inputfiles/pedotpssmapi_pcbm.csv. (with adjustments on layer lengths)","category":"page"},{"location":"examples/PSC_2D_unstructuredGrid/","page":"PSC device on 2D domain (unstructured grid).","title":"PSC device on 2D domain (unstructured grid).","text":"ENV[\"LC_NUMERIC\"]=\"C\" # put this in to work with Triangulate.jl, which is originally written in c++\n\nmodule PSC_2D_unstructuredGrid\n\nusing VoronoiFVM\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\n\n# For using this example one additionally needs to add Triangulate.\n# SimplexGridFactory is a wrapper for using this meshgenerator.\n# using SimplexGridFactory\n# using Triangulate\n\n# problem with linux, when including PyPlot not until the end: \"ERROR: LoadError: InitError: could not load library \"/home/abdel/.julia/artifacts/8cc532f6a1ace8d1b756fc413f4ab340195ec3c3/lib/libgio-2.0.so\"/home/abdel/.julia/artifacts/8cc532f6a1ace8d1b756fc413f4ab340195ec3c3/lib/libgobject-2.0.so.0: undefined symbol: g_uri_ref\"\n# It seems that this problem is common: https://discourse.julialang.org/t/could-not-load-library-librsvg-very-strange-error/21276\nusing PyPlot\n\nfunction main(Plotter = PyPlot, ;plotting = false, verbose = false, test = true, unknown_storage=:dense)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionAcceptor   = 1                           # p doped region\n    regionIntrinsic  = 2                           # intrinsic region\n    regionDonor      = 3                           # n doped region\n    regions          = [regionAcceptor, regionIntrinsic, regionDonor]\n    numberOfRegions  = length(regions)\n\n    # boundary region numbers\n    bregionAcceptor  = 1\n    bregionDonor     = 2\n    bregionJunction1 = 3\n    bregionJunction2 = 4\n    bregionNoFlux    = 5\n\n    # grid\n    h_pdoping        = 3.00e-6 * cm + 1.0e-7 *cm\n    h_intrinsic      = 3.00e-5 * cm\n    h_ndoping        = 8.50e-6 * cm + 1.0e-7 *cm\n    height           = 1.00e-5 * cm\n\n    b                = SimplexGridBuilder(Generator=Triangulate)\n\n    # specify boundary nodes\n    length_0         = point!(b, 0.0, 0.0)\n    length_p         = point!(b, h_pdoping, 0.0)\n    length_pi        = point!(b, h_pdoping + h_intrinsic, 0.0)\n    length_pin       = point!(b, h_pdoping + h_intrinsic + h_ndoping, 0.0)\n\n    height_0         = point!(b, 0.0, height)\n    height_p         = point!(b, h_pdoping, height)\n    height_pi        = point!(b, h_pdoping + h_intrinsic, height)\n    height_pin       = point!(b, h_pdoping + h_intrinsic + h_ndoping, height)\n\n    # specify boundary regions\n    # metal interface\n    facetregion!(b, bregionAcceptor)\n    facet!(b, length_0, height_0)\n    facetregion!(b, bregionDonor)\n    facet!(b, length_pin, height_pin)\n\n    # no flux\n    facetregion!(b, bregionNoFlux)\n    facet!(b, length_0, length_pin)\n    facetregion!(b, bregionNoFlux)\n    facet!(b, height_0, height_pin)\n\n    # inner interface\n    facetregion!(b, bregionJunction1)\n    facet!(b, length_p, height_p)\n    facetregion!(b, bregionJunction2)\n    facet!(b, length_pi, height_pi)\n\n    # cell regions\n    cellregion!(b, regionAcceptor)\n\tregionpoint!(b, h_pdoping/2, height/2)\n    cellregion!(b,regionIntrinsic)\n\tregionpoint!(b, (h_pdoping + h_intrinsic)/2, height/2)\n    cellregion!(b,regionDonor)\n\tregionpoint!(b, h_pdoping + h_intrinsic + h_ndoping/2, height/2)\n\n    options!(b,maxvolume=1.0e-16)\n\n    grid           = simplexgrid(b)\n\n    if plotting\n        GridVisualize.gridplot(grid, Plotter= Plotter, resolution=(600,400),linewidth=0.5, legend=:lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin            = 1 # electron quasi Fermi potential\n    iphip            = 2 # hole quasi Fermi potential\n    iphia            = 3 # anion vacancy quasi Fermi potential\n    numberOfCarriers = 3 # electrons, holes and anion vacancies\n\n    # temperature\n    T                = 300.0                 *  K\n\n    # band edge energies\n    Ec_a             = -3.0                  *  eV\n    Ev_a             = -5.1                  *  eV\n\n    Ec_i             = -3.8                  *  eV\n    Ev_i             = -5.4                  *  eV\n\n    Ec_d             = -3.8                  *  eV\n    Ev_d             = -6.2                  *  eV\n\n    EC               = [Ec_a, Ec_i, Ec_d]\n    EV               = [Ev_a, Ev_i, Ev_d]\n\n    # effective densities of state\n    Nc_a             = 1.0e20                / (cm^3)\n    Nv_a             = 1.0e20                / (cm^3)\n\n    Nc_i             = 1.0e19                / (cm^3)\n    Nv_i             = 1.0e19                / (cm^3)\n\n    # ###################### adjust Na, Ea here #####################\n    Nanion           = 1.0e18                / (cm^3)\n    Ea_i             = -4.4                  *  eV\n    # for the labels in the figures\n    textEa           = Ea_i./eV\n    textNa           = Nanion.*cm^3\n    # ###################### adjust Na, Ea here #####################\n    EA               = [0.0,  Ea_i,  0.0]\n\n    Nc_d             = 1.0e19                / (cm^3)\n    Nv_d             = 1.0e19                / (cm^3)\n\n    NC               = [Nc_a, Nc_i, Nc_d]\n    NV               = [Nv_a, Nv_i, Nv_d]\n    NAnion           = [0.0,  Nanion, 0.0]\n\n    # mobilities\n    μn_a             = 0.1                   * (cm^2) / (V * s)\n    μp_a             = 0.1                   * (cm^2) / (V * s)\n\n    μn_i             = 2.00e1                * (cm^2) / (V * s)\n    μp_i             = 2.00e1                * (cm^2) / (V * s)\n    μa_i             = 1.00e-10              * (cm^2) / (V * s)\n\n    μn_d             = 1.0e-3                * (cm^2) / (V * s)\n    μp_d             = 1.0e-3                * (cm^2) / (V * s)\n\n    μn               = [μn_a, μn_i, μn_d]\n    μp               = [μp_a, μp_i, μp_d]\n    μa               = [0.0,  μa_i, 0.0 ]\n\n    # relative dielectric permittivity\n    ε_a              = 4.0                   *  1.0\n    ε_i              = 23.0                  *  1.0\n    ε_d              = 3.0                   *  1.0\n\n    ε                = [ε_a, ε_i, ε_d]\n\n    # radiative recombination\n    r0_a             = 6.3e-11               * cm^3 / s\n    r0_i             = 3.6e-12               * cm^3 / s\n    r0_d             = 6.8e-11               * cm^3 / s\n\n    r0               = [r0_a, r0_i, r0_d]\n\n    # life times and trap densities\n    τn_a             = 1.0e-6                * s\n    τp_a             = 1.0e-6                * s\n\n    τn_i             = 1.0e-7                * s\n    τp_i             = 1.0e-7                * s\n    τn_d             = τn_a\n    τp_d             = τp_a\n\n    τn               = [τn_a, τn_i, τn_d]\n    τp               = [τp_a, τp_i, τp_d]\n\n    # SRH trap energies (needed for calculation of recombinationSRHTrapDensity)\n    Ei_a             = -4.05                * eV\n    Ei_i             = -4.60                * eV\n    Ei_d             = -5.00                * eV\n\n    EI               = [Ei_a, Ei_i, Ei_d]\n\n    # doping (doping values are from Phils paper, not stated in the parameter list online)\n    Nd               = 2.089649130192123e17 / (cm^3)\n    Na               = 4.529587947185444e18 / (cm^3)\n    C0               = 1.0e18               / (cm^3)\n\n    # contact voltage\n    voltageAcceptor  = 1.0                  * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in data\n    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Transient\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA, FermiDiracMinusOne, Blakemore\n    data.F                             = [Boltzmann, Boltzmann, FermiDiracMinusOne]\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = false,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceModelNone,\n    # InterfaceModelSurfaceReco (inner boundary).\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n\n    # Present ionic vacancies in perovskite layer\n    data.enableIonicCarriers           = enable_ionic_carriers(ionic_carriers = [iphia], regions = [regionIntrinsic])\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation             = ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                              = Params(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = -1\n    params.chargeNumbers[iphip]                         =  1\n    params.chargeNumbers[iphia]                         =  1\n\n    # boundary region data\n    params.bDensityOfStates[iphin, bregionDonor]        = Nc_d\n    params.bDensityOfStates[iphip, bregionDonor]        = Nv_d\n\n    params.bDensityOfStates[iphin, bregionAcceptor]     = Nc_a\n    params.bDensityOfStates[iphip, bregionAcceptor]     = Nv_a\n\n    params.bBandEdgeEnergy[iphin, bregionDonor]         = Ec_d\n    params.bBandEdgeEnergy[iphip, bregionDonor]         = Ev_d\n\n    params.bBandEdgeEnergy[iphin, bregionAcceptor]      = Ec_a\n    params.bBandEdgeEnergy[iphip, bregionAcceptor]      = Ev_a\n\n    for ireg in 1:numberOfRegions # interior region data\n\n        params.dielectricConstant[ireg]                 = ε[ireg]\n\n        # effective DOS, band edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = NC[ireg]\n        params.densityOfStates[iphip, ireg]             = NV[ireg]\n        params.densityOfStates[iphia, ireg]             = NAnion[ireg]\n\n        params.bandEdgeEnergy[iphin, ireg]              = EC[ireg]\n        params.bandEdgeEnergy[iphip, ireg]              = EV[ireg]\n        params.bandEdgeEnergy[iphia, ireg]              = EA[ireg]\n\n        params.mobility[iphin, ireg]                    = μn[ireg]\n        params.mobility[iphip, ireg]                    = μp[ireg]\n        params.mobility[iphia, ireg]                    = μa[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]    = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = trap_density!(iphin, ireg, data, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg] = trap_density!(iphip, ireg, data, EI[ireg])\n\n    end\n\n    # interior doping\n    params.doping[iphin, regionDonor]                   = Nd\n    params.doping[iphia, regionIntrinsic]               = C0\n    params.doping[iphip, regionAcceptor]                = Na\n\n    # boundary doping\n    params.bDoping[iphip, bregionAcceptor]              = Na\n    params.bDoping[iphin, bregionDonor]                 = Nd\n\n    data.params                                         = params\n    ctsys                                               = System(grid, data, unknown_storage=unknown_storage)\n\n    # print data\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define oute boundary conditions\")\n    end\n    ################################################################################\n\n    # set zero voltage ohmic contacts for electrons and holes at all outer boundaries.\n    set_contact!(ctsys, bregionAcceptor, Δu = 0.0)\n    set_contact!(ctsys, bregionDonor,    Δu = 0.0)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Newton solver\")\n    end\n    ################################################################################\n\n    control                   = VoronoiFVM.NewtonControl()\n    control.verbose           = verbose\n    control.max_iterations    = 300\n    control.tol_absolute      = 1.0e-10\n    control.tol_relative      = 1.0e-10\n    control.handle_exceptions = true\n    control.tol_round         = 1.0e-10\n    control.max_round         = 5\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium for Boltzmann\")\n    end\n    ################################################################################\n\n    # initialize solution and starting vectors\n    initialGuess  = unknowns(ctsys)\n    solution      = unknowns(ctsys)\n\n    solution      = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)\n\n    initialGuess .= solution\n\n    if plotting # currently, plotting the solution was only tested with PyPlot.\n        ipsi = data.index_psi\n        X    = grid[Coordinates][1,:]\n        Y    = grid[Coordinates][2,:]\n\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[ipsi, :])\n        Plotter.title(\"Electrostatic potential \\$ \\\\psi \\$ in Equilibrium\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        Plotter.tight_layout()\n        ################\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[iphin,:] )\n        Plotter.title(\"quasi Fermi potential \\$ \\\\varphi_n \\$ in Equilibrium\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        Plotter.tight_layout()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"I-V Measurement Loop\")\n    end\n    ################################################################################\n\n    data.calculationType = OutOfEquilibrium\n\n    # primary data for I-V scan protocol\n    scanrate             = 0.04 * V/s\n    number_tsteps        = 41\n    endVoltage           = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    tend                 = endVoltage/scanrate\n\n    # with fixed timestep sizes we can calculate the times a priori\n    tvalues              = range(0, stop = tend, length = number_tsteps)\n\n    # for saving I-V data\n    IV                   = zeros(0) # for IV values\n    biasValues           = zeros(0) # for bias values\n\n    for istep = 2:length(tvalues)\n\n        t  = tvalues[istep]       # Actual time\n        Δu = t * scanrate         # Applied voltage\n        Δt = t - tvalues[istep-1] # Time step size\n\n        # Apply new voltage; set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: t = $(t)\")\n        end\n\n        solve!(solution, initialGuess, ctsys, control  = control, tstep = Δt)\n\n        # get I-V data\n        current = get_current_val(ctsys, solution, initialGuess, Δt)\n\n        push!(IV, current)\n        push!(biasValues, Δu)\n\n        initialGuess .= solution\n    end # time loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    if plotting\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[ipsi, :])\n        Plotter.title(\"Electrostatic potential \\$ \\\\psi \\$ at end time\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        # ################\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[iphin,:] )\n        Plotter.title(\"quasi Fermi potential \\$ \\\\varphi_n \\$ at end time\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        # ################\n        Plotter.figure()\n        Plotter.plot(biasValues, IV.*(cm)^2/height, label = \"\\$ E_a =\\$$(textEa)eV;  \\$ N_a =\\$ $textNa\\$\\\\mathrm{cm}^{⁻3}\\$ (without internal BC)\",  linewidth= 3, linestyle=\"--\", color=\"red\")\n        Plotter.title(\"Forward; \\$ E_a =\\$$(textEa)eV;  \\$ N_a =\\$ $textNa\\$\\\\mathrm{cm}^{⁻3}\\$ \")\n        Plotter.ylabel(\"total current [A]\") #\n        Plotter.xlabel(\"Applied Voltage [V]\")\n    end\n\n    testval = solution[data.index_psi, 42]\n    return testval\n\nend #  main\n\nfunction test()\n    testval = -4.068873400363849\n    main(test = true, unknown_storage=:dense) ≈ testval #&& main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/PSC_2D_unstructuredGrid/","page":"PSC device on 2D domain (unstructured grid).","title":"PSC device on 2D domain (unstructured grid).","text":"","category":"page"},{"location":"examples/PSC_2D_unstructuredGrid/","page":"PSC device on 2D domain (unstructured grid).","title":"PSC device on 2D domain (unstructured grid).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Ex108_PSC_uniform_Generation/#PSC-device-with-uniform-generation-rate-(1D).","page":"PSC device with uniform generation rate (1D).","title":"PSC device with uniform generation rate (1D).","text":"","category":"section"},{"location":"examples/Ex108_PSC_uniform_Generation/","page":"PSC device with uniform generation rate (1D).","title":"PSC device with uniform generation rate (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex108_PSC_uniform_Generation/","page":"PSC device with uniform generation rate (1D).","title":"PSC device with uniform generation rate (1D).","text":"Simulating a three layer PSC device Pedot| MAPI | PCBM. The simulations are performed out of equilibrium, time-dependent, with abrupt interfaces and with a uniform generation. A linear I-V measurement protocol is included and the corresponding solution vectors after the scan protocol can be depicted.","category":"page"},{"location":"examples/Ex108_PSC_uniform_Generation/","page":"PSC device with uniform generation rate (1D).","title":"PSC device with uniform generation rate (1D).","text":"The paramters are from Calado et al.: https://github.com/barnesgroupICL/Driftfusion/blob/master/Inputfiles/pedotpssmapi_pcbm.csv. (with adjustments on layer lengths)","category":"page"},{"location":"examples/Ex108_PSC_uniform_Generation/","page":"PSC device with uniform generation rate (1D).","title":"PSC device with uniform generation rate (1D).","text":"module Ex108_PSC_uniform_Generation\n\nusing VoronoiFVM\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing PyPlot\n\nfunction main(;n = 4, Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage=:dense)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionAcceptor  = 1                           # p doped region\n    regionIntrinsic = 2                           # intrinsic region\n    regionDonor     = 3                           # n doped region\n    regions         = [regionAcceptor, regionIntrinsic, regionDonor]\n    numberOfRegions = length(regions)\n\n    # boundary region numbers\n    bregionAcceptor = 1\n    bregionDonor    = 2\n\n    # grid\n    h_pdoping       = 3.00e-6 * cm + 1.0e-7 *cm # add 1.e-7 cm to this layer for agreement with grid of Driftfusion\n    h_intrinsic     = 3.00e-5 * cm\n    h_ndoping       = 8.50e-6 * cm + 1.0e-7 *cm # add 1.e-7 cm to this layer for agreement with grid of Driftfusion\n\n    x0              = 0.0 * cm\n    δ               = 4*n        # the larger, the finer the mesh\n    t               = 0.5*(cm)/δ # tolerance for geomspace and glue (with factor 10)\n    k               = 1.5        # the closer to 1, the closer to the boundary geomspace works\n\n    coord_p_u       = collect(range(x0, h_pdoping/2, step=h_pdoping/(0.6*δ)))\n    coord_p_g       = geomspace(h_pdoping/2,\n                                h_pdoping,\n                                h_pdoping/(0.8*δ),\n                                h_pdoping/(0.6*δ),\n                                tol=t)\n    coord_i_g1      = geomspace(h_pdoping,\n                                h_pdoping+h_intrinsic/k,\n                                h_intrinsic/(6.1*δ),\n                                h_intrinsic/(2.1*δ),\n                                tol=t)\n    coord_i_g2      = geomspace(h_pdoping+h_intrinsic/k,\n                                h_pdoping+h_intrinsic,\n                                h_intrinsic/(2.1*δ),\n                                h_intrinsic/(6.1*δ),\n                                tol=t)\n    coord_n_g       = geomspace(h_pdoping+h_intrinsic,\n                                h_pdoping+h_intrinsic+h_ndoping/2,\n                                h_ndoping/(1.5*δ),\n                                h_ndoping/(0.9*δ),\n                                tol=t)\n    coord_n_u       = collect(range(h_pdoping+h_intrinsic+h_ndoping/2, h_pdoping+h_intrinsic+h_ndoping, step=h_pdoping/(0.5*δ)))\n\n    coord           = glue(coord_p_u, coord_p_g,  tol=10*t)\n    coord           = glue(coord,     coord_i_g1, tol=10*t)\n    coord           = glue(coord,     coord_i_g2, tol=10*t)\n    coord           = glue(coord,     coord_n_g,  tol=10*t)\n    coord          = glue(coord,     coord_n_u,  tol=10*t)\n    grid           = simplexgrid(coord)\n\n    # set different regions in grid, doping profiles do not intersect\n    cellmask!(grid, [0.0 * μm],                [h_pdoping],                           regionAcceptor, tol = 1.0e-18)  # n-doped region   = 1\n    cellmask!(grid, [h_pdoping],               [h_pdoping + h_intrinsic],             regionIntrinsic, tol = 1.0e-18) # intrinsic region = 2\n    cellmask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic + h_ndoping], regionDonor, tol = 1.0e-18)     # p-doped region   = 3\n\n    if plotting\n        gridplot(grid, Plotter = Plotter)\n        Plotter.title(\"Grid\")\n        Plotter.figure()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin              = 1 # electron quasi Fermi potential\n    iphip              = 2 # hole quasi Fermi potential\n    iphia              = 3 # anion vacancy quasi Fermi potential\n    numberOfCarriers   = 3 # electrons, holes and anion vacancies\n\n    # temperature\n    T                  =  300.0                 *  K\n\n    # band edge energies\n    Ec_a               = -3.0                  *  eV\n    Ev_a               = -5.1                  *  eV\n\n    Ec_i               = -3.8                  *  eV\n    Ev_i               = -5.4                  *  eV\n\n    Ec_d               = -3.8                  *  eV\n    Ev_d               = -6.2                  *  eV\n\n    EC                 = [Ec_a, Ec_i, Ec_d]\n    EV                 = [Ev_a, Ev_i, Ev_d]\n\n    # effective densities of state\n    Nc_a               = 1.0e20                / (cm^3)\n    Nv_a               = 1.0e20                / (cm^3)\n\n    Nc_i               = 1.0e19                / (cm^3)\n    Nv_i               = 1.0e19                / (cm^3)\n\n    # ############ adjust Na, Ea for anion vacancies here ###########\n    Nanion             = 1.21e22                / (cm^3)\n    Ea_i               = -5.175                 *  eV\n    # for the labels in the figures\n    textEa             = Ea_i./eV\n    textNa             = Nanion.*cm^3\n    # ############ adjust Na, Ea for anion vacancies here ###########\n\n    EA                 = [0.0,  Ea_i,  0.0]\n\n    Nc_d               = 1.0e19                 / (cm^3)\n    Nv_d               = 1.0e19                 / (cm^3)\n\n    NC                 = [Nc_a, Nc_i, Nc_d]\n    NV                 = [Nv_a, Nv_i, Nv_d]\n    NAnion             = [0.0,  Nanion, 0.0]\n\n    # mobilities\n    μn_a               = 0.1                    * (cm^2) / (V * s)\n    μp_a               = 0.1                    * (cm^2) / (V * s)\n\n    μn_i               = 2.00e1                 * (cm^2) / (V * s)\n    μp_i               = 2.00e1                 * (cm^2) / (V * s)\n    μa_i               = 1.00e-10               * (cm^2) / (V * s)\n\n    μn_d               = 1.0e-3                 * (cm^2) / (V * s)\n    μp_d               = 1.0e-3                 * (cm^2) / (V * s)\n\n    μn                 = [μn_a, μn_i, μn_d]\n    μp                 = [μp_a, μp_i, μp_d]\n    μa                 = [0.0,  μa_i, 0.0 ]\n\n    # relative dielectric permittivity\n    ε_a                = 4.0                    *  1.0\n    ε_i                = 23.0                   *  1.0\n    ε_d                = 3.0                    *  1.0\n\n    ε                  = [ε_a, ε_i, ε_d]\n\n    # radiative recombination\n    r0_a               = 6.3e-11                * cm^3 / s\n    r0_i               = 3.6e-12                * cm^3 / s\n    r0_d               = 6.8e-11                * cm^3 / s\n\n    r0                 = [r0_a, r0_i, r0_d]\n\n    # life times and trap densities\n    τn_a               = 1.0e-6                 * s\n    τp_a               = 1.0e-6                 * s\n\n    τn_i               = 1.0e-7                 * s\n    τp_i               = 1.0e-7                 * s\n    τn_d               = τn_a\n    τp_d               = τp_a\n\n    τn                 = [τn_a, τn_i, τn_d]\n    τp                 = [τp_a, τp_i, τp_d]\n\n    # SRH trap energies\n    Ei_a               = -4.05                 * eV\n    Ei_i               = -4.60                 * eV\n    Ei_d               = -5.00                 * eV\n\n    EI                 = [Ei_a, Ei_i, Ei_d]\n\n    # Auger recombination\n    Auger              = 0.0\n\n    # generation\n    generation_a       = 0.0\n    generation_i       = 2.64e21               / (cm^3 * s)\n    generation_d       = 0.0\n\n    generation_uniform = [generation_a, generation_i, generation_d]\n\n    # doping\n    Nd                 = 2.089649130192123e17  / (cm^3)\n    Na                 = 4.529587947185444e18  / (cm^3)\n    C0                 = 1.0e18                / (cm^3)\n\n    # contact voltage\n    voltageAcceptor    = 1.1                   * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Transient\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F                             = [Boltzmann, Boltzmann, FermiDiracMinusOne]\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = true,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Possible choices: GenerationNone, GenerationUniform\n    data.generationModel               = GenerationUniform\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceModelNone,\n    # InterfaceModelSurfaceReco (inner boundary).\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n\n    # Present ionic vacancies in perovskite layer\n    data.enableIonicCarriers           = enable_ionic_carriers(ionic_carriers = [iphia], regions = [regionIntrinsic])\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation             = ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                              = Params(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = -1\n    params.chargeNumbers[iphip]                         =  1\n    params.chargeNumbers[iphia]                         =  1\n\n    # boundary region data\n    params.bDensityOfStates[iphin, bregionDonor]        = Nc_d\n    params.bDensityOfStates[iphip, bregionDonor]        = Nv_d\n\n    params.bDensityOfStates[iphin, bregionAcceptor]     = Nc_a\n    params.bDensityOfStates[iphip, bregionAcceptor]     = Nv_a\n\n    params.bBandEdgeEnergy[iphin, bregionDonor]         = Ec_d\n    params.bBandEdgeEnergy[iphip, bregionDonor]         = Ev_d\n\n    params.bBandEdgeEnergy[iphin, bregionAcceptor]      = Ec_a\n    params.bBandEdgeEnergy[iphip, bregionAcceptor]      = Ev_a\n\n\n    for ireg in 1:numberOfRegions # interior region data\n\n        params.dielectricConstant[ireg]                 = ε[ireg]\n\n        # effective DOS, band edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = NC[ireg]\n        params.densityOfStates[iphip, ireg]             = NV[ireg]\n        params.densityOfStates[iphia, ireg]             = NAnion[ireg]\n\n        params.bandEdgeEnergy[iphin, ireg]              = EC[ireg]\n        params.bandEdgeEnergy[iphip, ireg]              = EV[ireg]\n        params.bandEdgeEnergy[iphia, ireg]              = EA[ireg]\n\n        params.mobility[iphin, ireg]                    = μn[ireg]\n        params.mobility[iphip, ireg]                    = μp[ireg]\n        params.mobility[iphia, ireg]                    = μa[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]    = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = trap_density!(iphin, ireg, data, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg] = trap_density!(iphip, ireg, data, EI[ireg])\n        params.recombinationAuger[iphin, ireg]          = Auger\n        params.recombinationAuger[iphip, ireg]          = Auger\n\n        params.generationUniform[ireg]                  = generation_uniform[ireg]\n    end\n\n    # interior doping\n    params.doping[iphin, regionDonor]                   = Nd\n    params.doping[iphia, regionIntrinsic]               = C0\n    params.doping[iphip, regionAcceptor]                = Na\n\n    # boundary doping\n    params.bDoping[iphip, bregionAcceptor]              = Na\n    params.bDoping[iphin, bregionDonor]                 = Nd\n\n    data.params                                         = params\n    ctsys                                               = System(grid, data, unknown_storage=unknown_storage)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define outer boundary conditions\")\n    end\n    ################################################################################\n\n    # set zero voltage ohmic contacts for electrons and holes at all outer boundaries.\n    set_contact!(ctsys, bregionAcceptor, Δu = 0.0)\n    set_contact!(ctsys, bregionDonor,    Δu = 0.0)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Newton solver\")\n    end\n    ################################################################################\n\n    control                   = VoronoiFVM.NewtonControl()\n    control.verbose           = verbose\n    control.max_iterations    = 300\n    control.tol_absolute      = 1.0e-10\n    control.tol_relative      = 1.0e-10\n    control.handle_exceptions = true\n    control.tol_round         = 1.0e-10\n    control.max_round         = 5\n    control.damp_initial      = 0.5\n    control.damp_growth       = 1.21 # >= 1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium for Boltzmann\")\n    end\n    ################################################################################\n\n    # initialize solution and starting vectors\n    initialGuess  = unknowns(ctsys)\n    solution      = unknowns(ctsys)\n\n    solution      = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)\n\n    initialGuess .= solution\n\n    if plotting\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        # add labels for anion vacancy\n        label_energy[1, iphia] = \"\\$E_a-q\\\\psi\\$\"; label_energy[2, iphia] = \"\\$ - q \\\\varphi_a\\$\"\n        label_density[iphia]   = \"a\";              label_solution[iphia]  = \"\\$ \\\\varphi_a\\$\"\n\n        plot_energies(Plotter, grid, data, solution, \"Equilibrium; \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution,\"Equilibrium; \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, grid, data, solution, \"Equilibrium; \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Loop for putting generation on\")\n    end\n    ################################################################################\n\n    data.calculationType = OutOfEquilibrium\n\n    # primary data for I-V scan protocol\n    scanrate             = 0.04 * V/s\n    number_tsteps        = 31\n    endVoltage           = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    tend                 = endVoltage/scanrate\n\n    # with fixed timestep sizes we can calculate the times priori\n    tvalues              = range(0, stop = tend, length = number_tsteps)\n\n    # these values are needed for putting the generation slightly on\n    I      = collect(length(tvalues):-1:0.0)\n    LAMBDA = 10 .^ (-I)\n\n    for istep = 2:number_tsteps\n\n        t  = tvalues[istep]       # Actual time\n        Δu = t * scanrate         # Applied voltage\n        Δt = t - tvalues[istep-1] # Time step size\n\n        # Apply new voltage by setting non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        # turn slowly generation on\n        data.λ2   = LAMBDA[istep + 1]\n\n        if test == false\n            println(\"increase generation with λ2 = $(data.λ2)\")\n            println(\"time value: t = $(t)\")\n        end\n\n        solve!(solution, initialGuess, ctsys, control  = control, tstep = Δt)\n\n        initialGuess .= solution\n\n    end # time loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Reverse IV Scan Protocol\")\n    end\n    ################################################################################\n\n    # for saving I-V data\n    IVReverse          = zeros(0) # for IV values\n    biasValuesReverse  = zeros(0) # for bias values\n\n    for istep = number_tsteps:-1:2\n\n        t  = tvalues[istep]       # Actual time\n        Δu = t * scanrate         # Applied voltage\n        Δt = t - tvalues[istep-1] # Time step size\n\n        # Apply new voltage\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: t = $(t)\")\n        end\n\n        solve!(solution, initialGuess, ctsys, control  = control, tstep = Δt)\n\n        initialGuess .= solution\n\n        # get I-V data\n        current = get_current_val(ctsys, solution, initialGuess, Δt)\n\n        push!(IVReverse, current)\n        push!(biasValuesReverse, Δu)\n\n    end # time loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Forward IV Scan Protocol\")\n    end\n    ################################################################################\n\n    # for saving I-V data\n    IVForward          = zeros(0) # for IV values\n    biasValuesForward  = zeros(0) # for bias values\n\n    for istep = 2:number_tsteps\n\n        t  = tvalues[istep]       # Actual time\n        Δu = t * scanrate         # Applied voltage\n        Δt = t - tvalues[istep-1] # Time step size\n\n        # Apply new voltage\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: t = $(t)\")\n        end\n\n        solve!(solution, initialGuess, ctsys, control  = control, tstep = Δt)\n\n        # get I-V data\n        current = get_current_val(ctsys, solution, initialGuess, Δt)\n\n        push!(IVForward, current)\n        push!(biasValuesForward, Δu)\n\n        initialGuess .= solution\n\n\n    end # time loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ##resForward = [biasValuesForward IVForward]\n\n    if plotting\n        Plotter.figure()\n\n        plot_densities(Plotter, grid, data, solution, \"\\$ \\\\Delta u = $(biasValuesForward[end])\\$; \\$ E_a =\\$$(textEa)eV;  \\$ N_a =\\$ $textNa\\$\\\\mathrm{cm}^{⁻3}\\$\", label_density)\n        # ###############\n        Plotter.figure()\n        plot_solution(Plotter, grid, data, solution, \"\\$ \\\\Delta u = $(biasValuesForward[end])\\$; \\$ E_a =\\$$(textEa)eV;  \\$ N_a =\\$ $textNa\\$\\\\mathrm{cm}^{⁻3}\\$\", label_solution)\n        # ###############\n        Plotter.figure()\n\n        Plotter.plot(biasValuesForward, IVForward.*(cm^2), label = \"forward\",  linewidth= 3, linestyle=\"--\", color=\"red\")\n        Plotter.plot(biasValuesReverse, IVReverse.*(cm^2), label = \"reverse\",  linewidth= 3, linestyle=\"--\", color=\"blue\")\n        Plotter.legend()\n        Plotter.xlabel(\"Applied Voltage [V]\")\n        Plotter.ylabel(\"current density [A \\$ cm^{-2}\\$ ]\")\n        Plotter.title(\"\\$ E_a =\\$$(textEa)eV;  \\$ N_a =\\$ $textNa\\$\\\\mathrm{cm}^{⁻3}\\$ (without internal BC)\")\n        Plotter.tight_layout()\n    end\n\n    testval = VoronoiFVM.norm(ctsys.fvmsys, solution, 2)\n    return testval\n\nend #  main\n\nfunction test()\n    testval = 39.06872444917981\n    main(test = true, unknown_storage=:dense) ≈ testval #&& main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex108_PSC_uniform_Generation/","page":"PSC device with uniform generation rate (1D).","title":"PSC device with uniform generation rate (1D).","text":"","category":"page"},{"location":"examples/Ex108_PSC_uniform_Generation/","page":"PSC device with uniform generation rate (1D).","title":"PSC device with uniform generation rate (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Non_RectangularGrid_2D/#Example-code-for-a-2D-non-rectangular-grid.","page":"Example code for a 2D non rectangular grid.","title":"Example code for a 2D non rectangular grid.","text":"","category":"section"},{"location":"examples/Non_RectangularGrid_2D/","page":"Example code for a 2D non rectangular grid.","title":"Example code for a 2D non rectangular grid.","text":"(source code)","category":"page"},{"location":"examples/Non_RectangularGrid_2D/","page":"Example code for a 2D non rectangular grid.","title":"Example code for a 2D non rectangular grid.","text":"This code provides an unstructured grid for a non rectangular two-dimensional domain. The grid is produced with Triangulate.jl.","category":"page"},{"location":"examples/Non_RectangularGrid_2D/","page":"Example code for a 2D non rectangular grid.","title":"Example code for a 2D non rectangular grid.","text":"ENV[\"LC_NUMERIC\"]=\"C\"\n\nmodule Non_RectangularGrid_2D\n\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing PyPlot\n\n# For using this example, one additionally needs to add Triangulate. SimplexGridFactory is a wrapper for using this meshgenerator.\n# using SimplexGridFactory\n# using Triangulate\n\nfunction main(;Plotter = PyPlot, plotting = false)\n\n    # region numbers\n    regionDonor      = 1                           # n doped region\n    regionIntrinsic  = 2                           # intrinsic region\n    regionAcceptor   = 3                           # p doped region\n\n    # boundary region numbers\n    bregionDonor     = 1\n    bregionAcceptor  = 2\n    bregionJunction1 = 3\n    bregionJunction2 = 4\n    bregionNoFlux    = 5\n\n    # grid\n    h_ndoping        = 9.90e-6 * cm\n    h_intrinsic      = 4.00e-5 * cm + 2.0e-7 * cm\n    h_pdoping        = 1.99e-5 * cm\n    height           = 3.00e-5 * cm\n\n    function unsuitable(x1,y1,x2,y2,x3,y3,area)\n        bary_x=(x1+x2+x3)/3.0\n        bary_y=(y1+y2+y3)/3.0\n        dx=bary_x-refinement_center[1]\n        dy=bary_y-refinement_center[2]\n        qdist=dx^2+dy^2\n        area>0.1*max(8.0e-16,qdist)\n    end\n\n    b           = SimplexGridBuilder(Generator=Triangulate)\n\n    # specify boundary nodes\n    length_0    = point!(b, 0.0, 0.0)\n    length_n    = point!(b, h_ndoping, 0.0)\n    length_ni   = point!(b, h_ndoping + h_intrinsic, 0.0)\n    length_nip  = point!(b, h_ndoping + h_intrinsic + h_pdoping, 0.0)\n    height_0    = point!(b, 0.0, height)\n    height_n    = point!(b, h_ndoping, height)\n\n    # for L shape\n    height_ni12 = point!(b, h_ndoping + h_intrinsic/2, height)\n    height_ni2  = point!(b, h_ndoping + h_intrinsic/2, height/2)\n    height_ni   = point!(b, h_ndoping + h_intrinsic, height/2)\n    height_nip  = point!(b, h_ndoping + h_intrinsic + h_pdoping, height/2)\n\n    # specify boundary regions\n    # metal interface\n    facetregion!(b, bregionDonor)\n    facet!(b, length_0, height_0)\n    facetregion!(b, bregionAcceptor)\n    facet!(b, length_nip, height_nip)\n\n    # no flux\n    facetregion!(b, bregionNoFlux)\n    facet!(b, length_0, length_nip)\n    facetregion!(b, bregionNoFlux)\n    facet!(b, height_0, height_n)\n    facetregion!(b, bregionNoFlux)\n    facet!(b, height_0, height_ni12)\n    facetregion!(b, bregionNoFlux)\n    facet!(b, height_ni12, height_ni2)\n    facetregion!(b, bregionNoFlux)\n    facet!(b, height_ni2, height_nip)\n\n    # inner interface\n    facetregion!(b, bregionJunction1)\n    facet!(b, length_n, height_n)\n    facetregion!(b, bregionJunction2)\n    facet!(b, length_ni, height_ni)\n\n    refinement_center = [h_ndoping + h_intrinsic/2, height/2]\n    # Activate unsuitable callback\n    options!(b,unsuitable=unsuitable)\n\n    # cell regions\n    cellregion!(b, regionDonor)\n    regionpoint!(b, h_ndoping-1.0e-6*cm, height/2-1.0e-6*cm)\n    cellregion!(b,regionIntrinsic)\n    regionpoint!(b, h_ndoping + h_intrinsic -1.0e-6*cm, height/2-1.0e-6*cm)\n    cellregion!(b,regionAcceptor)\n    regionpoint!(b, h_ndoping + h_intrinsic + h_pdoping -1.0e-6*cm, height/2-1.0e-6*cm)\n\n    options!(b,maxvolume=7.0e-16)\n\n    grid = simplexgrid(b)\n\n    if plotting\n        # GridVisualize.gridplot(grid, Plotter= Plotter, resolution=(600,400),linewidth=0.6)\n        # Plotter.xlabel(\"length [m]\")\n        # Plotter.ylabel(\"height [m]\")\n        # Plotter.tight_layout()\n        builderplot(b,Plotter=Plotter,resolution=(750,700))\nend\n\nend # main\n\nend # module","category":"page"},{"location":"examples/Non_RectangularGrid_2D/","page":"Example code for a 2D non rectangular grid.","title":"Example code for a 2D non rectangular grid.","text":"","category":"page"},{"location":"examples/Non_RectangularGrid_2D/","page":"Example code for a 2D non rectangular grid.","title":"Example code for a 2D non rectangular grid.","text":"This page was generated using Literate.jl.","category":"page"},{"location":"backgroundinfo/#Mathematical-drift-diffusion-models","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"ChargeTransport.jl aims to discretize charge transport models based on drift-diffusion equations. The bipolar case is sometimes referred to as van Roosbroeck system. This nonlinear system of partial differential equations couples Poisson's equation to several continuity equations. The precise type and amount will vary with the specific application.","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"In this section, we would like to describe the mathematical theory a bit more in detail. We denote with alpha the charge carrier, with n_alpha its corresponding density in a device region mathbfOmega during a finite time interval 0 t_F.","category":"page"},{"location":"backgroundinfo/#Poisson's-equation","page":"Mathematical drift-diffusion models","title":"Poisson's equation","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Poisson's equation for the electric potential psi is given by","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"beginaligned\n- nabla cdot Bigl(varepsilon_s nabla psi(mathbfx t) Bigr) = q sum_alpha z_alpha Bigl( n_alpha(mathbfx t) - C_alpha(mathbfx) Bigr)\nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Here, varepsilon_s denotes the dielectric permittivity and $ q $ the elementary charge. The right-hand side of Poisson's equation, the space charge density, is the sum of charge carrier densities n_alpha multiplied by their respective charge numbers z_alpha and some corresponding fixed charges, the doping $ C_\\alpha $.","category":"page"},{"location":"backgroundinfo/#Continuity-equations","page":"Mathematical drift-diffusion models","title":"Continuity equations","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Poisson's equation is coupled to additional continuity equations for each charge carrier alpha, which describe the motion of free charge carriers in an electric field","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"beginaligned\nz_alpha q partial_t n_alpha +  nablacdot mathbfj_alpha\n\t=\n\tz_alpha q\tr_alpha\nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Here, the flux mathbfj_alpha refers to the the carrier's current density and r_alpha to some production/reduction rates. These rates may be chosen to represent different recombination or generation models such as Shockley-Read-Hall, Auger or direct recombination.","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"The amount and type of charge carriers will be dependent on the specific application. The standard semiconductor equations use electrons alpha=n and holes alpha=p.","category":"page"},{"location":"backgroundinfo/#Drift-diffusion-fluxes","page":"Mathematical drift-diffusion models","title":"Drift-diffusion fluxes","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Our code uses as independent variables the electrostatic potential psi as well as the quasi Fermi potentials varphi_alpha. The charge carrier densities n_alpha are linked to the corresponding quasi Fermi potentials via the state equations","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"beginaligned\nn_alpha = N_alpha mathcalF_alpha Bigl(eta_alpha(psi varphi_alpha) Bigr) quad eta_alpha = z_alpha fracq (varphi_alpha - psi) + E_alphak_B T\nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"where the physical parameters are defined in the list of notations. With this definition we can formulate the carrier current given by","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"beginaligned\n    mathbfj_alpha\n\t=\n    - (z_alpha)^2 q mu_alpha\n    n_alpha\n    nablavarphi_alpha\n    \nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"with the negative gradients of the quasi Fermi potentials as driving forces. Using the state equations one may rewrite these fluxes in a drift-diffusion form.","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"note: Note\nThe unknowns in ChargeTransport.jl are always defined as the quasi Fermi potentials $ \\varphi_\\alpha$ and the electric potential psi.","category":"page"},{"location":"backgroundinfo/#Background-literature","page":"Mathematical drift-diffusion models","title":"Background literature","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"For a comprehensive overview of drift-diffusion models, semiconductor applications as well as the underlying numerical methods, we recommend the following sources:","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"P. Farrell, D. H. Doan, M. Kantner, J. Fuhrmann, T. Koprucki, and N. Rotundo. “Drift-Diffusion Models”. In: Optoelectronic Device Modeling and Simulation: Fundamentals, Materials, Nanostructures, LEDs, and Amplifiers. CRC Press Taylor & Francis Group, 2017, pp. 733–771.\nS. Selberherr. Analysis and Simulation of Semiconductor Devices. Springer-Verlag, 1984.\nS. M. Sze and K. K. Ng. Physics of Semiconductor Devices. Wiley, 2006.","category":"page"},{"location":"backgroundinfo/#notation","page":"Mathematical drift-diffusion models","title":"Notation","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"symbol physical quantity     symbol physical quantity\n$ \\alpha $ mobile charge carrier     $ n_\\alpha $ charge carrier density of $ \\alpha $\nvarepsilon_s dielectric permittivity     $ \\psi $ electrostatic potential\n$ q $ elementary charge     $ C_\\alpha $ doping/background charge\n$ z_\\alpha $ charge number for $ \\alpha $     $ r_\\alpha $ production/reaction rate for $ \\alpha $\n$ N_\\alpha $ effective density of states for $ \\alpha $     $ \\mathcal{F}_\\alpha $ statistics function\n$ \\varphi_\\alpha $ quasi Fermi potential for $ \\alpha $     $ E_\\alpha $ band-edge energy for $ \\alpha $\n$ k_B $ Boltzmann constant     $ T $ temperature\n$ \\mu_\\alpha $ mobility of carrier $ \\alpha $      ","category":"page"},{"location":"allindex/#Overview-–-Constants,-Types,-Constructors-and-Methods","page":"Types, Constructors and Methods","title":"Overview – Constants, Types, Constructors and Methods","text":"","category":"section"},{"location":"allindex/#Constants,-Types-and-Constructors","page":"Types, Constructors and Methods","title":"Constants, Types and Constructors","text":"","category":"section"},{"location":"allindex/","page":"Types, Constructors and Methods","title":"Types, Constructors and Methods","text":"Modules = [ChargeTransport]\nOrder=[:constant, :type]","category":"page"},{"location":"allindex/#Methods","page":"Types, Constructors and Methods","title":"Methods","text":"","category":"section"},{"location":"allindex/","page":"Types, Constructors and Methods","title":"Types, Constructors and Methods","text":"Modules = [ChargeTransport]\nOrder=[:function]","category":"page"},{"location":"allindex/#Description-of-Constant,-Types,-Constructors-and-Methods","page":"Types, Constructors and Methods","title":"Description of Constant, Types, Constructors and Methods","text":"","category":"section"},{"location":"allindex/#Constants,-Types-and-Constructors-2","page":"Types, Constructors and Methods","title":"Constants, Types and Constructors","text":"","category":"section"},{"location":"allindex/","page":"Types, Constructors and Methods","title":"Types, Constructors and Methods","text":"Modules = [ChargeTransport]\nOrder=[:constant, :type]","category":"page"},{"location":"allindex/#ChargeTransport.BoundaryModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.BoundaryModelType","text":"Possible types of boundary models.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.CalculationType","page":"Types, Constructors and Methods","title":"ChargeTransport.CalculationType","text":"Possible types for calculation type.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.FluxApproximationType","page":"Types, Constructors and Methods","title":"ChargeTransport.FluxApproximationType","text":"Possible types of flux discretization schemes.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationModelType","text":"Possible types for generation model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InterfaceModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.InterfaceModelType","text":"Possible Types of interface model (interior boundary conditions).\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.ModelType","text":"Possible types which indicate, if we consider stationary or transient problem.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.OuterBoundaryModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.OuterBoundaryModelType","text":"Possible types of outer boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.QType","page":"Types, Constructors and Methods","title":"ChargeTransport.QType","text":"Type of charge carriers and the electric potential.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.SRHWithoutTrapsType","page":"Types, Constructors and Methods","title":"ChargeTransport.SRHWithoutTrapsType","text":"Possible type for SRH recombination without traps.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.StandardFuncSet","page":"Types, Constructors and Methods","title":"ChargeTransport.StandardFuncSet","text":"Type of statistics functions.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.BulkRecombination","page":"Types, Constructors and Methods","title":"ChargeTransport.BulkRecombination","text":"mutable struct BulkRecombination\n\nA struct holding all necessary information for building bulk recombination. With help of this constructor we can read out the indices the user chooses for electron and hole quasi Fermi potentials.\n\niphin::Int64\nIndex for FVM construction of electron quasi Fermi potential.\n\niphip::Int64\nIndex for FVM construction of hole quasi Fermi potential.\n\nbulk_recomb_Auger::Bool\nBoolean for present Auger recombination in bulk.\n\nbulk_recomb_radiative::Bool\nBoolean for present radiative recombination in bulk.\n\nbulk_recomb_SRH::Union{Type{SRHOff}, Type{ChargeTransport.SRHStationary}, Type{SRHTrapsTransient}}\nDataType for present SRH recombination in bulk. This needs to be a Type due to cases with or without mobile traps.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Data","page":"Types, Constructors and Methods","title":"ChargeTransport.Data","text":"mutable struct Data{TFuncs<:Function}\n\nA struct holding all data information including model and numerics information, but also all physical parameters for a drift-diffusion simulation of a semiconductor device.\n\nF::Vector{TFuncs} where TFuncs<:Function\nAn array with the corresponding distribution function mathcalF_alpha for all carriers alpha.\n\nboundaryType::Vector{Union{Type{InterfaceModelDiscontqF}, Type{InterfaceModelIonCharge}, Type{InterfaceModelNone}, Type{InterfaceModelSurfaceReco}, Type{InterfaceModelSurfaceRecoAndTangentialFlux}, Type{InterfaceModelTangentialFlux}, Type{OhmicContact}, Type{SchottkyContact}}}\nAn array of DataTypes with the type of boundary model for each boundary (interior and exterior).\n\nbulkRecombination::BulkRecombination\nA struct containing information concerning the bulk recombination model.\n\nenableIonicCarriers::IonicChargeCarriers\nA struct which contains information on the regions, where ionic charge carriers (ions and/or ion vacancies) are present.\n\nenableTraps::ChargeTransport.Traps\nA struct which contains information on present SRH traps.\n\ninnerInterfaceModel::Union{Type{InterfaceModelDiscontqF}, Type{InterfaceModelIonCharge}, Type{InterfaceModelNone}, Type{InterfaceModelSurfaceReco}, Type{InterfaceModelSurfaceRecoAndTangentialFlux}, Type{InterfaceModelTangentialFlux}}\nDataType which stores information about which inner interface model is chosen by user. This quantity cannot be seen by the user and is needed for the core of the package.\n\nfluxApproximation::Union{Type{DiffusionEnhanced}, Type{ExcessChemicalPotential}, Type{ExcessChemicalPotentialGraded}, Type{GeneralizedSG}, Type{ScharfetterGummel}, Type{ScharfetterGummelGraded}}\nA DataType for the flux discretization method.\n\ncalculationType::Union{Type{InEquilibrium}, Type{OutOfEquilibrium}}\nA DataType for equilibrium or out of equilibrium calculations.\n\nmodelType::Union{Type{Stationary}, Type{Transient}}\nA DataType for transient or stationary calculations.\n\ngenerationModel::Union{Type{GenerationBeerLambert}, Type{GenerationNone}, Type{GenerationUniform}}\nA DataType for for generation model.\n\nλ1::Float64\nAn embedding parameter used to solve the nonlinear Poisson problem, where for λ1 = 0 the right hand-side is set to zero whereas for for λ1 = 1 we have a full space charge density.\n\nλ2::Float64\nAn embedding parameter for the generation rate.\n\nλ3::Float64\nAn embedding parameter for an electrochemical reaction.\n\ntempBEE1::Vector{Float64}\nWithin this template informations concerning the band-edge energy of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.\n\ntempBEE2::Vector{Float64}\nSee the description of tempBEE1.\n\ntempDOS1::Vector{Float64}\nWithin this template informations concerning the effective DOS of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.\n\ntempDOS2::Vector{Float64}\nSee the desciption of tempDOS2.\n\nisContinuous::Vector{Bool}\nAn array containing information on whether charge carriers are continuous or discontinuous. This is needed for building the AbstractQuantities which handle the indices of charge carriers on different regions.\n\nchargeCarrierList::Vector{Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}}\nThis list stores all charge carriers. Based on the user choice we have with this new type the opportunity to simulate discontinuous unknowns.\n\nindex_psi::Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}\nThis variable stores the index of the electric potential. Based on the user choice we have with this new type the opportunity to simulate discontinuous unknowns.\n\nparams::Params\nA struct holding all region dependent parameter information. For more information see struct Params.\n\nparamsnodal::ParamsNodal\nA struct holding all space dependent parameter information. For more information see struct ParamsNodal.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Data-Union{Tuple{TFuncs}, Tuple{Any, Any}} where TFuncs","page":"Types, Constructors and Methods","title":"ChargeTransport.Data","text":"Data(grid, numberOfCarriers; statfunctions) -> Data{StandardFuncSet}\n\n\nSimplified constructor for Data which only takes the grid and the numberOfCarriers as argument. Here, all necessary information including the physical parameters, but also some numerical information are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.DiffusionEnhanced","page":"Types, Constructors and Methods","title":"ChargeTransport.DiffusionEnhanced","text":"abstract type DiffusionEnhanced\n\nAbstract type for diffusion enhanced flux discretization, check M. Bessemoulin-Chatard, “A finite volume scheme for convection–diffusion equations with nonlinear diffusion derived from the Scharfetter–Gummel scheme”, Numerische Mathematik, vol. 121, pp. 637–670, 2012.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ExcessChemicalPotential","page":"Types, Constructors and Methods","title":"ChargeTransport.ExcessChemicalPotential","text":"abstract type ExcessChemicalPotential\n\nAbstract type for excess chemical potential flux discretization, check  Z. Yu, and R. Dutton, “SEDAN III – A one-dimensional device simulator”, http://www-tcad.stanford.edu/tcad/programs/sedan3.html, 1988.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ExcessChemicalPotentialGraded","page":"Types, Constructors and Methods","title":"ChargeTransport.ExcessChemicalPotentialGraded","text":"abstract type ExcessChemicalPotentialGraded\n\nAbstract type for excess chemical potential flux discretization for graded effective density of states and/or graded band-edge energies. This means, use this flux when at least one of these parameters is assumed to be space-dependent.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GeneralizedSG","page":"Types, Constructors and Methods","title":"ChargeTransport.GeneralizedSG","text":"abstract type GeneralizedSG\n\nAbstract type for generalized Scharfetter-Gummel flux discretization. This flux approximation results in an implicit equation which needs to be solved and is exact for all Blakemore type statistics functions with abritary γ, check T. Koprucki and K. Gärtner. “Discretization scheme for drift-diffusion equations with strong diffusion enhancement”. In: 12th International Conference on Numerical Simulation of Optoelectronic Devices (NUSOD). 2012, pp. 103–104.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationBeerLambert","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationBeerLambert","text":"abstract type GenerationBeerLambert\n\nAbstract type for Beer-Lambert generation. Note that this type is implemented, but not well tested yet.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationNone","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationNone","text":"abstract type GenerationNone\n\nAbstract type for no generation model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationUniform","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationUniform","text":"abstract type GenerationUniform\n\nAbstract type for uniform generation.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InEquilibrium","page":"Types, Constructors and Methods","title":"ChargeTransport.InEquilibrium","text":"abstract type InEquilibrium\n\nAbstract type for equilibrium calculations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InterfaceModelNone","page":"Types, Constructors and Methods","title":"ChargeTransport.InterfaceModelNone","text":"abstract type InterfaceModelNone\n\nAbstract type for no interface model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InterfaceModelSurfaceReco","page":"Types, Constructors and Methods","title":"ChargeTransport.InterfaceModelSurfaceReco","text":"abstract type InterfaceModelSurfaceReco\n\nAbstract type for surface recombination mechanisms.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.IonicChargeCarriers","page":"Types, Constructors and Methods","title":"ChargeTransport.IonicChargeCarriers","text":"mutable struct IonicChargeCarriers\n\nA struct holding all information necessary on the ionic charge carriers. With help of this constructor we can read out the indices the user chooses for ionic charge carrier quasi Fermi potentials and the respective regions in which they are defined. Note that it is possible to use ions as well as ion vacancies.\n\nionic_carriers::Vector{Int64}\nArray with the indices of ionic charge carriers.\n\nregions::Vector{Int64}\nCorresponding regions where ionic charge carriers are assumed to be present.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.OhmicContact","page":"Types, Constructors and Methods","title":"ChargeTransport.OhmicContact","text":"Abstract type for ohmic contacts as outer boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.OutOfEquilibrium","page":"Types, Constructors and Methods","title":"ChargeTransport.OutOfEquilibrium","text":"abstract type OutOfEquilibrium\n\nAbstract type for out of equilibrium calculations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Params","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"mutable struct Params\n\nA struct holding the physical region dependent parameters for a drift-diffusion simulation of a semiconductor device.\n\nnumberOfNodes::Int64\nNumber of nodes used for the disretization of the domain mathbfOmega.\n\nnumberOfRegions::Int64\nNumber of subregions mathbfOmega_k within the domain mathbfOmega.\n\nnumberOfBoundaryRegions::Int64\nNumber of boundary regions (partial mathbfOmega)_k such that partial mathbfOmega = cup_k (partial mathbfOmega)_k. Note that here are inner and outer boundaries calculated.\n\nnumberOfCarriers::Int64\nNumber of moving charge carriers.\n\ntemperature::Float64\nA given constant temperature.\n\nUT::Float64\nThe thermal voltage, which reads  U_T = k_B T  q.\n\nγ::Float64\nThe parameter of the Blakemore statistics (needed for the generalizedSG flux).\n\nr0::Float64\nPrefactor of electro-chemical reaction of internal boundary conditions.\n\nprefactor_SRH::Float64\nPrefactor for stationary SRH recombination.\n\ngenerationPeak::Float64\nParameter for the shift of generation peak of the Beer-Lambert generation profile.\n\nSchottkyBarrier::Vector{Float64}\nAn array for the given Schottky barriers at present Schotkky contacts.\n\nchargeNumbers::Vector{Float64}\nAn array with the corresponding charge numbers z_alpha for all carriers alpha.\n\nbBandEdgeEnergy::Matrix{Float64}\nAn array with the corresponding boundary band-edge energy values E_alpha in each region for each carrier alpha.\n\nbDensityOfStates::Matrix{Float64}\nAn array with the corresponding boundary effective density of states values N_alpha for each carrier alpha.\n\nbMobility::Matrix{Float64}\nA 2D array with the corresponding boundary mobility values mu_alpha in each boundary region for each carrier alpha.\n\nbDoping::Matrix{Float64}\nA 2D array with the corresponding boundary doping values for each carrier alpha.\n\nbVelocity::Matrix{Float64}\nA 2D array with the corresponding boundary velocity values for each carrier alpha, when assuming Schottky contacts.\n\nrecombinationSRHvelocity::Matrix{Float64}\nA 2D array with the corresponding recombination surface boundary velocity values for electrons and holes.\n\nbRecombinationSRHTrapDensity::Matrix{Float64}\nA 2D array with the corresponding recombination surface boundary density values for electrons and holes.\n\ndoping::Matrix{Float64}\nA 2D array with the corresponding doping values for each carrier alpha on each region.\n\ndensityOfStates::Matrix{Float64}\nA 2D array with the corresponding effective density of states values N_alpha for each carrier alpha on each region.\n\nbandEdgeEnergy::Matrix{Float64}\nA 2D array with the corresponding band-edge energy values E_alpha for each carrier alpha on each region.\n\nmobility::Matrix{Float64}\nA 2D array with the corresponding mobility values mu_alpha for each carrier alpha on each region.\n\nrecombinationSRHLifetime::Matrix{Float64}\nA 2D array with the corresponding SRH lifetimes tau_n tau_p for electrons and holes.\n\nrecombinationSRHTrapDensity::Matrix{Float64}\nA 2D array with the corresponding time-independent SRH trap densities n_tau p_tau for electrons and holes.\n\nrecombinationAuger::Matrix{Float64}\nA 2D array with the corresponding Auger coefficients for electrons and holes.\n\ndielectricConstant::Vector{Float64}\nA region dependent dielectric constant.\n\ngenerationIncidentPhotonFlux::Vector{Float64}\nA region dependent array for the prefactor in the generation process which is the incident photon flux.\n\ngenerationUniform::Vector{Float64}\nA region dependent array for an uniform generation rate.\n\ngenerationAbsorption::Vector{Float64}\nA region dependent array for the absorption coefficient in the generation process.\n\nrecombinationRadiative::Vector{Float64}\nA region dependent array for the radiative recombination rate.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Params-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"Params(grid, numberOfCarriers) -> Params\n\n\nSimplified constructor for Params which only takes the grid and the numberOfCarriers as argument.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.ParamsNodal","page":"Types, Constructors and Methods","title":"ChargeTransport.ParamsNodal","text":"mutable struct ParamsNodal\n\nA struct holding the physical nodal, i.e. space-dependent parameters for a drift-diffusion simulation of a semiconductor device.\n\ndielectricConstant::Vector{Float64}\nA node dependent dielectric constant.\n\ndoping::Vector{Float64}\nA 1D array with the corresponding doping values on each node.\n\nmobility::Matrix{Float64}\nA 2D array with the corresponding mobility values mu_alpha for each carrier alpha on each node.\n\ndensityOfStates::Matrix{Float64}\nA 2D array with the corresponding effective density of states values N_alpha for each carrier alpha on each node.\n\nbandEdgeEnergy::Matrix{Float64}\nA 2D array with the corresponding band-edge energy values E_alpha for each carrier alpha on each node.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ParamsNodal-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.ParamsNodal","text":"ParamsNodal(grid, numberOfCarriers) -> ParamsNodal\n\n\nSimplified constructor for ParamsNodal which only takes the grid and the numberOfCarriers as argument.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.SRHWithTrapsType","page":"Types, Constructors and Methods","title":"ChargeTransport.SRHWithTrapsType","text":"Possible types for SRH recombination without traps.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ScharfetterGummel","page":"Types, Constructors and Methods","title":"ChargeTransport.ScharfetterGummel","text":"abstract type ScharfetterGummel\n\nAbstract type for Scharfetter-Gummel flux discretization. Choose this one, when the Boltzmann statistics function is chosen as statistics, check D. Scharfetter and H. Gummel, “Large-signal analysis of a silicon Read diode oscillator”, IEEE Trans. Electr. Dev., vol. 16, pp. 64–77, 1969.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ScharfetterGummelGraded","page":"Types, Constructors and Methods","title":"ChargeTransport.ScharfetterGummelGraded","text":"abstract type ScharfetterGummelGraded\n\nAbstract type for Scharfetter-Gummel flux discretization for graded effective density of states and/or graded band-edge energies. This means, use this flux when at least one of these parameters is assumed to be space-dependent.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.SchottkyContact","page":"Types, Constructors and Methods","title":"ChargeTransport.SchottkyContact","text":"Abstract type for schottky contacts as boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Stationary","page":"Types, Constructors and Methods","title":"ChargeTransport.Stationary","text":"abstract type Stationary\n\nAbstract type for stationary simulations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.System","page":"Types, Constructors and Methods","title":"ChargeTransport.System","text":"mutable struct System\n\nA struct holding all information necessary for a drift-diffusion type system.\n\ndata::Data\nA struct holding all data information, see Data\n\nfvmsys::VoronoiFVM.AbstractSystem\nA struct holding system information for the finite volume system.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.System-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.System","text":"System(grid, data; unknown_storage)\n\n\nSystem constructor which builds all necessary information needed based on the input parameters with special regard to interface models. This is the main struct in which all information on the input data, but also on the solving system, are stored.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Transient","page":"Types, Constructors and Methods","title":"ChargeTransport.Transient","text":"abstract type Transient\n\nAbstract type for transient simulations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Traps","page":"Types, Constructors and Methods","title":"ChargeTransport.Traps","text":"mutable struct Traps\n\nA struct holding all information necessary for enabling traps in the SRH recombination. With help of this constructor we can read out the index the user chooses for trap quasi Fermi potentials and the respective regions in which they are defined.\n\ntraps::Int64\nArray with the index of traps.\n\nregions::Vector{Int64}\nCorresponding regions where traps are assumed to be present.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#Methods-2","page":"Types, Constructors and Methods","title":"Methods","text":"","category":"section"},{"location":"allindex/","page":"Types, Constructors and Methods","title":"Types, Constructors and Methods","text":"Modules = [ChargeTransport]\nOrder=[:function]","category":"page"},{"location":"allindex/#ChargeTransport.Blakemore-Tuple{Real, Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.Blakemore","text":"Blakemore(x::Real, γ::Real) -> Any\n\n\nThe Blakemore approximation 1(exp(-x) + γ) with variable real scalar γ, see J. S. Blakemore. “The Parameters of Partially Degenerate Semiconductors”. In: Proceedings of the Physical Society. Section A 65 (1952), pp. 460–461.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Boltzmann-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.Boltzmann","text":"Boltzmann(x::Real) -> Any\n\n\nThe Boltzmann statistics function exp(x).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.FermiDiracMinusOne-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.FermiDiracMinusOne","text":"FermiDiracMinusOne(x::Real) -> Any\n\n\nThe Fermi-Dirac integral of order -1 which reads 1(exp(-x) + 1), see J.S. Blakemore, Approximations for Fermi-Dirac integrals, especially the function F_12 (eta) used to describe electron density in a semiconductor, Solid-State Electronics 25 (11) (1982) 1067 – 1076.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.FermiDiracOneHalfBednarczyk-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.FermiDiracOneHalfBednarczyk","text":"FermiDiracOneHalfBednarczyk(x::Real) -> Any\n\n\nThe incomplete Fermi-Dirac integral of order 1/2, implemented according to [Bednarczyk1978, \"The Approximation of the Fermi-Dirac integral F_12(eta)\"].\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.FermiDiracOneHalfTeSCA-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.FermiDiracOneHalfTeSCA","text":"FermiDiracOneHalfTeSCA(x::Real) -> Any\n\n\nThe incomplete Fermi-Dirac integral of order 1/2, implemented according to the software package TeSCA, see https://wias-berlin.de/software/index.jsp?lang=1&id=TeSCA.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.RHSContinuityEquations!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.RHSContinuityEquations!","text":"RHSContinuityEquations!(f, u, node, data)\n\n\nFunction which builds right-hand side of electric charge carriers.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.RHSPoisson!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.RHSPoisson!","text":"RHSPoisson!(f, u, node, data) -> Any\n\n\nFunction which builds right-hand side of Poisson equation, i.e. which builds the space charge density.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.bflux!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.bflux!","text":"bflux!(f, u, bedge, data) -> Any\n\n\nMaster bflux! function. This is the function which enters VoronoiFVM and hands over for each boundary the flux within the boundary.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.breaction!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.breaction!","text":"breaction!(f, u, bnode, data) -> Any\n\n\nMaster breaction! function. This is the function which enters VoronoiFVM and hands over for each boundary the chosen boundary model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{OhmicContact}}","page":"Types, Constructors and Methods","title":"ChargeTransport.breaction!","text":"breaction!(f, u, bnode, data, _::Type{OhmicContact}) -> Any\n\n\nCreates ohmic boundary conditions via a penalty approach with penalty parameter delta. For example, the right-hand side for the electrostatic potential psi is implemented as\n\nfpsi  = -qdelta   ( (p - N_a) - (n - N_d) ),\n\nassuming a bipolar semiconductor. In general, we have for some given charge number z_alpha\n\nfpsi =  -qdelta  sum_alpha z_alpha  (n_alpha - C_alpha) \n\nwhere C_alpha corresponds to some doping w.r.t. the species alpha.\n\nThe boundary conditions for the charge carriers are set in the main file. Hence,\n\nfn_alpha = 0`\n\nfor all charge carriers alpha.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{SchottkyContact}}","page":"Types, Constructors and Methods","title":"ChargeTransport.breaction!","text":"breaction!(f, u, bnode, data, _::Type{SchottkyContact})\n\n\nCreates Schottky boundary conditions in a first attempt. For the electrostatic potential we assume\n\npsi = phi_Sq + U\n\nwhere  phi_S corresponds to a given value (Schottky barrier) and U to the applied voltage. For now, the quantitity phi_S needs to be specified in the main file. For the charge carriers we assume the following\n\nfn_alpha  =  z_alpha q v_alpha (n_alpha - n_alpha 0),\n\nwhere v_alpha can be treated as a surface recombination mechanism and is given. The parameter n_alpha 0 is a given value, calculated by the statistical relation, when assuming no electrical field and a quasi Fermi level equal to the Schottky barrier phi_S, i.e.\n\nn_alpha 0= N_alpha mathcalF_alpha Bigl( z_alpha U_T (E_alpha - phi_S)  q Bigr)\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.bstorage!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.bstorage!","text":"bstorage!(f, u, bnode, data) -> Any\n\n\nMaster bstorage! function. This is the function which enters VoronoiFVM and hands over for each boundary the time-dependent part of the chosen boundary model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.charge_density-NTuple{8, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.charge_density","text":"charge_density(psi0, phi, UT, EVector, chargeNumbers, dopingVector, dosVector, FVector) -> Any\n\n\nCompute the charge density, i.e. the right-hand side of Poisson's equation.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.charge_density-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.charge_density","text":"charge_density(ctsys, sol) -> Any\n\n\nCompute the charge density for each region separately.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.compute_densities!-Tuple{Any, Any, Any, Any, Any, Bool}","page":"Types, Constructors and Methods","title":"ChargeTransport.compute_densities!","text":"compute_densities!(u, data, inode, region, icc, in_region::Bool) -> Any\n\n\nFor given potentials, compute corresponding densities. This function is needed for the method, plotting the densities.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.compute_densities!-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.compute_densities!","text":"compute_densities!(grid, data, sol) -> Matrix{Real}\n\n\nFor given potentials in vector form, compute corresponding vectorized densities. [Caution: this was not tested for multidimensions.]\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.compute_energies!-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.compute_energies!","text":"compute_energies!(grid, data, sol)\n\n\nFor given solution in vector form, compute corresponding vectorized band-edge energies and Fermi level. [Caution: this was not tested for multidimensions.]\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.degenerateLimit-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.degenerateLimit","text":"degenerateLimit(x) -> Any\n\n\nDegenerate limit of incomplete Fermi-Dirac integral of order 1/2.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.electroNeutralSolution!-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.electroNeutralSolution!","text":"electroNeutralSolution!(grid, data; Newton) -> Any\n\n\nCompute the electro-neutral solution for the Boltzmann approximation. It is obtained by setting the left-hand side in the Poisson equation equal to zero and solving for psi. The charge carriers may obey different statitics functions. Currently, this one is not well tested for the case of charge carriers beyond electrons and holes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.electrochemicalReaction-NTuple{10, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.electrochemicalReaction","text":"electrochemicalReaction(data, u, iphia, ipsi, iphiaJunction, ipsiJunction, β, κ, DOS, E) -> Any\n\n\nElectrochemical reaction between interface and bulk ionic species. This function enters in the internal boundary reaction in case of an ion charge interface model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.enable_ionic_carriers-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.enable_ionic_carriers","text":"Corresponding constructor for the present ionic charge carriers and the respective regions.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.enable_traps!-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.enable_traps!","text":"Corresponding constructor for the present traps and the respective regions.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction-NTuple{5, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction","text":"etaFunction(psi, phi, UT, E, z) -> Any\n\n\nThe argument of the distribution function for given varphi_alpha and psi\n\nz_alpha  U_T  ( (varphi_alpha - psi) + E_alpha  q )\n\nThe parameters E_alpha and z_alpha are given as vectors. This function may be used to compute the charge density, i.e. the right-hand side of the Poisson equation.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction-Tuple{Any, Any, Any, Any, Any, Bool}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction","text":"etaFunction(u, data, node, region, icc, in_region::Bool) -> Any\n\n\nThe argument of the distribution function for floats.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction-Tuple{Any, VoronoiFVM.BNode, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction","text":"etaFunction(u, bnode::VoronoiFVM.BNode, data, icc) -> Any\n\n\nThe argument of the distribution function for boundary nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction-Tuple{Any, VoronoiFVM.Node, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction","text":"etaFunction(u, node::VoronoiFVM.Node, data, icc) -> Any\n\n\nThe argument of the distribution function for interior nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.flux!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.flux!","text":"flux!(f, u, edge, data) -> Any\n\n\nMaster flux functions which enters VoronoiFVM. Flux discretization scheme is chosen in two steps. First, we need to see, if we are in or out of equilibrium. If, InEquilibrium, then no flux is passed. If outOfEquilibrium, we choose the flux approximation which the user chose.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_BEE!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}, VoronoiFVM.Node, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_BEE!","text":"get_BEE!(icc::Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}, node::VoronoiFVM.Node, data) -> Any\n\n\nDefining locally the band-edge energy for interior nodes (analougesly for boundary nodes and edges).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_DOS!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}, VoronoiFVM.Node, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_DOS!","text":"get_DOS!(icc::Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}, node::VoronoiFVM.Node, data) -> Any\n\n\nDefining locally the effective DOS for interior nodes (analogously for boundary nodes and edges).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_current_val-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_current_val","text":"Calculates current for time dependent problem.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_current_val-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_current_val","text":"Calculates current for stationary problem.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plotDiffusionEnhancements-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.plotDiffusionEnhancements","text":"plotDiffusionEnhancements()\n\n\nPlot diffusion enhancements.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plotDistributions-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.plotDistributions","text":"plotDistributions(; Plotter)\n\n\nPlot different distribution integrals.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_IV-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_IV","text":"plot_IV(Plotter, biasValues, IV, title; plotGridpoints) -> Any\n\n\nMethod for showing the total current. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_densities-Tuple{Any, Any, Data, Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_densities","text":"plot_densities(Plotter, grid, data::Data, sol, title, label_density; plotGridpoints) -> Any\n\n\nPlotting routine, where the charge carrier densities are depicted in dependence of space. The case of heterojunctions is tested, but yet multidimensional plottings are not included. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, Data, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_doping","text":"plot_doping(Plotter, g::ExtendableGrids.ExtendableGrid, data::Data, label_density) -> Any\n\n\nPossibility to plot the considered doping. This is especially useful for making sure that the interior and the boundary doping agree.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ParamsNodal}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_doping","text":"Plot doping for nodal dependent doping.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_electroNeutralSolutionBoltzmann-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_electroNeutralSolutionBoltzmann","text":"plot_electroNeutralSolutionBoltzmann(Plotter, grid, psi0; plotGridpoints) -> Any\n\n\nPlotting routine for depicting the electroneutral potential. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_energies-Tuple{Any, Any, Data, Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_energies","text":"plot_energies(Plotter, grid, data::Data, sol, title, label_energy; plotGridpoints) -> Any\n\n\nWith this method it is possible to plot the energies\n\nE_alpha - q psi quad textwrt space\n\nThe case of heterojunctions is tested, but yet multidimensional plottings are not included.\n\nOne input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_energies-Tuple{Any, ExtendableGrids.ExtendableGrid, Data, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_energies","text":"plot_energies(Plotter, grid, data, label_BEE)\n\n\nWith this method it is possible to depict the band-edge energies E_alpha. This can be useful for debugging when dealing with heterojunctions.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_solution-Tuple{Any, Any, Data, Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_solution","text":"plot_solution(Plotter, grid, data::Data, solution, title, label_solution; plotGridpoints) -> Any\n\n\nMethod for plotting the solution vectors: the electrostatic potential psi as well as the charge carriers. The case of heterojunctions is tested, but yet multidimensional plottings are not included. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.printJacobi-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.printJacobi","text":"printJacobi(node, sys)\n\n\nFirst try of debugger. Print the Jacobi matrix for a given node, i.e. the number of node in the grid and not the excact coordinate. This is only done for the one dimensional case so far.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.reaction!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.reaction!","text":"reaction!(f, u, node, data)\n\n\nMaster reaction! function. This is the function which enters VoronoiFVM and hands over reaction terms for concrete calculation type and bulk recombination model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{InEquilibrium}}","page":"Types, Constructors and Methods","title":"ChargeTransport.reaction!","text":"reaction!(f, u, node, data, _::Type{InEquilibrium})\n\n\nReaction in case of equilibrium, i.e. no generation and recombination is considered.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}","page":"Types, Constructors and Methods","title":"ChargeTransport.reaction!","text":"reaction!(f, u, node, data, _::Type{OutOfEquilibrium})\n\n\nSets up the right-hand sides. Assuming a bipolar semiconductor the right-hand side for the electrostatic potential becomes\n\nfψ  = - q ((p - N_a) - (n - N_d) ) = - q  sum  n_alpha  (n_alpha - C_alpha)\n\nfor some doping C_alpha w.r.t. to the species alpha. The right-hand sides for the charge carriers read as\n\nfn_alpha =  - z_alpha  q (G -  R)\n\nfor all charge carriers n_alpha. The recombination includes radiative, Auger and Shockley-Read-Hall recombination. For latter recombination process the stationary simplification is implemented.\n\nThe recombination is only implemented for electron and holes and assumes that the electron index is 1 and the hole index is 2.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.set_bulk_recombination-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.set_bulk_recombination","text":"set_bulk_recombination(; iphin, iphip, bulk_recomb_Auger, bulk_recomb_radiative, bulk_recomb_SRH)\n\n\nCorresponding constructor for the bulk recombination model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.set_plotting_labels-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.set_plotting_labels","text":"set_plotting_labels(data) -> Tuple{Any, Any, Matrix{String}, Any}\n\n\nMethod which can be used to construct the arrays parsed to the plotting routines for labeling. The description for electrons and holes are predefined. If one wishes to extend by labels for, e.g. mobile ionic carriers or traps, this can be done within the main file.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.storage!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.storage!","text":"storage!(f, u, node, data) -> Union{Nothing, Float64}\n\n\nMaster storage! function. This is the function which enters VoronoiFVM and hands over a storage term, if we consider transient problem.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.storage!-Tuple{Any, Any, Any, Any, Type{Transient}}","page":"Types, Constructors and Methods","title":"ChargeTransport.storage!","text":"storage!(f, u, node, data, _::Type{Transient}) -> Float64\n\n\nThe storage term for time-dependent problems. Currently, for the time-dependent current densities the implicit Euler scheme is used. Hence, we have\n\nfn_alpha =  z_alpha  q _t n_alpha\n\nand for the electrostatic potential fψ = 0.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.trap_density!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.trap_density!","text":"trap_density!(icc, ireg, data, Et)\n\n\nCompute trap densities for a given trap energy. [Currently, only done for the Boltzmann statistics and for region dependent parameters.]\n\n\n\n\n\n","category":"method"},{"location":"PSC/#Perovskite-solar-cell","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"We simulate charge transport in perovskite solar cells (PSCs), where we have apart from holes and electrons also ionic charge carriers. Here, we assume to have three domains, denoted by mathbfOmega = mathbfOmega_textHTL cup mathbfOmega_textintr cup mathbfOmega_textETL   The unknowns are the quasi Fermi potentials of electrons holes and anion vacancies varphi_n varphi_p varphi_a as well as the electric potential psi. The underlying PDEs are given by","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"beginaligned\n\t- nabla cdot (varepsilon_s nabla psi) = q Big( (p(psi varphi_p) - N_A ) - (n(psi varphi_n) - N_D) Big)\n\tq partial_t n(psi varphi_n) - nabla cdot mathbfj_n = qBigl(G(mathbfx) - R(np) Bigr) \n\tq partial_t p(psi varphi_p) + nabla cdot mathbfj_p = Bigl(G(mathbfx) - R(np) Bigr)\nendaligned","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"for mathbfx in mathbfOmega_textHTL cup  mathbfOmega_textETL  t in 0 t_F. In the middle, intrinsic region ($ \\mathbf{x} \\in \\mathbf{\\Omega}_{\\text{intr}} $), we have","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"beginaligned\n\t- nabla cdot (varepsilon_s nabla psi) = q Big( p(psi varphi_p)  - n(psi varphi_n) + a(psi varphi_a) - C_0 Big)\nq partial_t n(psi varphi_n)\t- nabla cdot mathbfj_n = Bigl(G(mathbfx) - R(np) Bigr) \n\tq partial_t p(psi varphi_p) + nabla cdot mathbfj_p = Bigl(G(mathbfx) - R(np) Bigr)\n\tq partial_t a(psi varphi_a) + nabla cdot mathbfj_a = 0\nendaligned","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"see Abdel2021.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Differences to the previous example include","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"an additional charge carrier (the anion vacancy)\nparameter jumps across heterojunctions\nthe transient case\na generation rate G\nhigher dimensional problem.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"A quick survey on how to use ChargeTransport.jl to adjust the input parameters such that these features can be simulated will be given in the following.","category":"page"},{"location":"PSC/#Example-1:-Graded-interfaces","page":"Perovskite solar cell","title":"Example 1: Graded interfaces","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"By default, we assume abrupt inner interfaces. If one wishes to simulate graded interfaces, where for example the effective density of states and the band-edge energy may vary, we refer to this or this example.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"We sketch the relevant parts here. First, we need to define two additional thin interface layers","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"# region numbers\nregionDonor            = 1       # n doped region\nregionJunction1        = 2\nregionIntrinsic        = 3       # intrinsic region\nregionJunction2        = 4\nregionAcceptor         = 5       # p doped region","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"which need to be taken into account by the initialization of the grid.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Second, since we allow varying parameters within the thin interface layers, the flux discretization scheme needs to be chosen accordingly and we need to construct a nodally dependent parameter struct","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"data.fluxApproximation = ScharfetterGummelGraded\n\nparamsnodal            = ParamsNodal(grid, numberOfCarriers)","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Finally, we introduce graded parameters. Currently, only a linear grading is implemented.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"paramsnodal.bandEdgeEnergy[iphin, :] = grading_parameter!(paramsnodal.bandEdgeEnergy[iphin, :],\n                                                         coord, regionTransportLayers, regionJunctions,\n                                                         h, heightLayers, lengthLayers, EC)","category":"page"},{"location":"PSC/#Example-2:-Linear-IV-scan-protocol","page":"Perovskite solar cell","title":"Example 2: Linear IV scan protocol","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Here, we summarize the main parts of this example. Define three charge carriers.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"iphin                    = 2 # electrons\niphip                    = 1 # holes\niphia                    = 3 # anion vacancies\nnumberOfCarriers         = 3","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Consider the transient problem and enable the ionic charge carriers only in the active layer:","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"data.modelType           = Transient\ndata.enableIonicCarriers = enable_ionic_carriers(ionic_carriers = [iphia], regions = [regionIntrinsic])","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Following specification is needed for a linear I-V scan protocol.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"scanrate                 = 1.0 * V/s\nnumber_tsteps            = 31\nendVoltage               = voltageAcceptor # bias goes until the given voltage at acceptor boundary\ntend                     = endVoltage/scanrate\n\n## with fixed timestep sizes we can calculate the times a priori\ntvalues                    = range(0, stop = tend, length = number_tsteps)","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Solve the transient problem:","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"for istep = 2:number_tsteps\n\n    t  = tvalues[istep]                  # current time\n    Δu = t * scanrate                    # applied voltage\n    Δt = t - tvalues[istep-1]            # time step\n    set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n    solve!(solution, initialGuess, ctsys, control = control, tstep = Δt) # provide time step\n    initialGuess .= solution\n\nend","category":"page"},{"location":"PSC/#Example-3:-Illumination","page":"Perovskite solar cell","title":"Example 3: Illumination","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Add uniform illumination to the previous code by setting","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"data.generationModel = GenerationUniform","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"and specify the uniform generation rate in each region, i.e.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"for ireg in 1:numberOfRegions\n    params.generationUniform[ireg] = generationUniform[ireg]\nend","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"for given data stored in generationUniform.  If one wishes to use the Beer-Lambert generation, then the corresponding code would be","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"data.generationModel                          = GenerationBeerLambert\n\nfor ireg in 1:numberOfRegions\n    params.generationIncidentPhotonFlux[ireg] = incidentPhotonFlux[ireg]\n    params.generationAbsorption[ireg]         = absorption[ireg]\nend\n\nparams.generationPeak                         = generationPeak","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Furthermore, we recommend performing a time loop while increasing the generation rate and afterwards applying the scan protocol with a full generation due to numerical stability, see this example or this one.","category":"page"},{"location":"PSC/#Example-4:-Multi-dimensional-problems","page":"Perovskite solar cell","title":"Example 4: Multi-dimensional problems","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"It is also possible to perform multi-dimensional simulations.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"For a 2D mesh you may use a structured grid via ExtendableGrids.jl or an unstructured mesh via the Julia wrapper Triangulate.jl for Jonathan Richard Shewchuk's Triangle mesh generator. Respective examples can be likewise found within this package.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Lastly, with help of the TetGen.jl wrapper, three dimensional tetrahedral meshes can be generated, see this example.","category":"page"},{"location":"examples/Ex106_PSC_withIons_IVMeasurement/#PSC-device-with-ions-and-linear-I-V-scan-protocol-(1D).","page":"PSC device with ions and linear I-V scan protocol (1D).","title":"PSC device with ions and linear I-V scan protocol (1D).","text":"","category":"section"},{"location":"examples/Ex106_PSC_withIons_IVMeasurement/","page":"PSC device with ions and linear I-V scan protocol (1D).","title":"PSC device with ions and linear I-V scan protocol (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex106_PSC_withIons_IVMeasurement/","page":"PSC device with ions and linear I-V scan protocol (1D).","title":"PSC device with ions and linear I-V scan protocol (1D).","text":"Simulating a three layer PSC device SiO2| MAPI | SiO2 with mobile ions where the ion vacancy accumulation is limited by the Fermi-Dirac integral of order -1. The simulations are performed out of equilibrium, time-dependent and with abrupt interfaces. A linear I-V measurement protocol is included and the corresponding solution vectors after the scan can be depicted.","category":"page"},{"location":"examples/Ex106_PSC_withIons_IVMeasurement/","page":"PSC device with ions and linear I-V scan protocol (1D).","title":"PSC device with ions and linear I-V scan protocol (1D).","text":"The parameters can be found in Table S.13, https://arxiv.org/abs/2009.04384. Or here: https://github.com/barnesgroupICL/Driftfusion/blob/Methods-IonMonger-Comparison/Inputfiles/IonMongerdefault_bulk.csv","category":"page"},{"location":"examples/Ex106_PSC_withIons_IVMeasurement/","page":"PSC device with ions and linear I-V scan protocol (1D).","title":"PSC device with ions and linear I-V scan protocol (1D).","text":"module Ex106_PSC_withIons_IVMeasurement\n\nusing VoronoiFVM\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing PyPlot\n\nfunction main(;n = 2, Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage=:dense)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionDonor      = 1                           # n doped region\n    regionIntrinsic  = 2                           # intrinsic region\n    regionAcceptor   = 3                           # p doped region\n    regions          = [regionDonor, regionIntrinsic, regionAcceptor]\n    numberOfRegions  = length(regions)\n\n    # boundary region numbers\n    bregionDonor     = 1\n    bregionAcceptor  = 2\n\n    # grid\n    h_ndoping        = 9.90e-6 * cm\n    h_intrinsic      = 4.00e-5 * cm + 2.0e-7 * cm\n    h_pdoping        = 1.99e-5 * cm\n    heightLayers     = [h_ndoping,\n                        h_ndoping + h_intrinsic,\n                        h_ndoping + h_intrinsic + h_pdoping]\n\n    x0               = 0.0 * cm\n    δ                = 4*n        # the larger, the finer the mesh\n    t                = 0.5*(cm)/δ # tolerance for geomspace and glue (with factor 10)\n    k                = 1.5        # the closer to 1, the closer to the boundary geomspace\n\n    coord_n_u        = collect(range(x0, h_ndoping/2, step=h_ndoping/(0.8*δ)))\n    coord_n_g        = geomspace(h_ndoping/2,\n                                 h_ndoping,\n                                 h_ndoping/(0.7*δ),\n                                 h_ndoping/(1.1*δ),\n                                 tol=t)\n    coord_i_g1       = geomspace(h_ndoping,\n                                 h_ndoping+h_intrinsic/k,\n                                 h_intrinsic/(2.8*δ),\n                                 h_intrinsic/(2.1*δ),\n                                 tol=t)\n    coord_i_g2       = geomspace(h_ndoping+h_intrinsic/k,\n                                 h_ndoping+h_intrinsic,\n                                 h_intrinsic/(2.1*δ),\n                                 h_intrinsic/(2.8*δ),\n                                 tol=t)\n    coord_p_g       = geomspace(h_ndoping+h_intrinsic,\n                                h_ndoping+h_intrinsic+h_pdoping/2,\n                                h_pdoping/(1.6*δ),\n                                h_pdoping/(1.6*δ),\n                                tol=t)\n    coord_p_u       = collect(range(h_ndoping+h_intrinsic+h_pdoping/2, h_ndoping+h_intrinsic+h_pdoping, step=h_pdoping/(1.3*δ)))\n\n    coord           = glue(coord_n_u, coord_n_g,  tol=10*t)\n    coord           = glue(coord,     coord_i_g1, tol=10*t)\n    coord           = glue(coord,     coord_i_g2, tol=10*t)\n    coord           = glue(coord,     coord_p_g,  tol=10*t)\n    coord           = glue(coord,     coord_p_u,  tol=10*t)\n    grid            = ExtendableGrids.simplexgrid(coord)\n\n    # set different regions in grid, doping profiles do not intersect\n    cellmask!(grid, [0.0 * μm],        [heightLayers[1]], regionDonor, tol = 1.0e-18)     # n-doped region   = 1\n    cellmask!(grid, [heightLayers[1]], [heightLayers[2]], regionIntrinsic, tol = 1.0e-18) # intrinsic region = 2\n    cellmask!(grid, [heightLayers[2]], [heightLayers[3]], regionAcceptor, tol = 1.0e-18)  # p-doped region   = 3\n\n    if plotting\n        gridplot(grid, Plotter = Plotter)\n        Plotter.title(\"Grid\")\n        Plotter.figure()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    # Note that, if setting iphia not to the last index, we get convergence problems with the Newton.\n    iphin            = 2 # electron quasi Fermi potential\n    iphip            = 1 # hole quasi Fermi potential\n    iphia            = 3 # anion vacancy quasi Fermi potential\n\n    numberOfCarriers = 3 # electrons, holes and anion vacancies\n\n    # temperature\n    T                = 300.0                 *  K\n\n    # band edge energies\n    Ec_d             = -4.0                  *  eV\n    Ev_d             = -5.8                  *  eV\n\n    Ec_i             = -3.7                  *  eV\n    Ev_i             = -5.4                  *  eV\n\n    Ec_a             = -3.4                  *  eV\n    Ev_a             = -5.1                  *  eV\n\n    # ############ adjust Na, Ea for anion vacancies here ###########\n    Nanion           = 1.0e21                / (cm^3)\n    Ea_i             = -4.45                 *  eV\n\n    # for the labels in the figures\n    textEa           = Ea_i./eV\n    textNa           = Nanion.*cm^3\n    # ############ adjust Na, Ea for anion vacancies here ###########\n\n    EC               = [Ec_d, Ec_i, Ec_a]\n    EV               = [Ev_d, Ev_i, Ev_a]\n    EA               = [0.0,  Ea_i,  0.0]\n\n    # effective densities of state\n    Nc_d             = 5.0e19                / (cm^3)\n    Nv_d             = 5.0e19                / (cm^3)\n\n    Nc_i             = 8.1e18                / (cm^3)\n    Nv_i             = 5.8e18                / (cm^3)\n\n    Nc_a             = 5.0e19                / (cm^3)\n    Nv_a             = 5.0e19                / (cm^3)\n\n    NC               = [Nc_d, Nc_i,  Nc_a]\n    NV               = [Nv_d, Nv_i,  Nv_a]\n    NAnion           = [0.0,  Nanion, 0.0]\n\n    # mobilities\n    μn_d             = 3.89                  * (cm^2) / (V * s)\n    μp_d             = 3.89                  * (cm^2) / (V * s)\n\n    μn_i             = 6.62e1                * (cm^2) / (V * s)\n    μp_i             = 6.62e1                * (cm^2) / (V * s)\n\n    μa_i             = 3.93e-12              * (cm^2) / (V * s)\n\n    μn_a             = 3.89e-1               * (cm^2) / (V * s)\n    μp_a             = 3.89e-1               * (cm^2) / (V * s)\n\n    μn               = [μn_d, μn_i, μn_a]\n    μp               = [μp_d, μp_i, μp_a]\n    μa               = [0.0,  μa_i, 0.0 ]\n\n    # relative dielectric permittivity\n    ε_d              = 10.0                  *  1.0\n    ε_i              = 24.1                  *  1.0\n    ε_a              = 3.0                   *  1.0\n\n    ε                = [ε_d, ε_i, ε_a]\n\n    # radiative recombination\n    r0_d             = 0.0e+0               * cm^3 / s\n    r0_i             = 1.0e-12              * cm^3 / s\n    r0_a             = 0.0e+0               * cm^3 / s\n\n    r0               = [r0_d, r0_i, r0_a]\n\n    # life times and trap densities\n    τn_d             = 1.0e100              * s\n    τp_d             = 1.0e100              * s\n\n    τn_i             = 3.0e-10              * s\n    τp_i             = 3.0e-8               * s\n    τn_a             = τn_d\n    τp_a             = τp_d\n\n    τn               = [τn_d, τn_i, τn_a]\n    τp               = [τp_d, τp_i, τp_a]\n\n    # SRH trap energies\n    Ei_d             = -5.0                 * eV\n    Ei_i             = -4.55                * eV\n    Ei_a             = -4.1                 * eV\n\n    EI               = [Ei_d, Ei_i, Ei_a]\n\n    # Auger recombination\n    Auger            = 0.0\n\n    # doping\n    Nd               = 1.03e18              / (cm^3)\n    Na               = 1.03e18              / (cm^3)\n    C0               = 1.6e19               / (cm^3)\n\n    # contact voltage\n    voltageAcceptor  = 1.2                  * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Transient\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F                             = [Boltzmann, Boltzmann, FermiDiracMinusOne]\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = true,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceModelNone,\n    # InterfaceModelSurfaceReco (inner boundary).\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n\n    # Here, the user gives information on which indices belong to ionic charge carriers and\n    # in which regions these charge carriers are present. In this application ion vacancies\n    # only live in active perovskite layer.\n    data.enableIonicCarriers           = enable_ionic_carriers(ionic_carriers = [iphia], regions = [regionIntrinsic])\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation             = ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                              = Params(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = -1\n    params.chargeNumbers[iphip]                         =  1\n    params.chargeNumbers[iphia]                         =  1\n\n    for ireg in 1:numberOfRegions # interior region data\n\n        params.dielectricConstant[ireg]                 = ε[ireg]\n\n        # effective DOS, band edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = NC[ireg]\n        params.densityOfStates[iphip, ireg]             = NV[ireg]\n        params.densityOfStates[iphia, ireg]             = NAnion[ireg]\n\n        params.bandEdgeEnergy[iphin, ireg]              = EC[ireg]\n        params.bandEdgeEnergy[iphip, ireg]              = EV[ireg]\n        params.bandEdgeEnergy[iphia, ireg]              = EA[ireg]\n\n        params.mobility[iphin, ireg]                    = μn[ireg]\n        params.mobility[iphip, ireg]                    = μp[ireg]\n        params.mobility[iphia, ireg]                    = μa[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]    = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = trap_density!(iphin, ireg, data, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg] = trap_density!(iphip, ireg, data, EI[ireg])\n        params.recombinationAuger[iphin, ireg]          = Auger\n        params.recombinationAuger[iphip, ireg]          = Auger\n    end\n\n    # boundary region data\n    params.bDensityOfStates[iphin, bregionDonor]        = Nc_d\n    params.bDensityOfStates[iphip, bregionDonor]        = Nv_d\n\n    params.bDensityOfStates[iphin, bregionAcceptor]     = Nc_a\n    params.bDensityOfStates[iphip, bregionAcceptor]     = Nv_a\n\n    params.bBandEdgeEnergy[iphin, bregionDonor]         = Ec_d\n    params.bBandEdgeEnergy[iphip, bregionDonor]         = Ev_d\n\n    params.bBandEdgeEnergy[iphin, bregionAcceptor]      = Ec_a\n    params.bBandEdgeEnergy[iphip, bregionAcceptor]      = Ev_a\n\n    # interior doping\n    params.doping[iphin, regionDonor]                   = Nd\n    params.doping[iphia, regionIntrinsic]               = C0\n    params.doping[iphip, regionAcceptor]                = Na\n\n    # boundary doping\n    params.bDoping[iphip, bregionAcceptor]              = Na\n    params.bDoping[iphin, bregionDonor]                 = Nd\n\n    data.params                                         = params\n    ctsys                                               = System(grid, data, unknown_storage=unknown_storage)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    if plotting == true\n        ################################################################################\n        println(\"Plot electroneutral potential, band-edge energies and doping\")\n        ################################################################################\n        label_solution, label_density, label_energy, label_BEE = set_plotting_labels(data)\n\n        # add labels for anion vacancy\n        label_energy[1, iphia] = \"\\$E_a-q\\\\psi\\$\"; label_energy[2, iphia] = \"\\$ - q \\\\varphi_a\\$\"; label_BEE[iphia] = \"\\$E_a\\$\"\n        label_density[iphia]   = \"a\";              label_solution[iphia]  = \"\\$ \\\\varphi_a\\$\"\n\n        plot_energies(Plotter, grid, data, label_BEE)\n        Plotter.figure()\n        plot_doping(Plotter, grid, data, label_density)\n        Plotter.figure()\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define outer boundary conditions\")\n    end\n    ################################################################################\n\n    # set zero voltage ohmic contacts for electrons and holes at all outer boundaries.\n    set_contact!(ctsys, bregionAcceptor, Δu = 0.0)\n    set_contact!(ctsys, bregionDonor,    Δu = 0.0)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Newton solver\")\n    end\n    ################################################################################\n\n    control                   = NewtonControl()\n    control.verbose           = verbose\n    control.max_iterations    = 300\n    control.tol_absolute      = 1.0e-10\n    control.tol_relative      = 1.0e-10\n    control.handle_exceptions = true\n    control.tol_round         = 1.0e-10\n    control.max_round         = 5\n    control.damp_initial      = 0.5\n    control.damp_growth       = 1.61 # >= 1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # initialize solution and starting vectors\n    initialGuess  = unknowns(ctsys)\n    solution      = unknowns(ctsys)\n\n    solution      = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)\n\n    initialGuess .= solution\n\n    if plotting\n        plot_energies(Plotter, grid, data, solution, \"Equilibrium; \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution,\"Equilibrium; \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, grid, data, solution, \"Equilibrium; \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"IV Measurement loop\")\n    end\n    ################################################################################\n    data.calculationType = OutOfEquilibrium\n\n    # primary data for I-V scan protocol\n    scanrate             = 1.0 * V/s\n    number_tsteps        = 31\n    endVoltage           = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    tend                 = endVoltage/scanrate\n\n    # with fixed timestep sizes we can calculate the times a priori\n    tvalues              = range(0, stop = tend, length = number_tsteps)\n\n    # for saving I-V data\n    IV                   = zeros(0) # for IV values\n    biasValues           = zeros(0) # for bias values\n\n    for istep = 2:number_tsteps\n\n        t  = tvalues[istep]       # Actual time\n        Δu = t * scanrate         # Applied voltage\n        Δt = t - tvalues[istep-1] # Time step size\n\n        # Apply new voltage by setting non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: t = $(t)\")\n        end\n\n        # Solve time step problems with timestep Δt. initialGuess plays the role of the solution\n        # from last timestep\n        solve!(solution, initialGuess, ctsys, control  = control, tstep = Δt)\n\n        # get I-V data\n        current = get_current_val(ctsys, solution, initialGuess, Δt)\n\n        push!(IV, current)\n        push!(biasValues, Δu)\n\n        initialGuess .= solution\n\n    end # time loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    # here in res the biasValues and the corresponding current are stored.\n    # res = [biasValues IV];\n\n    if plotting\n        plot_energies(Plotter, grid, data, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage); \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution,\"bias \\$\\\\Delta u\\$ = $(endVoltage); \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, grid, data, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage); \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_solution)\n    end\n\n    testval = VoronoiFVM.norm(ctsys.fvmsys, solution, 2)\n    return testval\n\n    println(\"*** done\\n\")\n\nend #  main\n\nfunction test()\n    testval = 26.046765170194163\n    main(test = true, unknown_storage=:dense) ≈ testval  #&& main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex106_PSC_withIons_IVMeasurement/","page":"PSC device with ions and linear I-V scan protocol (1D).","title":"PSC device with ions and linear I-V scan protocol (1D).","text":"","category":"page"},{"location":"examples/Ex106_PSC_withIons_IVMeasurement/","page":"PSC device with ions and linear I-V scan protocol (1D).","title":"PSC device with ions and linear I-V scan protocol (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Ex101_PIN/#GaAs-diode-(1D).","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"","category":"section"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"We simulate charge transport in a GaAs pin diode, where we use the van Roosbroeck system of equations as charge transport model. The unknowns are given by the quasi Fermi potentials of electrons and holes varphi_n, varphi_p and the electric potential psi. The simulations are performed out of equilibrium and for the stationary problem.","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"module Ex101_PIN\n\nusing VoronoiFVM       # PDE solver with a FVM spatial discretization\nusing ChargeTransport  # drift-diffusion solver\nusing ExtendableGrids  # grid initializer\nusing GridVisualize    # grid visualizer\nusing PyPlot           # solution visualizer\n\n\n# This function is used to initialize the grid for a possible extension to other p-i-n devices.\nfunction initialize_pin_grid(refinementfactor, h_ndoping, h_intrinsic, h_pdoping)\n    coord_ndoping    = collect(range(0.0, stop = h_ndoping, length = 3 * refinementfactor))\n    coord_intrinsic  = collect(range(h_ndoping, stop = (h_ndoping + h_intrinsic), length = 3 * refinementfactor))\n    coord_pdoping    = collect(range((h_ndoping + h_intrinsic), stop = (h_ndoping + h_intrinsic + h_pdoping), length = 3 * refinementfactor))\n    coord            = glue(coord_ndoping, coord_intrinsic)\n    coord            = glue(coord, coord_pdoping)\n\n    return coord\nend\n\n\nfunction main(;n = 3, Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage=:sparse)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionAcceptor          = 1          # p doped region\n    regionIntrinsic         = 2          # intrinsic region\n    regionDonor             = 3          # n doped region\n    regions                 = [regionAcceptor, regionIntrinsic, regionDonor]\n    numberOfRegions         = length(regions)\n\n    # boundary region numbers\n    bregionAcceptor         = 1\n    bregionDonor            = 2\n    bregions                = [bregionAcceptor, bregionDonor]\n    numberOfBoundaryRegions = length(bregions)\n\n    # grid\n    refinementfactor        = 2^(n-1)\n    h_pdoping               = 2.0    * μm\n    h_intrinsic             = 2.0    * μm\n    h_ndoping               = 2.0    * μm\n    w_device                = 0.5    * μm  # width of device\n    z_device                = 1.0e-4 * cm  # depth of device\n    coord                   = initialize_pin_grid(refinementfactor,\n                                                  h_pdoping,\n                                                  h_intrinsic,\n                                                  h_ndoping)\n\n    grid                    = simplexgrid(coord)\n\n    # cellmask! for defining the subregions and assigning region number\n    cellmask!(grid, [0.0 * μm],                [h_pdoping],                           regionAcceptor)  # p-doped region = 1\n    cellmask!(grid, [h_pdoping],               [h_pdoping + h_intrinsic],             regionIntrinsic) # intrinsic region = 2\n    cellmask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic + h_ndoping], regionDonor)     # n-doped region = 3\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend=:lt)\n        Plotter.title(\"Grid\")\n        Plotter.figure()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin            = 1 # electron quasi Fermi potential\n    iphip            = 2 # hole quasi Fermi potential\n    numberOfCarriers = 2","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"We define the physical data.","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    Ec               = 1.424                *  eV\n    Ev               = 0.0                  *  eV\n    Nc               = 4.351959895879690e17 / (cm^3)\n    Nv               = 9.139615903601645e18 / (cm^3)\n    mun              = 8500.0               * (cm^2) / (V * s)\n    mup              = 400.0                * (cm^2) / (V * s)\n    εr               = 12.9                 *  1.0              # relative dielectric permittivity of GAs\n    T                = 300.0                *  K\n\n    # recombination parameters\n    Auger            = 1.0e-29              * cm^6 / s\n    SRH_TrapDensity  = 1.0e10               / cm^3\n    SRH_LifeTime     = 1.0                  * ns\n    Radiative        = 1.0e-10              * cm^3 / s\n\n    # doping\n    dopingFactorNd   = 1.0\n    dopingFactorNa   = 0.46\n    Nd               = dopingFactorNd * Nc\n    Na               = dopingFactorNa * Nv\n\n    # intrinsic concentration\n    ni               = sqrt(Nc * Nv) * exp(-(Ec - Ev) / (2 * kB * T))\n\n    # contact voltage: we impose an applied voltage only on one boundary.\n    # At the other boundary the applied voltage is zero.\n    voltageAcceptor  = 1.5                  * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"We initialize the Data instance and fill in predefined data.","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    data                               = Data(grid, numberOfCarriers)\n\n    # Following variable declares, if we want to solve stationary or transient problem\n    data.modelType                     = Stationary\n\n    # Following choices are possible for F: Boltzmann, FermiDiracOneHalfBednarczyk,\n    # FermiDiracOneHalfTeSCA, FermiDiracMinusOne, Blakemore\n    data.F                            .= Boltzmann\n\n    # Here, we need to specify which numbers are associated with electron and hole quasi\n    # Fermi potential. Further, the desired recombination processes can be chosen here.\n    # Note that, if you choose a SRH recombination you can further specify a transient SRH\n    # recombination by the method enable_traps! and adjusting the modelType. Otherwise, by\n    # default we use the stationary model for this type of recombination.\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = true,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Following choices are possible for boundary model: For contacts currently only\n    # OhmicContact and SchottkyContact are possible. For inner boundaries we have\n    # InterfaceModelNone, InterfaceModelSurfaceReco.\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n\n    # Following choices are possible for the flux discretization scheme: ScharfetterGummel,\n    # ScharfetterGummelGraded, ExcessChemicalPotential, ExcessChemicalPotentialGraded,\n    # DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation             = ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"Define the Params struct. Params contains all necessary physical parameters. If one wants to simulate space-dependent variables, one additionally needs to generate a ParamsNodal struct, see Ex102.","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    params                                              = Params(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = -1\n    params.chargeNumbers[iphip]                         =  1\n\n    for ibreg in 1:numberOfBoundaryRegions  # boundary region data\n        params.bDensityOfStates[iphin, ibreg]           = Nc\n        params.bDensityOfStates[iphip, ibreg]           = Nv\n        params.bBandEdgeEnergy[iphin, ibreg]            = Ec\n        params.bBandEdgeEnergy[iphip, ibreg]            = Ev\n    end\n\n    for ireg in 1:numberOfRegions           # interior region data\n\n        params.dielectricConstant[ireg]                 = εr\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = Nc\n        params.densityOfStates[iphip, ireg]             = Nv\n        params.bandEdgeEnergy[iphin, ireg]              = Ec\n        params.bandEdgeEnergy[iphip, ireg]              = Ev\n        params.mobility[iphin, ireg]                    = mun\n        params.mobility[iphip, ireg]                    = mup\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = Radiative\n        params.recombinationSRHLifetime[iphin, ireg]    = SRH_LifeTime\n        params.recombinationSRHLifetime[iphip, ireg]    = SRH_LifeTime\n        params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity\n        params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity\n        params.recombinationAuger[iphin, ireg]          = Auger\n        params.recombinationAuger[iphip, ireg]          = Auger\n\n    end\n\n    # interior doping\n    params.doping[iphin, regionDonor]                   = Nd     # data.doping   = [0.0  Na;\n    params.doping[iphin, regionIntrinsic]               = ni     #                  ni   0.0;\n    params.doping[iphip, regionIntrinsic]               = 0.0    #                  Nd  0.0]\n    params.doping[iphip, regionAcceptor]                = Na\n\n    # boundary doping\n    params.bDoping[iphin, bregionDonor]                 = Nd     # data.bDoping  = [0.0  Na;\n    params.bDoping[iphip, bregionAcceptor]              = Na     #                  Nd  0.0]","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"Region dependent params is now a substruct of data which is again a substruct of the system and will be parsed in next step.","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    data.params                                         = params","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"In the last step, we initialize our system with previous data which is likewise dependent on the parameters. It is important that this is in the end, otherwise our VoronoiFVMSys is not dependent on the data we initialized but rather on default data.","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    ctsys                                               = System(grid, data, unknown_storage=unknown_storage)\n\n    if test == false\n        # Here we cn show region dependent physical parameters. show_params() only supports\n        # region dependent parameters, but, if one wishes to print nodal dependent parameters,\n        # currently this is possible with println(ctsys.data.paramsnodal). We neglected here,\n        # since in most applications where the numberOfNodes is >> 10 this would results in a\n        # large output in the terminal.\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define outer boundary conditions\")\n    end\n    ################################################################################\n\n    # We set zero voltage ohmic contacts for each charge carrier at all outer boundaries\n    # for the equilibrium calculations.\n    set_contact!(ctsys, bregionAcceptor, Δu = 0.0)\n    set_contact!(ctsys, bregionDonor,    Δu = 0.0)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    if plotting == true\n        ################################################################################\n        println(\"Plot electroneutral potential, band-edge energies and doping\")\n        ################################################################################\n        # set legend for plotting routines. Either you can use the predefined labels or write your own.\n        label_solution, label_density, label_energy, label_BEE = set_plotting_labels(data)\n\n        psi0 = electroNeutralSolution!(grid, data)\n        plot_energies(Plotter, grid, data, label_BEE)\n        Plotter.figure()\n        plot_doping(Plotter, grid, data, label_density)\n        Plotter.figure()\n        plot_electroNeutralSolutionBoltzmann(Plotter, grid, psi0, ;plotGridpoints=true)\n        Plotter.figure()\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Newton solver\")\n    end\n    ################################################################################\n\n    control                   = NewtonControl()\n    control.verbose           = verbose\n    control.max_iterations    = 250\n    control.tol_absolute      = 1.0e-14\n    control.tol_relative      = 1.0e-14\n    control.handle_exceptions = true\n    control.tol_round         = 1.0e-8\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    control.damp_initial = 0.5\n    control.damp_growth  = 1.2 # >= 1\n    control.max_round    = 3\n\n    # initialize solution and starting vectors\n    initialGuess         = unknowns(ctsys)\n    solution             = unknowns(ctsys)\n\n    solution             = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)\n\n    initialGuess        .= solution\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"Set calculationType to OutOfEquilibrium for starting with respective simulation.","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    data.calculationType = OutOfEquilibrium\n\n    maxBias              = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    biasValues           = range(0, stop = maxBias, length = 32)\n    IV                   = zeros(0)\n\n    for Δu in biasValues\n\n        if test == false\n            println(\"Δu  = \", Δu)\n        end\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        solve!(solution, initialGuess, ctsys, control = control, tstep = Inf)\n\n        initialGuess .= solution\n\n        # get I-V data\n        current = get_current_val(ctsys, solution)\n\n        push!(IV,  abs.(w_device * z_device * ( current)) )\n\n    end # bias loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    # plot solution and IV curve\n    if plotting\n        plot_energies(Plotter, grid, data, solution,  \"Applied voltage Δu = $(biasValues[end])\", label_energy,   plotGridpoints = false)\n        Plotter.figure()\n        plot_solution(Plotter, grid, data, solution,  \"Applied voltage Δu = $(biasValues[end])\", label_solution, plotGridpoints = true)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution, \"Applied voltage Δu = $(biasValues[end])\", label_density,  plotGridpoints = true)\n        Plotter.figure()\n        plot_IV(Plotter, biasValues,IV,  \"Applied voltage Δu = $(biasValues[end])\", plotGridpoints = true)\n    end\n\n    testval = solution[15]\n    return testval\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\nend #  main\n\nfunction test()\n    testval = 1.5068426773059806\n    main(test = true, unknown_storage=:dense) ≈ testval && main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when the PIN module has successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"","category":"page"},{"location":"examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Ex108_PSC_BeerLambert_Generation/#PSC-device-with-Beer-Lambert-generation-rate-(1D).","page":"PSC device with Beer-Lambert generation rate (1D).","title":"PSC device with Beer-Lambert generation rate (1D).","text":"","category":"section"},{"location":"examples/Ex108_PSC_BeerLambert_Generation/","page":"PSC device with Beer-Lambert generation rate (1D).","title":"PSC device with Beer-Lambert generation rate (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex108_PSC_BeerLambert_Generation/","page":"PSC device with Beer-Lambert generation rate (1D).","title":"PSC device with Beer-Lambert generation rate (1D).","text":"Simulating a three layer PSC device SiO2| MAPI | SiO2 with mobile ions where the ion vacancy accumulation is limited by the Fermi-Dirac integral of order -1. The simulations are performed out of equilibrium, time-dependent and with abrupt interfaces. A linear I-V measurement protocol is included and the corresponding solution vectors after the scan can be depicted.","category":"page"},{"location":"examples/Ex108_PSC_BeerLambert_Generation/","page":"PSC device with Beer-Lambert generation rate (1D).","title":"PSC device with Beer-Lambert generation rate (1D).","text":"The parameters can be found in Table S.13, https://arxiv.org/abs/2009.04384. Or here: https://github.com/barnesgroupICL/Driftfusion/blob/Methods-IonMonger-Comparison/Inputfiles/IonMongerdefault_bulk.csv","category":"page"},{"location":"examples/Ex108_PSC_BeerLambert_Generation/","page":"PSC device with Beer-Lambert generation rate (1D).","title":"PSC device with Beer-Lambert generation rate (1D).","text":"module Ex108_PSC_BeerLambert_Generation\n\nusing VoronoiFVM\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing PyPlot\n\nfunction main(;n = 2, Plotter = PyPlot, plotting = false, verbose = false, test = false)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n    # region numbers\n    regionDonor     = 1                           # n doped region\n    regionIntrinsic = 2                           # intrinsic region\n    regionAcceptor  = 3                           # p doped region\n    regions         = [regionDonor, regionIntrinsic, regionAcceptor]\n    numberOfRegions = length(regions)\n\n    # boundary region numbers\n    bregionDonor    = 1\n    bregionAcceptor = 2\n\n    # grid\n    h_ndoping       = 9.90e-6 * cm\n    h_intrinsic     = 4.00e-5 * cm + 2.0e-7 * cm\n    h_pdoping       = 1.99e-5 * cm\n    heightLayers    = [h_ndoping,\n                       h_ndoping + h_intrinsic,\n                       h_ndoping + h_intrinsic + h_pdoping]\n\n    x0              = 0.0 * cm\n    δ               = 4*n        # the larger, the finer the mesh\n    t               = 0.5*(cm)/δ # tolerance for geomspace and glue (with factor 10)\n    k               = 1.5        # the closer to 1, the closer to the boundary geomspace\n\n    coord_n_u       = collect(range(x0, h_ndoping/2, step=h_ndoping/(0.8*δ)))\n    coord_n_g       = geomspace(h_ndoping/2,\n                                h_ndoping,\n                                h_ndoping/(0.7*δ),\n                                h_ndoping/(1.1*δ),\n                                tol=t)\n    coord_i_g1      = geomspace(h_ndoping,\n                                h_ndoping+h_intrinsic/k,\n                                h_intrinsic/(2.8*δ),\n                                h_intrinsic/(2.1*δ),\n                                tol=t)\n    coord_i_g2      = geomspace(h_ndoping+h_intrinsic/k,\n                                h_ndoping+h_intrinsic,\n                                h_intrinsic/(2.1*δ),\n                                h_intrinsic/(2.8*δ),\n                                tol=t)\n    coord_p_g       = geomspace(h_ndoping+h_intrinsic,\n                                h_ndoping+h_intrinsic+h_pdoping/2,\n                                h_pdoping/(1.6*δ),\n                                h_pdoping/(1.6*δ),\n                                tol=t)\n    coord_p_u       = collect(range(h_ndoping+h_intrinsic+h_pdoping/2, h_ndoping+h_intrinsic+h_pdoping, step=h_pdoping/(1.3*δ)))\n\n    coord           = glue(coord_n_u, coord_n_g,  tol=10*t)\n    coord           = glue(coord,     coord_i_g1, tol=10*t)\n    coord           = glue(coord,     coord_i_g2, tol=10*t)\n    coord           = glue(coord,     coord_p_g,  tol=10*t)\n    coord           = glue(coord,     coord_p_u,  tol=10*t)\n    grid            = ExtendableGrids.simplexgrid(coord)\n\n    # set different regions in grid, doping profiles do not intersect\n    cellmask!(grid, [0.0 * μm],        [heightLayers[1]], regionDonor, tol = 1.0e-18)     # n-doped region   = 1\n    cellmask!(grid, [heightLayers[1]], [heightLayers[2]], regionIntrinsic, tol = 1.0e-18) # intrinsic region = 2\n    cellmask!(grid, [heightLayers[2]], [heightLayers[3]], regionAcceptor, tol = 1.0e-18)  # p-doped region   = 3\n\n    if plotting\n        gridplot(grid, Plotter = Plotter)\n        Plotter.title(\"Grid\")\n        Plotter.figure()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin              = 1 # electron quasi Fermi potential\n    iphip              = 2 # hole quasi Fermi potential\n    iphia              = 3 # anion vacancy quasi Fermi potential\n\n    numberOfCarriers   = 3 # electrons, holes and anion vacancies\n\n    # temperature\n    T                  = 298.0                 *  K\n\n    # band edge energies\n    Ec_d               = -4.0                  *  eV\n    Ev_d               = -5.8                  *  eV\n\n    Ec_i               = -3.7                  *  eV\n    Ev_i               = -5.4                  *  eV\n\n    Ec_a               = -3.4                  *  eV\n    Ev_a               = -5.1                  *  eV\n\n    # ############ adjust Na, Ea for anion vacancies here ###########\n    Nanion             = 1.0e21                / (cm^3)\n    Ea_i               = -4.45                 *  eV\n    # ############ adjust Na, Ea for anion vacancies here ###########\n\n    EC                 = [Ec_d, Ec_i, Ec_a]\n    EV                 = [Ev_d, Ev_i, Ev_a]\n    EA                 = [0.0,  Ea_i,  0.0]\n\n    # effective densities of state\n    Nc_d               = 5.0e19                / (cm^3)\n    Nv_d               = 5.0e19                / (cm^3)\n\n    Nc_i               = 8.1e18                / (cm^3)\n    Nv_i               = 5.8e18                / (cm^3)\n\n    Nc_a               = 5.0e19                / (cm^3)\n    Nv_a               = 5.0e19                / (cm^3)\n\n    NC                 = [Nc_d, Nc_i,  Nc_a]\n    NV                 = [Nv_d, Nv_i,  Nv_a]\n    NAnion             = [0.0,  Nanion, 0.0]\n\n    # mobilities\n    μn_d             = 3.89                    * (cm^2) / (V * s)\n    μp_d             = 3.89                    * (cm^2) / (V * s)\n\n    μn_i             = 6.62e1                  * (cm^2) / (V * s)\n    μp_i             = 6.62e1                  * (cm^2) / (V * s)\n\n    μa_i             = 3.93e-12                * (cm^2) / (V * s)\n\n    μn_a             = 3.89e-1                 * (cm^2) / (V * s)\n    μp_a             = 3.89e-1                 * (cm^2) / (V * s)\n\n    μn               = [μn_d, μn_i, μn_a]\n    μp               = [μp_d, μp_i, μp_a]\n    μa               = [0.0,  μa_i, 0.0 ]\n\n    # relative dielectric permittivity\n    ε_d                = 10.0                  *  1.0\n    ε_i                = 24.1                  *  1.0\n    ε_a                = 3.0                   *  1.0\n\n    ε                  = [ε_d, ε_i, ε_a]\n\n    # radiative recombination\n    r0_d               = 0.0e0                 * cm^3 / s\n    r0_i               = 0.0e0                 * cm^3 / s\n    r0_a               = 0.0e0                 * cm^3 / s\n\n    r0                 = [r0_d, r0_i, r0_a]\n\n    # life times and trap densities\n    τn_d               = 1.0e100               * s\n    τp_d               = 1.0e100               * s\n\n    τn_i               = 3.0e-9                * s\n    τp_i               = 3.0e-7                * s\n    τn_a               = τn_d\n    τp_a               = τp_d\n    τn                 = [τn_d, τn_i, τn_a]\n    τp                 = [τp_d, τp_i, τp_a]\n\n    # SRH trap energies\n    Ei_d               = -5.0                  * eV\n    Ei_i               = -4.55                 * eV\n    Ei_a               = -4.1                  * eV\n\n    EI                 = [Ei_d, Ei_i, Ei_a]\n\n    # Auger recombination\n    Auger              = 0.0\n\n    # generation\n    photonflux_i       = 1.4e21                / (m^2 * s)\n    absorption_i       = 1.3e7                 / m\n    incidentPhotonFlux = [0.0, photonflux_i, 0.0]\n    absorption         = [0.0, absorption_i, 0.0]\n    generationPeak     = h_ndoping\n\n    # doping\n    Nd                 = 1.00e18               / (cm^3)\n    Na                 = 1.00e18               / (cm^3)\n    C0                 = 1.6e19                / (cm^3)\n\n    # contact voltage\n    voltageAcceptor    = 1.2                   * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    data                               = Data(grid, numberOfCarriers)\n    data.modelType                     = Transient\n    data.F                             = [Boltzmann, Boltzmann, FermiDiracMinusOne]\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = true,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n    data.generationModel               = GenerationBeerLambert\n    data.enableIonicCarriers           = enable_ionic_carriers(ionic_carriers = [iphia], regions = [regionIntrinsic])\n    data.fluxApproximation             = ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                              = Params(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = -1\n    params.chargeNumbers[iphip]                         =  1\n    params.chargeNumbers[iphia]                         =  1\n\n    for ireg in 1:numberOfRegions # interior region data\n\n        params.dielectricConstant[ireg]                 = ε[ireg]\n\n        # effective DOS, band edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = NC[ireg]\n        params.densityOfStates[iphip, ireg]             = NV[ireg]\n        params.densityOfStates[iphia, ireg]             = NAnion[ireg]\n\n        params.bandEdgeEnergy[iphin, ireg]              = EC[ireg]\n        params.bandEdgeEnergy[iphip, ireg]              = EV[ireg]\n        params.bandEdgeEnergy[iphia, ireg]              = EA[ireg]\n\n        params.mobility[iphin, ireg]                    = μn[ireg]\n        params.mobility[iphip, ireg]                    = μp[ireg]\n        params.mobility[iphia, ireg]                    = μa[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]    = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = trap_density!(iphin, ireg, data, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg] = trap_density!(iphip, ireg, data, EI[ireg])\n        params.recombinationAuger[iphin, ireg]          = Auger\n        params.recombinationAuger[iphip, ireg]          = Auger\n\n        # generation parameters\n        params.generationIncidentPhotonFlux[ireg]       = incidentPhotonFlux[ireg]\n        params.generationAbsorption[ireg]               = absorption[ireg]\n    end","category":"page"},{"location":"examples/Ex108_PSC_BeerLambert_Generation/","page":"PSC device with Beer-Lambert generation rate (1D).","title":"PSC device with Beer-Lambert generation rate (1D).","text":"parameter which passes the shift information in the Beer-Lambert generation","category":"page"},{"location":"examples/Ex108_PSC_BeerLambert_Generation/","page":"PSC device with Beer-Lambert generation rate (1D).","title":"PSC device with Beer-Lambert generation rate (1D).","text":"    params.generationPeak                               = generationPeak\n\n    # boundary region data\n    params.bDensityOfStates[iphin, bregionDonor]        = Nc_d\n    params.bDensityOfStates[iphip, bregionDonor]        = Nv_d\n\n    params.bDensityOfStates[iphin, bregionAcceptor]     = Nc_a\n    params.bDensityOfStates[iphip, bregionAcceptor]     = Nv_a\n\n    params.bBandEdgeEnergy[iphin, bregionDonor]         = Ec_d\n    params.bBandEdgeEnergy[iphip, bregionDonor]         = Ev_d\n\n    params.bBandEdgeEnergy[iphin, bregionAcceptor]      = Ec_a\n    params.bBandEdgeEnergy[iphip, bregionAcceptor]      = Ev_a\n\n    # interior doping\n    params.doping[iphin, regionDonor]                   = Nd\n    params.doping[iphia, regionIntrinsic]               = C0\n    params.doping[iphip, regionAcceptor]                = Na\n\n    # boundary doping\n    params.bDoping[iphip, bregionAcceptor]              = Na\n    params.bDoping[iphin, bregionDonor]                 = Nd\n\n    data.params                                         = params\n    ctsys                                               = System(grid, data, unknown_storage=:dense)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define outer boundary conditions\")\n    end\n    ################################################################################\n\n    # set zero voltage ohmic contacts for electrons and holes at all outer boundaries.\n    set_contact!(ctsys, bregionAcceptor, Δu = 0.0)\n    set_contact!(ctsys, bregionDonor,    Δu = 0.0)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Newton solver\")\n    end\n    ################################################################################\n\n    control                   = NewtonControl()\n    control.verbose           = verbose\n    control.max_iterations    = 300\n    control.tol_absolute      = 1.0e-10\n    control.tol_relative      = 1.0e-10\n    control.handle_exceptions = true\n    control.tol_round         = 1.0e-10\n    control.max_round         = 5\n    control.damp_initial      = 0.5\n    control.damp_growth       = 1.61 # >= 1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # initialize solution and starting vectors\n    initialGuess  = unknowns(ctsys)\n    solution      = unknowns(ctsys)\n\n    solution      = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)\n\n    initialGuess .= solution\n\n    if plotting\n        label_solution, label_density, label_energy, label_BEE = set_plotting_labels(data)\n\n        # add labels for anion vacancy\n        label_energy[1, iphia] = \"\\$E_a-q\\\\psi\\$\"; label_energy[2, iphia] = \"\\$ - q \\\\varphi_a\\$\"; label_BEE[iphia] = \"\\$E_a\\$\"\n        label_density[iphia]   = \"a\";              label_solution[iphia]  = \"\\$ \\\\varphi_a\\$\"\n\n        plot_energies(Plotter, grid, data, solution, \"Equilibrium\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution,\"Equilibrium\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, grid, data, solution, \"Equilibrium\", label_solution)\n        Plotter.figure()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Loop for generation\")\n    end\n    ################################################################################\n\n    data.calculationType = OutOfEquilibrium","category":"page"},{"location":"examples/Ex108_PSC_BeerLambert_Generation/","page":"PSC device with Beer-Lambert generation rate (1D).","title":"PSC device with Beer-Lambert generation rate (1D).","text":"these values are needed for putting the generation slightly on","category":"page"},{"location":"examples/Ex108_PSC_BeerLambert_Generation/","page":"PSC device with Beer-Lambert generation rate (1D).","title":"PSC device with Beer-Lambert generation rate (1D).","text":"    I      = collect(20:-1:0.0)\n    LAMBDA = 10 .^ (-I)\n\n    for istep = 1:length(I)-1\n\n        # turn slowly generation on\n        data.λ2   = LAMBDA[istep + 1]\n\n        if test == false\n            println(\"increase generation with λ2 = $(data.λ2)\")\n        end\n\n        solve!(solution, initialGuess, ctsys, control  = control, tstep = Inf)\n\n        initialGuess .= solution\n\n    end # generation loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"IV Measurement loop\")\n    end\n    ################################################################################\n\n    # primary data for I-V scan protocol\n    scanrate      = 1.0 * V/s\n    number_tsteps = 41\n    endVoltage    = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    tend          = endVoltage/scanrate\n    tvalues       = range(0, stop = tend, length = number_tsteps)\n\n    # for saving I-V data\n    IV            = zeros(0) # for IV values\n    biasValues    = zeros(0) # for bias values\n\n    for istep = 2:number_tsteps\n\n        t  = tvalues[istep]       # Actual time\n        Δu = t * scanrate         # Applied voltage\n        Δt = t - tvalues[istep-1] # Time step size\n\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: t = $(t)\")\n        end\n\n        solve!(solution, initialGuess, ctsys, control  = control, tstep = Δt)\n\n        # get I-V data\n        current = get_current_val(ctsys, solution, initialGuess, Δt)\n\n        push!(IV, current)\n        push!(biasValues, Δu)\n\n        initialGuess .= solution\n\n    end # time loop\n\n    if plotting\n        plot_energies(Plotter, grid, data, solution, \"bias \\$\\\\Delta u\\$ = $(biasValues[end])\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution,\"bias \\$\\\\Delta u\\$ = $(biasValues[end])\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, grid, data, solution, \"bias \\$\\\\Delta u\\$ = $(biasValues[end])\", label_solution)\n        Plotter.figure()\n        plot_IV(Plotter, biasValues, -IV, \"bias \\$\\\\Delta u\\$ = $(biasValues[end])\", plotGridpoints = true)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = VoronoiFVM.norm(ctsys.fvmsys, solution, 2)\n    return testval\n\n    println(\"*** done\\n\")\n\nend #  main\n\nfunction test()\n    testval = 26.083529957739483\n    main(test = true) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex108_PSC_BeerLambert_Generation/","page":"PSC device with Beer-Lambert generation rate (1D).","title":"PSC device with Beer-Lambert generation rate (1D).","text":"","category":"page"},{"location":"examples/Ex108_PSC_BeerLambert_Generation/","page":"PSC device with Beer-Lambert generation rate (1D).","title":"PSC device with Beer-Lambert generation rate (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"plot/#Plotting-Routines","page":"Plotting Routines","title":"Plotting Routines","text":"","category":"section"},{"location":"plot/","page":"Plotting Routines","title":"Plotting Routines","text":"The same design as in VoronoiFVM.jl is used: To avoid dependencies for this package, the plot methods defined in this package have as their first argument the module of the plotting package used.","category":"page"},{"location":"plot/","page":"Plotting Routines","title":"Plotting Routines","text":"Currently, only PyPlot was tested.","category":"page"},{"location":"examples/Ex201_PSC_tensorGrid/#PSC-device-on-2D-domain-(Tensor-grid).","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"","category":"section"},{"location":"examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"(source code)","category":"page"},{"location":"examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"Simulating a three layer PSC device Pedot| MAPI | PCBM with mobile ions. The simulations are performed in 2D on a tensor grid, out of equilibrium and with abrupt interfaces.","category":"page"},{"location":"examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"The paramters are from Calado et al.: https://github.com/barnesgroupICL/Driftfusion/blob/master/Inputfiles/pedotpssmapi_pcbm.csv. (with adjustments on layer lengths)","category":"page"},{"location":"examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"module Ex201_PSC_tensorGrid\n\nusing VoronoiFVM\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing PyPlot\n\nfunction main(;n = 3, Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage=:dense)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionAcceptor  = 1                           # p doped region\n    regionIntrinsic = 2                           # intrinsic region\n    regionDonor     = 3                           # n doped region\n    regions         = [regionAcceptor, regionIntrinsic, regionDonor]\n    numberOfRegions = length(regions)\n\n    # boundary region numbers\n    bregionAcceptor = 1\n    bregionDonor    = 2\n    bregionNoFlux   = 3\n\n    # grid\n    h_pdoping       = 3.00e-6 * cm + 1.0e-7 *cm\n    h_intrinsic     = 3.00e-5 * cm\n    h_ndoping       = 8.50e-6 * cm + 1.0e-7 *cm\n    height          = 5.00e-6 * cm\n\n    x0              = 0.0 * cm\n    δ               = 3*n        # the larger, the finer the mesh\n    t               = 0.5*(cm)/δ # tolerance for geomspace and glue (with factor 10)\n    k               = 1.5        # the closer to 1, the closer to the boundary geomspace works\n\n    coord_p_u       = collect(range(x0, h_pdoping/2, step=h_pdoping/(0.3*δ)))\n    coord_p_g       = geomspace(h_pdoping/2,\n                                h_pdoping,\n                                h_pdoping/(0.4*δ),\n                                h_pdoping/(1.1*δ),\n                                tol=t)\n    coord_i_g1      = geomspace(h_pdoping,\n                                h_pdoping+h_intrinsic/k,\n                                h_intrinsic/(6.8*δ),\n                                h_intrinsic/(0.8*δ),\n                                tol=t)\n    coord_i_g2      = geomspace(h_pdoping+h_intrinsic/k,\n                                h_pdoping+h_intrinsic,\n                                h_intrinsic/(0.8*δ),\n                                h_intrinsic/(7.8*δ),\n                                tol=t)\n    coord_n_g       = geomspace(h_pdoping+h_intrinsic,\n                                h_pdoping+h_intrinsic+h_ndoping/2,\n                                h_ndoping/(2.8*δ),\n                                h_ndoping/(0.5*δ),\n                                tol=t)\n    coord_n_u       = collect(range(h_pdoping+h_intrinsic+h_ndoping/2, h_pdoping+h_intrinsic+h_ndoping, step=h_pdoping/(0.1*δ)))\n\n    coord           = glue(coord_p_u,coord_p_g,  tol=10*t)\n    coord           = glue(coord,    coord_i_g1, tol=10*t)\n    coord           = glue(coord,    coord_i_g2, tol=10*t)\n    coord           = glue(coord,    coord_n_g,  tol=10*t)\n    coord_length    = glue(coord,    coord_n_u,  tol=10*t)\n\n    height_L        = geomspace(0.0, height/2, height/(0.5*δ), height/(0.5*δ))\n    height_R        = geomspace(height/2, height, height/(0.5*δ), height/(0.5*δ))\n    coord_height    = glue(height_L, height_R, tol = 10*t)\n\n    grid            = simplexgrid(coord_length, coord_height)\n\n    # specify inner regions\n    cellmask!(grid, [0.0, 0.0],                     [h_pdoping, height],                           regionAcceptor, tol = 1.0e-18)  # p-doped region   = 1\n    cellmask!(grid, [h_pdoping, 0.0],               [h_pdoping + h_intrinsic, height],             regionIntrinsic, tol = 1.0e-18) # intrinsic region = 2\n    cellmask!(grid, [h_pdoping + h_intrinsic, 0.0], [h_pdoping + h_intrinsic + h_ndoping, height], regionDonor, tol = 1.0e-18)     # n-doped region   = 3\n\n    # specifiy outer regions\n    # metal interfaces\n    bfacemask!(grid, [0.0, 0.0], [0.0, height], bregionAcceptor) # BregionNumber = 1\n    bfacemask!(grid, [h_pdoping + h_intrinsic + h_ndoping, 0.0], [h_pdoping + h_intrinsic + h_ndoping, height], bregionDonor) # BregionNumber = 2\n\n    # no flux interfaces [xmin, ymin], [xmax, ymax]\n    bfacemask!(grid, [0.0, 0.0], [h_pdoping + h_intrinsic + h_ndoping, 0.0], bregionNoFlux) # BregionNumber = 3\n    bfacemask!(grid, [0.0, height], [h_pdoping + h_intrinsic + h_ndoping, height], bregionNoFlux) # # BregionNumber = 3\n\n    if plotting\n        gridplot(grid, Plotter= Plotter, resolution=(600,400),linewidth=0.5, legend=:lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin            = 1 # electron quasi Fermi potential\n    iphip            = 2 # hole quasi Fermi potential\n    iphia            = 3 # anion vacancy quasi Fermi potential\n    numberOfCarriers = 3\n\n    # temperature\n    T                = 300.0                 *  K\n\n    # band edge energies\n    Ec_a             = -3.0                  *  eV\n    Ev_a             = -5.1                  *  eV\n\n    Ec_i             = -3.8                  *  eV\n    Ev_i             = -5.4                  *  eV\n\n    Ec_d             = -3.8                  *  eV\n    Ev_d             = -6.2                  *  eV\n\n    EC               = [Ec_a, Ec_i, Ec_d]\n    EV               = [Ev_a, Ev_i, Ev_d]\n\n    # effective densities of state\n    Nc_a             = 1.0e20                / (cm^3)\n    Nv_a             = 1.0e20                / (cm^3)\n\n    Nc_i             = 1.0e19                / (cm^3)\n    Nv_i             = 1.0e19                / (cm^3)\n\n    # ############ adjust Na, Ea for anion vacancies here ###########\n    Nanion           = 1.0e18                / (cm^3)\n    Ea_i             = -4.4                  *  eV\n    # for the labels in the figures\n    textEa           = Ea_i./eV\n    textNa           = Nanion.*cm^3\n    # ############ adjust Na, Ea for anion vacancies here ###########\n    EA               = [0.0,  Ea_i,  0.0]\n\n    Nc_d             = 1.0e19                / (cm^3)\n    Nv_d             = 1.0e19                / (cm^3)\n\n    NC               = [Nc_a, Nc_i, Nc_d]\n    NV               = [Nv_a, Nv_i, Nv_d]\n    NAnion           = [0.0,  Nanion, 0.0]\n\n    # mobilities\n    μn_a             = 0.1                   * (cm^2) / (V * s)\n    μp_a             = 0.1                   * (cm^2) / (V * s)\n\n    μn_i             = 2.00e1                * (cm^2) / (V * s)\n    μp_i             = 2.00e1                * (cm^2) / (V * s)\n    μa_i             = 1.00e-10              * (cm^2) / (V * s)\n\n    μn_d             = 1.0e-3                * (cm^2) / (V * s)\n    μp_d             = 1.0e-3                * (cm^2) / (V * s)\n\n    μn               = [μn_a, μn_i, μn_d]\n    μp               = [μp_a, μp_i, μp_d]\n    μa               = [0.0,  μa_i, 0.0 ]\n\n    # relative dielectric permittivity\n    ε_a              = 4.0                   *  1.0\n    ε_i              = 23.0                  *  1.0\n    ε_d              = 3.0                   *  1.0\n\n    ε                = [ε_a, ε_i, ε_d]\n\n    # radiative recombination\n    r0_a             = 6.3e-11               * cm^3 / s\n    r0_i             = 3.6e-12               * cm^3 / s\n    r0_d             = 6.8e-11               * cm^3 / s\n\n    r0               = [r0_a, r0_i, r0_d]\n\n    # life times and trap densities\n    τn_a             = 1.0e-6                * s\n    τp_a             = 1.0e-6                * s\n\n    τn_i             = 1.0e-7                * s\n    τp_i             = 1.0e-7                * s\n    τn_d             = τn_a\n    τp_d             = τp_a\n\n    τn               = [τn_a, τn_i, τn_d]\n    τp               = [τp_a, τp_i, τp_d]\n\n    # SRH trap energies (needed for calculation of trap_density! (SRH))\n    Ei_a             = -4.05                * eV\n    Ei_i             = -4.60                * eV\n    Ei_d             = -5.00                * eV\n\n    EI               = [Ei_a, Ei_i, Ei_d]\n\n    # Auger recombination\n    Auger            = 0.0\n\n    # doping\n    Nd               = 2.089649130192123e17 / (cm^3)\n    Na               = 4.529587947185444e18 / (cm^3)\n    C0               = 1.0e18               / (cm^3)\n\n    # contact voltage\n    voltageAcceptor  = 1.0                  * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in data\n    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Transient\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F                             = [Boltzmann, Boltzmann, FermiDiracMinusOne]\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = true,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceModelNone,\n    # InterfaceModelSurfaceReco (inner boundary).\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n\n    # Present ionic vacancies in perovskite layer\n    data.enableIonicCarriers           = enable_ionic_carriers(ionic_carriers = [iphia], regions = [regionIntrinsic])\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation             = ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                              = Params(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = -1\n    params.chargeNumbers[iphip]                         =  1\n    params.chargeNumbers[iphia]                         =  1\n\n    # boundary region data\n    params.bDensityOfStates[iphin, bregionDonor]        = Nc_d\n    params.bDensityOfStates[iphip, bregionDonor]        = Nv_d\n\n    params.bDensityOfStates[iphin, bregionAcceptor]     = Nc_a\n    params.bDensityOfStates[iphip, bregionAcceptor]     = Nv_a\n\n    params.bBandEdgeEnergy[iphin, bregionDonor]         = Ec_d\n    params.bBandEdgeEnergy[iphip, bregionDonor]         = Ev_d\n\n    params.bBandEdgeEnergy[iphin, bregionAcceptor]      = Ec_a\n    params.bBandEdgeEnergy[iphip, bregionAcceptor]      = Ev_a\n\n    for ireg in 1:numberOfRegions # interior region data\n\n        params.dielectricConstant[ireg]                 = ε[ireg]\n\n        # effective DOS, band edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = NC[ireg]\n        params.densityOfStates[iphip, ireg]             = NV[ireg]\n        params.densityOfStates[iphia, ireg]             = NAnion[ireg]\n\n        params.bandEdgeEnergy[iphin, ireg]              = EC[ireg]\n        params.bandEdgeEnergy[iphip, ireg]              = EV[ireg]\n        params.bandEdgeEnergy[iphia, ireg]              = EA[ireg]\n\n        params.mobility[iphin, ireg]                    = μn[ireg]\n        params.mobility[iphip, ireg]                    = μp[ireg]\n        params.mobility[iphia, ireg]                    = μa[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]    = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = trap_density!(iphin, ireg, data, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg] = trap_density!(iphip, ireg, data, EI[ireg])\n        params.recombinationAuger[iphin, ireg]          = Auger\n        params.recombinationAuger[iphip, ireg]          = Auger\n\n    end\n\n    # interior doping\n    params.doping[iphin, regionDonor]                   = Nd\n    params.doping[iphia, regionIntrinsic]               = C0\n    params.doping[iphip, regionAcceptor]                = Na\n\n    # boundary doping\n    params.bDoping[iphip, bregionAcceptor]              = Na\n    params.bDoping[iphin, bregionDonor]                 = Nd\n\n    data.params                                         = params\n    ctsys                                               = System(grid, data, unknown_storage=unknown_storage)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define outer boundary conditions\")\n    end\n    ################################################################################\n\n    # set zero voltage ohmic contacts for electrons and holes at all outer boundaries.\n    set_contact!(ctsys, bregionAcceptor, Δu = 0.0)\n    set_contact!(ctsys, bregionDonor,    Δu = 0.0)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Newton solver\")\n    end\n    ################################################################################\n\n    control                   = NewtonControl()\n    control.verbose           = verbose\n    control.max_iterations    = 300\n    control.tol_absolute      = 1.0e-10\n    control.tol_relative      = 1.0e-10\n    control.handle_exceptions = true\n    control.tol_round         = 1.0e-10\n    control.max_round         = 5\n    control.damp_initial      = 0.5\n    control.damp_growth       = 1.21 # >= 1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium for Boltzmann\")\n    end\n    ################################################################################\n\n    # initialize solution and starting vectors\n    initialGuess  = unknowns(ctsys)\n    solution      = unknowns(ctsys)\n\n    solution      = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)\n\n    initialGuess .= solution\n\n    if plotting # currently, plotting the solution was only tested with PyPlot.\n        ipsi = data.index_psi\n        X = grid[Coordinates][1,:]\n        Y = grid[Coordinates][2,:]\n\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[ipsi, :])\n        Plotter.title(\"Electrostatic potential \\$ \\\\psi \\$ in Equilibrium\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        Plotter.tight_layout()\n        ################\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[iphin,:] )\n        Plotter.title(\"quasi Fermi potential \\$ \\\\varphi_n \\$ in Equilibrium\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        Plotter.tight_layout()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"I-V Measurement Loop\")\n    end\n    ################################################################################\n\n    data.calculationType = OutOfEquilibrium\n\n    # primary data for I-V scan protocol\n    scanrate            = 0.04 * V/s\n    number_tsteps       = 16\n    endVoltage          = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    tend                = endVoltage/scanrate\n\n    # with fixed timestep sizes we can calculate the times a priori\n    tvalues             = range(0, stop = tend, length = number_tsteps)\n\n    # for saving I-V data\n    IV                  = zeros(0) # for IV values\n    biasValues         = zeros(0) # for bias values\n\n    for istep = 2:number_tsteps\n\n        t  = tvalues[istep]       # Actual time\n        Δu = t * scanrate         # Applied voltage\n        Δt = t - tvalues[istep-1] # Time step size\n\n        # Apply new voltage; set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: t = $(t)\")\n        end\n\n        solve!(solution, initialGuess, ctsys, control  = control, tstep = Δt)\n\n        # get I-V data\n        current = get_current_val(ctsys, solution, initialGuess, Δt)\n\n        push!(IV, current)\n        push!(biasValues, Δu)\n\n        initialGuess .= solution\n    end # time loop\n\n    if plotting\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[ipsi, :])\n        Plotter.title(\"Electrostatic potential \\$ \\\\psi \\$ at end time\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        # ################\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[iphin,:] )\n        Plotter.title(\"quasi Fermi potential \\$ \\\\varphi_n \\$ at end time\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        # ################\n        Plotter.figure()\n        Plotter.plot(biasValues, IV.*(cm)^2/height, label = \"\\$ E_a =\\$$(textEa)eV;  \\$ N_a =\\$ $textNa\\$\\\\mathrm{cm}^{⁻3}\\$ (without internal BC)\",  linewidth= 3, linestyle=\"--\", color=\"red\")\n        Plotter.title(\"Forward; \\$ E_a =\\$$(textEa)eV;  \\$ N_a =\\$ $textNa\\$\\\\mathrm{cm}^{⁻3}\\$ \")\n        Plotter.ylabel(\"total current [A]\") #\n        Plotter.xlabel(\"Applied Voltage [V]\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = solution[4, 42]\n    return testval\n\nend #  main\n\nfunction test()\n    testval = -4.067800512080874\n    main(test = true, unknown_storage=:dense) ≈ testval #&& main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"","category":"page"},{"location":"examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/#GaAs-diode-with-spatially-varying-doping-(1D).","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"","category":"section"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"Simulating charge transport in a GaAs pin diode. This means the PDE problem corresponds to the van Roosbroeck system of equations. The simulations are performed out of equilibrium and for the stationary problem. A special feature here is that the doping is node-dependent.","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"module Ex102_PIN_nodal_doping\n\nusing VoronoiFVM\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing PyPlot\n\nfunction main(;Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage=:sparse)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionAcceptor          = 1                           # p doped region\n    regionIntrinsic         = 2                           # intrinsic region\n    regionDonor             = 3                           # n doped region\n    regions                 = [regionAcceptor, regionIntrinsic, regionDonor]\n    numberOfRegions         = length(regions)\n\n    # boundary region numbers\n    bregionAcceptor         = 1\n    bregionDonor            = 2\n    bregions                = [bregionAcceptor, bregionDonor]\n    numberOfBoundaryRegions = length(bregions)\n\n    h_pdoping               = 0.1    * μm\n    h_intrinsic             = 0.1    * μm\n    h_ndoping               = 0.1    * μm\n    w_device                = 0.1    * μm  # width of device\n    z_device                = 1.0e-5 * cm  # depth of device\n\n    coord                   = range(0.0, stop = h_ndoping + h_intrinsic + h_pdoping, length = 25)\n    coord                   = collect(coord)\n    grid                    = simplexgrid(coord)\n    numberOfNodes           = length(coord)\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm],                [h_pdoping],                           regionAcceptor,  tol = 1.0e-15)    # p-doped region = 1\n    cellmask!(grid, [h_pdoping],               [h_pdoping + h_intrinsic],             regionIntrinsic, tol = 1.0e-15)    # intrinsic region = 2\n    cellmask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic + h_ndoping], regionDonor,     tol = 1.0e-15)    # n-doped region = 3\n\n    if plotting\n        gridplot(grid, Plotter = Plotter)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin              = 1 # electron quasi Fermi potential\n    iphip              = 2 # hole quasi Fermi potential\n    numberOfCarriers   = 2\n\n    # Define the physical data.\n    Ec                 = 1.424                *  eV\n    Ev                 = 0.0                  *  eV\n    Nc                 = 4.351959895879690e17 / (cm^3)\n    Nv                 = 9.139615903601645e18 / (cm^3)\n    mun                = 8500.0               * (cm^2) / (V * s)\n    mup                = 400.0                * (cm^2) / (V * s)\n    εr                 = 12.9                 *  1.0              # relative dielectric permittivity of GAs\n    T                  = 300.0                *  K\n\n    # recombination parameters\n    SRH_TrapDensity_n  = 4.760185435081902e5    / cm^3\n    SRH_TrapDensity_p  = 9.996936448738406e6    / cm^3\n    SRH_LifeTime       = 1.0                    * ps\n\n    # contact voltage\n    voltageAcceptor    = 1.4 * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"We initialize the Data instance and fill in predefined data.","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Stationary\n\n    # Possible choices for F: Boltzmann, FermiDiracOneHalfBednarczyk,\n    # FermiDiracOneHalfTeSCA, FermiDiracMinusOne, Blakemore\n    data.F                            .= Boltzmann\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                bulk_recomb_Auger = false,\n                                                                bulk_recomb_radiative = false,\n                                                                bulk_recomb_SRH = true)\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceModelNone,\n    # InterfaceModelSurfaceReco (inner boundary).\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation             = ScharfetterGummel\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"Define the Params and ParamsNodal struct.","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"    params                                              = Params(grid, numberOfCarriers)\n    paramsnodal                                         = ParamsNodal(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = -1\n    params.chargeNumbers[iphip]                         =  1\n\n    for ibreg in 1:numberOfBoundaryRegions  # boundary region data\n\n        params.bDensityOfStates[iphin, ibreg]           = Nc\n        params.bDensityOfStates[iphip, ibreg]           = Nv\n        params.bBandEdgeEnergy[iphin, ibreg]            = Ec\n        params.bBandEdgeEnergy[iphip, ibreg]            = Ev\n    end\n\n    for ireg in 1:numberOfRegions           # interior region data\n\n        params.dielectricConstant[ireg]                 = εr\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = Nc\n        params.densityOfStates[iphip, ireg]             = Nv\n        params.bandEdgeEnergy[iphin, ireg]              = Ec\n        params.bandEdgeEnergy[iphip, ireg]              = Ev\n        params.mobility[iphin, ireg]                    = mun\n        params.mobility[iphip, ireg]                    = mup\n\n        # recombination parameters\n        params.recombinationSRHLifetime[iphin, ireg]    = SRH_LifeTime\n        params.recombinationSRHLifetime[iphip, ireg]    = SRH_LifeTime\n        params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity_n\n        params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity_p\n\n    end\n\n    # initialize the space dependent doping (see FarrellPeschka2019, Computers & Mathematics with Applications, 2019).\n    NDoping  = 1.0e17  / cm^3\n    κ        = 500.0\n    for icoord = 1:numberOfNodes\n        paramsnodal.doping[icoord] = NDoping * 0.5 * ( 1.0  +  tanh( (0.1 - coord[icoord]/μm) *κ )  - ( 1.0 + tanh( (coord[icoord]/μm - 0.2) * κ )) )\n    end\n\n    data.params      = params\n    data.paramsnodal = paramsnodal\n\n    ctsys            = System(grid, data, unknown_storage=unknown_storage)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    if test == false\n        show_params(ctsys)\n    end\n\n    if plotting == true\n        ################################################################################\n        println(\"Plot doping\")\n        ################################################################################\n        Plotter.figure()\n        plot_doping(Plotter, grid, paramsnodal)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define outer boundary conditions\")\n    end\n    ################################################################################\n\n    # set zero voltage ohmic contacts for each charge carrier at all outer boundaries.\n    set_contact!(ctsys, bregionAcceptor, Δu = 0.0)\n    set_contact!(ctsys, bregionDonor,    Δu = 0.0)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Newton solver\")\n    end\n    ################################################################################\n\n    control                   = NewtonControl()\n    control.verbose           = verbose\n    control.damp_growth       = 1.21\n    control.max_iterations    = 250\n    control.tol_absolute      = 1.0e-14\n    control.tol_relative      = 1.0e-14\n    control.handle_exceptions = true\n    control.tol_round         = 1.0e-8\n    control.max_round         = 5\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium for Boltzmann\")\n    end\n    ################################################################################\n\n    # initialize solution and starting vectors\n    initialGuess  = unknowns(ctsys)\n    solution      = unknowns(ctsys)\n\n    solution      = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)\n\n    initialGuess .= solution\n\n    if plotting\n        # set legend for plotting routines. Either you can use the predefined labels or write your own.\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        Plotter.figure()\n        plot_energies(Plotter,  grid, data, solution, \"Equilibrium\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution, \"Equilibrium\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter,  grid, data, solution, \"Equilibrium\", label_solution)\n        Plotter.figure()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"Set calculationType to OutOfEquilibrium for starting with respective simulation.","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"    data.calculationType = OutOfEquilibrium\n\n    maxBias              = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    biasValues           = range(0, stop = maxBias, length = 41)\n    IV                   = zeros(0)\n\n    for Δu in biasValues\n\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        solve!(solution, initialGuess, ctsys, control = control, tstep = Inf)\n\n        initialGuess .= solution\n\n        # get IV curve\n        factory = VoronoiFVM.TestFunctionFactory(ctsys.fvmsys)\n\n        # testfunction zero in bregionAcceptor and one in bregionDonor\n        tf     = testfunction(factory, [bregionAcceptor], [bregionDonor])\n        I      = integrate(ctsys.fvmsys, tf, solution)\n\n        push!(IV,  abs.(w_device * z_device * (I[iphin] + I[iphip])))\n\n    end # bias loop\n\n\n    if plotting # plot solution and IV curve\n        plot_energies(Plotter, grid, data, solution, \"Applied voltage Δu = $(biasValues[end])\",  label_energy)\n        Plotter.figure()\n        plot_solution(Plotter, grid, data, solution, \"Applied voltage Δu = $(biasValues[end])\",  label_solution, plotGridpoints = true)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution, \"Applied voltage Δu = $(biasValues[end])\", label_density,  plotGridpoints = true)\n        Plotter.figure()\n        plot_IV(Plotter, biasValues,IV, \"Applied voltage Δu = $(biasValues[end])\", plotGridpoints = true)\n    end\n\n    testval = solution[15]\n    return testval\n\nend #  main\n\nfunction test()\n    testval = 1.4676876302354516\n    main(test = true, unknown_storage=:dense) ≈ testval && main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when the PIN module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"","category":"page"},{"location":"examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Ex104_PSC_gradedFlux_Schottky_contacts/#PSC-device-with-graded-interfaces-and-Schottky-contacts-(1D).","page":"PSC device with graded interfaces & Schottky contacts (1D).","title":"PSC device with graded interfaces & Schottky contacts (1D).","text":"","category":"section"},{"location":"examples/Ex104_PSC_gradedFlux_Schottky_contacts/","page":"PSC device with graded interfaces & Schottky contacts (1D).","title":"PSC device with graded interfaces & Schottky contacts (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex104_PSC_gradedFlux_Schottky_contacts/","page":"PSC device with graded interfaces & Schottky contacts (1D).","title":"PSC device with graded interfaces & Schottky contacts (1D).","text":"Simulating a three layer PSC device SiO2| MAPI | SiO2 without mobile ions. The simulations are performed out of equilibrium, stationary and with two junctions between perovskite layer and transport layers, to which we refer as graded interfaces. Hence, a graded flux discretization with space dependent band-edge energies and density of states is tested here. Additionally to that instead of Ohmic contacts we have Schottky contacts.","category":"page"},{"location":"examples/Ex104_PSC_gradedFlux_Schottky_contacts/","page":"PSC device with graded interfaces & Schottky contacts (1D).","title":"PSC device with graded interfaces & Schottky contacts (1D).","text":"The parameters can be found in Table S.13, https://arxiv.org/abs/2009.04384. Or here: https://github.com/barnesgroupICL/Driftfusion/blob/Methods-IonMonger-Comparison/Inputfiles/IonMongerdefault_bulk.csv","category":"page"},{"location":"examples/Ex104_PSC_gradedFlux_Schottky_contacts/","page":"PSC device with graded interfaces & Schottky contacts (1D).","title":"PSC device with graded interfaces & Schottky contacts (1D).","text":"module Ex104_PSC_gradedFlux_Schottky_contacts\n\nusing VoronoiFVM\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing PyPlot\n\n# function for grading the physical parameters\nfunction grading_parameter!(physicalParameter, coord, regionTransportLayers, regionJunctions, h, heightLayers, lengthLayers, values)\n    for ireg in regionTransportLayers\n\n        xcoord                     = lengthLayers[ireg]:lengthLayers[ireg+1]\n        physicalParameter[xcoord] .= values[ireg]\n\n    end\n\n    for ireg in regionJunctions\n\n        xcoord   = lengthLayers[ireg]:lengthLayers[ireg+1]\n        left     = lengthLayers[ireg]-3\n        junction = h[ireg]\n        right    = lengthLayers[ireg+2]-3\n\n        gradient = ( physicalParameter[right] - physicalParameter[left] ) / junction\n\n        for index in xcoord\n            physicalParameter[index] = physicalParameter[left] + (coord[index] - heightLayers[ireg-1]) * gradient\n        end\n\n    end\n\n    return physicalParameter\nend\n\nfunction main(;n = 2, Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage=:sparse)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionDonor           = 1          # n doped region\n    regionJunction1       = 2\n    regionIntrinsic       = 3          # intrinsic region\n    regionJunction2       = 4\n    regionAcceptor        = 5          # p doped region\n    regions               = [regionDonor, regionJunction1, regionIntrinsic, regionJunction2, regionAcceptor]\n    regionTransportLayers = [regionDonor, regionIntrinsic, regionAcceptor]\n    regionJunctions       = [regionJunction1, regionJunction2]\n    numberOfRegions       = length(regions)\n\n    # boundary region numbers\n    bregionDonor          = 1\n    bregionAcceptor       = 2\n\n    # grid\n    h_ndoping             = 9.90e-6 * cm\n    h_junction1           = 1.0e-7  * cm\n    h_intrinsic           = 4.00e-5 * cm\n    h_junction2           = 1.0e-7  * cm\n    h_pdoping             = 1.99e-5 * cm\n    h                     = [h_ndoping, h_junction1, h_intrinsic, h_junction2, h_pdoping]\n    heightLayers          = [h_ndoping,\n                             h_ndoping + h_junction1,\n                             h_ndoping + h_junction1 + h_intrinsic,\n                             h_ndoping + h_junction1 + h_intrinsic + h_junction2,\n                             h_ndoping + h_junction1 + h_intrinsic + h_junction2 + h_pdoping]\n    refinementfactor      = 2^(n-1)\n\n    coord_ndoping         = collect(range(0.0, stop = h_ndoping, length = 4 * refinementfactor))\n    length_n              = length(coord_ndoping)\n    coord_junction1       = collect(range(h_ndoping,\n                                         stop = h_ndoping + h_junction1,\n                                         length = 3 * refinementfactor))\n    coord_intrinsic       = collect(range(h_ndoping + h_junction1,\n                                         stop = (h_ndoping + h_junction1 + h_intrinsic),\n                                         length = 10 * refinementfactor))\n    coord_junction2       = collect(range(h_ndoping + h_junction1 + h_intrinsic,\n                                         stop = (h_ndoping + h_junction1 + h_intrinsic + h_junction2),\n                                         length = 3 * refinementfactor))\n    coord_pdoping         = collect(range((h_ndoping + h_junction1 + h_intrinsic + h_junction2),\n                                          stop = (h_ndoping + h_junction1 + h_intrinsic + h_junction2 + h_pdoping),\n                                          length = 4 * refinementfactor))\n\n    coord                 = glue(coord_ndoping, coord_junction1)\n    length_j1             = length(coord)\n    coord                 = glue(coord, coord_intrinsic)\n    length_i              = length(coord)\n    coord                 = glue(coord, coord_junction2)\n    length_j2             = length(coord)\n    coord                 = glue(coord, coord_pdoping)\n\n    grid                  = simplexgrid(coord)\n    numberOfNodes         = length(coord)\n    lengthLayers          = [1, length_n, length_j1, length_i, length_j2, numberOfNodes]\n\n    # set different regions in grid, doping profiles do not intersect\n    cellmask!(grid, [0.0 * μm],        [heightLayers[1]], regionDonor)     # n-doped region   = 1\n    cellmask!(grid, [heightLayers[1]], [heightLayers[2]], regionJunction1) # first junction   = 2\n    cellmask!(grid, [heightLayers[2]], [heightLayers[3]], regionIntrinsic) # intrinsic region = 3\n    cellmask!(grid, [heightLayers[3]], [heightLayers[4]], regionJunction2) # sec. junction    = 4\n    cellmask!(grid, [heightLayers[4]], [heightLayers[5]], regionAcceptor)  # p-doped region   = 5\n\n    if plotting\n        gridplot(grid, Plotter = Plotter)\n        Plotter.title(\"Grid\")\n        Plotter.figure()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin            = 1 # electron quasi Fermi potential\n    iphip            = 2 # hole quasi Fermi potential\n    numberOfCarriers = 2\n\n    # temperature\n    T                = 300.0                 *  K\n\n    Eref             = 4.1                   *  eV  # reference energy\n    # band edge energies\n    Ec_d             = -4.0                  *  eV  + Eref\n    Ev_d             = -6.0                  *  eV  + Eref\n\n    Ec_i             = -3.7                  *  eV  + Eref\n    Ev_i             = -5.4                  *  eV  + Eref\n\n    Ec_a             = -3.1                  *  eV  + Eref\n    Ev_a             = -5.1                  *  eV  + Eref\n\n    # these parameters at the junctions for E_\\alpha and N_\\alpha will be overwritten.\n    Ec_j1            = Ec_d;     Ec_j2     = Ec_i\n    Ev_j1            = Ev_d;     Ev_j2     = Ev_i\n\n    EC               = [Ec_d, Ec_j1, Ec_i, Ec_j2, Ec_a]\n    EV               = [Ev_d, Ev_j1, Ev_i, Ev_j2, Ev_a]\n\n    # effective densities of state\n    Nc_d             = 5.0e19                / (cm^3)\n    Nv_d             = 5.0e19                / (cm^3)\n\n    Nc_i             = 8.1e18                / (cm^3)\n    Nv_i             = 5.8e18                / (cm^3)\n\n    Nc_a             = 5.0e19                / (cm^3)\n    Nv_a             = 5.0e19                / (cm^3)\n\n    Nc_j1            = Nc_d;     Nc_j2      = Nc_i\n    Nv_j1            = Nv_d;     Nv_j2      = Nv_i\n\n    NC               = [Nc_d, Nc_j1, Nc_i, Nc_j2, Nc_a]\n    NV               = [Nv_d, Nv_j1, Nv_i, Nv_j2, Nv_a]\n\n    # mobilities\n    μn_d             = 3.89                  * (cm^2) / (V * s)\n    μp_d             = 3.89                  * (cm^2) / (V * s)\n\n    μn_i             = 6.62e1                * (cm^2) / (V * s)\n    μp_i             = 6.62e1                * (cm^2) / (V * s)\n\n    μn_a             = 3.89e-1               * (cm^2) / (V * s)\n    μp_a             = 3.89e-1               * (cm^2) / (V * s)\n\n    μn_j1            = μn_d;     μn_j2      = μn_i\n    μp_j1            = μp_d;     μp_j2      = μp_i\n\n    μn               = [μn_d, μn_j1, μn_i, μn_j2, μn_a]\n    μp               = [μp_d, μp_j1, μp_i, μp_j2, μp_a]\n\n    # relative dielectric permittivity\n    ε_d              = 10.0                  *  1.0\n    ε_i              = 24.1                  *  1.0\n    ε_a              = 3.0                   *  1.0\n\n    ε_j1             = ε_d;       ε_j2      = ε_a\n\n    ε                = [ε_d, ε_j1, ε_i, ε_j2, ε_a]\n\n    # radiative recombination\n    r0_d             = 0.0e+0               * cm^3 / s\n    r0_i             = 1.0e-12              * cm^3 / s\n    r0_a             = 0.0e+0               * cm^3 / s\n\n    r0_j1            = r0_i;      r0_j2     = r0_i\n\n    r0               = [r0_d, r0_j1, r0_i, r0_j2, r0_a]\n\n    # life times and trap densities\n    τn_d             = 1.0e100              * s\n    τp_d             = 1.0e100              * s\n\n    τn_i             = 3.0e-10              * s\n    τp_i             = 3.0e-8               * s\n    τn_a             = τn_d\n    τp_a             = τp_d\n\n    τn_j1            = τn_i;     τn_j2      = τn_a\n    τp_j1            = τp_i;     τp_j2      = τp_a\n\n    τn               = [τn_d, τn_j1, τn_i, τn_j2, τn_a]\n    τp               = [τp_d, τp_j1, τp_i, τp_j2, τp_a]\n\n    # SRH trap energies\n    Ei_d             = -5.0                 * eV\n    Ei_i             = -4.55                * eV\n    Ei_a             = -4.1                 * eV\n\n    Ei_j1            = Ei_i;      Ei_j2     = Ei_a\n\n    EI               = [Ei_d, Ei_j1, Ei_i, Ei_j2, Ei_a]\n\n    # Auger recombination\n    Auger            = 0.0\n\n    # doping (doping values are from Driftfusion)\n    Nd               = 1.03e18             / (cm^3)\n    Na               = 1.03e18             / (cm^3)\n\n    # contact voltage\n    voltageAcceptor  =  1.2                 * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in data\n    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Stationary\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F                            .= Boltzmann\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = true,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceModelNone,\n    # InterfaceModelSurfaceReco (inner boundary).\n    data.boundaryType[bregionDonor]    = SchottkyContact\n    data.boundaryType[bregionAcceptor] = SchottkyContact\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation             = ScharfetterGummelGraded\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    # for region dependent parameters\n    params                                = Params(grid, numberOfCarriers)\n    # for space dependent parameters\n    paramsnodal                           = ParamsNodal(grid, numberOfCarriers)\n\n\n    params.temperature                    = T\n    params.UT                             = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]           = -1\n    params.chargeNumbers[iphip]           =  1\n\n    # nodal band-edge energies\n    paramsnodal.bandEdgeEnergy[iphin, :]  = grading_parameter!(paramsnodal.bandEdgeEnergy[iphin, :],\n                                                              coord, regionTransportLayers, regionJunctions, h,\n                                                              heightLayers, lengthLayers, EC)\n    paramsnodal.bandEdgeEnergy[iphip, :]  = grading_parameter!(paramsnodal.bandEdgeEnergy[iphip, :],\n                                                              coord, regionTransportLayers, regionJunctions, h,\n                                                              heightLayers, lengthLayers, EV)\n    # nodal effective density of states\n    paramsnodal.densityOfStates[iphin, :] = grading_parameter!(paramsnodal.densityOfStates[iphin, :],\n                                                              coord, regionTransportLayers, regionJunctions, h,\n                                                              heightLayers, lengthLayers, NC)\n    paramsnodal.densityOfStates[iphip, :] = grading_parameter!(paramsnodal.densityOfStates[iphip, :],\n                                                              coord, regionTransportLayers, regionJunctions, h,\n                                                              heightLayers, lengthLayers, NV)\n    # region dependent data\n    for ireg in 1:numberOfRegions\n\n        # mobility\n        params.mobility[iphin, ireg]                    = μn[ireg]\n        params.mobility[iphip, ireg]                    = μp[ireg]\n\n        params.dielectricConstant[ireg]                 = ε[ireg]\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]    = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = trap_density!(iphin, ireg, data, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg] = trap_density!(iphip, ireg, data, EI[ireg])\n        params.recombinationAuger[iphin, ireg]          = Auger\n        params.recombinationAuger[iphip, ireg]          = Auger\n\n    end\n\n    # interior doping\n    params.doping[iphin, regionDonor]        = Nd\n    params.doping[iphip, regionAcceptor]     = Na\n\n    # boundary doping\n    params.bDoping[iphip, bregionAcceptor]   = Na\n    params.bDoping[iphin, bregionDonor]      = Nd\n\n    # values for the schottky contacts\n    params.SchottkyBarrier[bregionDonor]     =  0.0\n    params.SchottkyBarrier[bregionAcceptor]  = -5.0  * eV  -  (-4.1  * eV) # difference between boundary Fermi level\n    params.bVelocity                         = [1.0e7 * cm/s    0.0   * cm/s;\n                                                0.0   * cm/s    1.0e7 * cm/s]\n\n    data.params                              = params\n    data.paramsnodal                         = paramsnodal\n    ctsys                                    = System(grid, data, unknown_storage=unknown_storage)\n\n    if test == false\n        show_params(ctsys)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define boundary conditions\")\n    end\n    ################################################################################\n\n    # set Schottky contacts.\n    set_contact!(ctsys, bregionAcceptor, Δu = 0.0)\n    set_contact!(ctsys, bregionDonor,    Δu = 0.0)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Newton solver\")\n    end\n    ################################################################################\n\n    control                   = NewtonControl()\n    control.verbose           = verbose\n    control.max_iterations    = 300\n    control.tol_absolute      = 1.0e-13\n    control.tol_relative      = 1.0e-13\n    control.handle_exceptions = true\n    control.tol_round         = 1.0e-13\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    control.damp_initial  = 0.5\n    control.damp_growth   = 1.61 # >= 1\n    control.max_round     = 5\n\n    initialGuess          = unknowns(ctsys)\n    solution              = unknowns(ctsys)\n\n    solution              = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)\n    initialGuess         .= solution\n\n    if plotting\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        plot_energies(Plotter,  grid, data, solution, \"Equilibrium\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution, \"Equilibrium\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter,  grid, data, solution, \"Equilibrium\", label_solution)\n        Plotter.figure()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################\n\n    data.calculationType = OutOfEquilibrium\n\n    control.damp_initial = 0.9\n    control.damp_growth  = 1.61 # >= 1\n    control.max_round    = 7\n\n    maxBias    = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    biasValues = range(0, stop = maxBias, length = 25)\n\n    for Δu in biasValues\n        if test == false\n            println(\"Bias value: Δu = $(Δu)\")\n        end\n\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        solve!(solution, initialGuess, ctsys, control  = control, tstep = Inf)\n\n        initialGuess .= solution\n\n    end # bias loop\n\n    # plotting\n    if plotting\n        plot_energies(Plotter,  grid, data, solution, \"Applied voltage Δu = $maxBias\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution, \"Applied voltage Δu = $maxBias\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter,  grid, data, solution, \"Applied voltage Δu = $maxBias\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = solution[data.index_psi, 20]\n    return testval\n\nend #  main\n\nfunction test()\n    testval=0.11725154137943199\n    main(test = true, unknown_storage=:dense) ≈ testval && main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex104_PSC_gradedFlux_Schottky_contacts/","page":"PSC device with graded interfaces & Schottky contacts (1D).","title":"PSC device with graded interfaces & Schottky contacts (1D).","text":"","category":"page"},{"location":"examples/Ex104_PSC_gradedFlux_Schottky_contacts/","page":"PSC device with graded interfaces & Schottky contacts (1D).","title":"PSC device with graded interfaces & Schottky contacts (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Ex109_Traps/#GaAs-diode:-transient-with-traps-(1D).","page":"GaAs diode: transient with traps (1D).","title":"GaAs diode: transient with traps (1D).","text":"","category":"section"},{"location":"examples/Ex109_Traps/","page":"GaAs diode: transient with traps (1D).","title":"GaAs diode: transient with traps (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex109_Traps/","page":"GaAs diode: transient with traps (1D).","title":"GaAs diode: transient with traps (1D).","text":"Simulating transient charge transport in a GaAs p-i-n diode with an electron trap.","category":"page"},{"location":"examples/Ex109_Traps/","page":"GaAs diode: transient with traps (1D).","title":"GaAs diode: transient with traps (1D).","text":"module Ex109_Traps\n\nusing VoronoiFVM\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing PyPlot\n\n# function to initialize the grid for a possble extension to other p-i-n devices.\nfunction initialize_pin_grid(refinementfactor, h_ndoping, h_intrinsic, h_pdoping)\n    coord_ndoping   = collect(range(0.0, stop = h_ndoping, length = 3 * refinementfactor))\n    coord_intrinsic = collect(range(h_ndoping, stop = (h_ndoping + h_intrinsic), length = 3 * refinementfactor))\n    coord_pdoping   = collect(range((h_ndoping + h_intrinsic),\n                                     stop = (h_ndoping + h_intrinsic + h_pdoping),\n                                     length = 3 * refinementfactor))\n    coord           = glue(coord_ndoping, coord_intrinsic)\n    coord           = glue(coord, coord_pdoping)\n\n    return coord\nend\n\nfunction main(;n = 3, Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage=:sparse)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionAcceptor          = 1                           # p doped region\n    regionIntrinsic         = 2                           # intrinsic region\n    regionDonor             = 3                           # n doped region\n    regions                 = [regionAcceptor, regionIntrinsic, regionDonor]\n    numberOfRegions         = length(regions)\n\n    # boundary region numbers\n    bregionAcceptor         = 1\n    bregionDonor            = 2\n    bregions                = [bregionAcceptor, bregionDonor]\n    numberOfBoundaryRegions = length(bregions)\n\n    # grid\n    refinementfactor        = 2^(n-1)\n    h_pdoping               = 2.0    * μm\n    h_intrinsic             = 2.0    * μm\n    h_ndoping               = 2.0    * μm\n    w_device                = 0.5    * μm  # width of device\n    z_device                = 1.0e-4 * cm  # depth of device\n\n    coord                   = initialize_pin_grid(refinementfactor,\n                                                  h_pdoping,\n                                                  h_intrinsic,\n                                                  h_ndoping)\n\n    grid                    = simplexgrid(coord)\n\n    # set different regions in grid, doping profiles do not intersect\n    cellmask!(grid, [0.0 * μm], [h_pdoping], regionAcceptor)                                        # p-doped\n    cellmask!(grid, [h_pdoping], [h_pdoping + h_intrinsic], regionIntrinsic)                        # intrinsic\n    cellmask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic + h_ndoping], regionDonor)  # n-doped\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend=:lt)\n        Plotter.title(\"Grid\")\n        Plotter.figure()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    iphin            = 1 # index electron quasi Fermi potential\n    iphip            = 2 # index hole quasi Fermi potential\n    iphit            = 3 # index trap quasi Fermi potential\n    numberOfCarriers = 3 # electrons, holes and traps\n\n    # physical data\n    Ec               = 1.424                             *  eV\n    Ev               = 0.0                               *  eV\n    Et               = 0.6                               *  eV\n    Nc               = 4.351959895879690e17              / (cm^3)\n    Nv               = 9.139615903601645e18              / (cm^3)\n    Nt               = 1e16                              / (cm^3)\n    mun              = 8500.0                            * (cm^2) / (V * s)\n    mup              = 400.0                             * (cm^2) / (V * s)\n    mut              = 0.0                               * (cm^2) / (V * s)  # such that there is no flux\n    εr               = 12.9                              *  1.0              # relative dielectric permittivity of GAs\n    T                = 300.0                             *  K\n\n    # recombination parameters\n    ni               = sqrt(Nc * Nv) * exp(-(Ec - Ev) / (2 * kB * T))        # intrinsic concentration\n    n0               = Nc * Boltzmann( (Et-Ec) / (kB*T) )                    # Boltzmann equilibrium concentration\n    p0               = ni^2 / n0                                             # Boltzmann equilibrium concentration\n    Auger            = 1.0e-29                           * cm^6 / s          # 1.0e-41\n    SRH_LifeTime     = 1.0e-3                            * ns\n    Radiative        = 1.0e-10                           * cm^3 / s          # 1.0e-16\n    G                = 1.0e25                            / (cm^3 * s)\n\n    # doping -- trap doping will not be set and thus automatically zero\n    dopingFactorNd   = 1.0\n    dopingFactorNa   = 0.46\n    Nd               = dopingFactorNd * Nc\n    Na               = dopingFactorNa * Nv\n\n    # contact voltage\n    voltageAcceptor  = 1.5                               * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in data\n    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Transient\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F                            .= [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = true,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Here, we enable the traps and parse the respective index and the regions where the trap is defined.\n    enable_traps!(data = data, traps = iphit, regions = regions)\n\n    # Possible choices: GenerationNone, GenerationUniform\n    data.generationModel               = GenerationUniform\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceModelNone,\n    # InterfaceModelSurfaceReco (inner boundary).\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation             = ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                              = Params(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = -1\n    params.chargeNumbers[iphip]                         =  1\n    params.chargeNumbers[iphit]                         = -1 # trap charge number determines whether hole or electron trap is used\n\n    for ibreg in 1:numberOfBoundaryRegions   # boundary region data\n\n        params.bDensityOfStates[iphin, ibreg]           = Nc\n        params.bDensityOfStates[iphip, ibreg]           = Nv\n        params.bDensityOfStates[iphit, ibreg]           = Nt\n        params.bBandEdgeEnergy[iphin, ibreg]            = Ec\n        params.bBandEdgeEnergy[iphip, ibreg]            = Ev\n        params.bBandEdgeEnergy[iphit, ibreg]            = Et\n    end\n\n    for ireg in 1:numberOfRegions           # interior region data\n\n        params.dielectricConstant[ireg]                 = εr\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = Nc\n        params.densityOfStates[iphip, ireg]             = Nv\n        params.densityOfStates[iphit, ireg]             = Nt\n        params.bandEdgeEnergy[iphin, ireg]              = Ec\n        params.bandEdgeEnergy[iphip, ireg]              = Ev\n        params.bandEdgeEnergy[iphit, ireg]              = Et\n        params.mobility[iphin, ireg]                    = mun\n        params.mobility[iphip, ireg]                    = mup\n        params.mobility[iphit, ireg]                    = mut\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = Radiative\n        params.recombinationSRHLifetime[iphin, ireg]    = SRH_LifeTime\n        params.recombinationSRHLifetime[iphip, ireg]    = SRH_LifeTime\n        params.recombinationSRHTrapDensity[iphin, ireg] = n0\n        params.recombinationSRHTrapDensity[iphip, ireg] = p0\n        params.recombinationAuger[iphin, ireg]          = Auger\n        params.recombinationAuger[iphip, ireg]          = Auger\n        params.generationUniform[ireg]                  = G\n\n    end\n\n    # doping\n    params.doping[iphin, regionDonor]                   = Nd\n    params.doping[iphin, regionIntrinsic]               = ni\n    params.doping[iphip, regionIntrinsic]               = 0.0\n    params.doping[iphip, regionAcceptor]                = Na\n\n    # boundary doping\n    params.bDoping[iphin, bregionDonor]                 = Nd\n    params.bDoping[iphip, bregionAcceptor]              = Na\n\n    data.params                                         = params\n    ctsys                                               = System(grid, data, unknown_storage=unknown_storage)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define outer boundary conditions and enabled layers\")\n    end\n    ################################################################################\n\n    # set zero voltage ohmic contacts for each charge carrier at all outer boundaries.\n    set_contact!(ctsys, bregionAcceptor, Δu = 0.0)\n    set_contact!(ctsys, bregionDonor,    Δu = 0.0)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Newton solver\")\n    end\n    ################################################################################\n\n    control                = NewtonControl()\n    control.verbose        = verbose\n    control.tol_absolute   = 1.0e-10\n    control.tol_relative   = 1.0e-10\n    control.tol_round      = 1.0e-4\n    control.damp_initial   = 0.5\n    control.damp_growth    = 1.2\n    control.max_iterations = 30\n    control.max_round      = 3\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # initialize solution and starting vectors\n    initialGuess          = unknowns(ctsys)\n    solution              = unknowns(ctsys)\n\n    # solve thermodynamic equilibrium and update initial guess\n    solution              = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)\n    initialGuess         .= solution\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    if plotting\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        # add labels for traps\n        label_energy[1, iphit] = \"\\$E_{\\\\tau}-q\\\\psi\\$\"; label_energy[2, iphit] = \"\\$ - q \\\\varphi_{\\\\tau}\\$\"\n        label_density[iphit]   = \"\\$n_{\\\\tau}\\$\";        label_solution[iphit]  = \"\\$ \\\\varphi_{\\\\tau}\\$\"\n\n        plot_energies(Plotter, grid, data, solution, \"Equilibrium\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution,\"Equilibrium\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, grid, data, solution, \"Equilibrium\", label_solution)\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Loop for putting generation on\")\n    end\n    ################################################################################\n\n    data.calculationType = OutOfEquilibrium\n\n    # Scan rate and time steps\n    scanrate             = 1.0 * V/s\n    number_tsteps        = 25\n    endVoltage           = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n\n    IV                   = zeros(0) # for IV values\n    biasValues           = zeros(0) # for bias values\n    tend                 = endVoltage/scanrate\n\n    # with fixed timestep sizes we can calculate the times\n    # a priori\n    tvalues              = range(0.0, stop = tend, length = number_tsteps)\n\n    steps                = 20\n    I                    = collect(steps:-1:0.0)\n    LAMBDA               = 10 .^ (I)\n    Δt                   = tvalues[2] - tvalues[1]\n\n    for i in 1:length(LAMBDA)\n\n        data.λ2 = 1 / (LAMBDA[i] )\n\n        if test == false\n            println(\"increase generation with λ2 = $(data.λ2)\")\n        end\n\n        VoronoiFVM.solve!(solution, initialGuess, ctsys, control = control, tstep=Δt)\n\n        initialGuess = solution\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"IV Measurement loop\")\n    end\n    ################################################################################\n\n    for istep = 2:number_tsteps\n\n        t  = tvalues[istep]          # Actual time\n        Δu = t * scanrate            # Applied voltage\n        Δt = t - tvalues[istep-1]    # Time step size\n\n        # Apply new voltage: set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: t = $(t)\")\n        end\n\n        solve!(solution, initialGuess, ctsys, control  = control, tstep = Δt)\n\n        # get I-V data\n        current = get_current_val(ctsys, solution, initialGuess, Δt)\n\n        push!(IV, w_device * z_device * current)\n        push!(biasValues, Δu)\n\n        initialGuess .= solution\n\n    end # bias loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    # plot solution and IV curve\n    if plotting\n        plot_energies(Plotter, grid, data, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage), \\$ t=$(tvalues[number_tsteps])\\$\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution,\"bias \\$\\\\Delta u\\$ = $(endVoltage), \\$ t=$(tvalues[number_tsteps])\\$\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, grid, data, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage), \\$ t=$(tvalues[number_tsteps])\\$\", label_solution)\n        Plotter.figure()\n        plot_IV(Plotter, biasValues,IV, \"bias \\$\\\\Delta u\\$ = $(biasValues[end])\", plotGridpoints = true)\n    end\n\n    testval = solution[iphit, 17]\n    return testval\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\nend #  main\n\nfunction test()\n    testval = 1.0245795906936774\n    main(test = true, unknown_storage=:dense) ≈ testval && main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when the PIN module has successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex109_Traps/","page":"GaAs diode: transient with traps (1D).","title":"GaAs diode: transient with traps (1D).","text":"","category":"page"},{"location":"examples/Ex109_Traps/","page":"GaAs diode: transient with traps (1D).","title":"GaAs diode: transient with traps (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Ex110_PSC_surface_recombination/#PSC-device-with-surface-recombination-(1D).","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"","category":"section"},{"location":"examples/Ex110_PSC_surface_recombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex110_PSC_surface_recombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"Simulating a three layer PSC device Pedot| MAPI | PCBM. The simulations are performed out of equilibrium, time-dependent, with abrupt interfaces and with surface recombination at the internal boundaries.","category":"page"},{"location":"examples/Ex110_PSC_surface_recombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"The parameters are from Calado et al.: https://github.com/barnesgroupICL/Driftfusion/blob/master/Inputfiles/pedotpssmapi_pcbm.csv. (with adjustments on layer lengths)","category":"page"},{"location":"examples/Ex110_PSC_surface_recombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"module Ex110_PSC_surface_recombination\n\nusing VoronoiFVM\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing PyPlot\n\nfunction main(;n = 6, Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage=:dense)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionAcceptor   = 1                           # p doped region\n    regionIntrinsic  = 2                           # intrinsic region\n    regionDonor      = 3                           # n doped region\n    regions          = [regionAcceptor, regionIntrinsic, regionDonor]\n    numberOfRegions  = length(regions)\n\n    # boundary region numbers\n    bregionAcceptor  = 1\n    bregionDonor     = 2\n    bregionJunction1 = 3\n    bregionJunction2 = 4\n\n    # grid (the nearer to interface, the finer)\n    h_pdoping        = 3.00e-6 * cm + 1.0e-7 * cm\n    h_intrinsic      = 3.00e-5 * cm\n    h_ndoping        = 8.50e-6 * cm + 1.0e-7 * cm\n\n    x0               = 0.0 * cm\n    δ                = 4*n        # the larger, the finer the mesh\n    t                = 0.5*(cm)/δ # tolerance for geomspace and glue (with factor 10)\n    k                = 1.5        # the closer to 1, the closer to the boundary geomspace works\n\n    coord_p_u        = collect(range(x0, h_pdoping/2, step=h_pdoping/(0.5*δ)))\n    coord_p_g        = geomspace(h_pdoping/2,\n                                 h_pdoping,\n                                 h_pdoping/(0.8*δ),\n                                 h_pdoping/(1.5*δ),\n                                 tol=t)\n    coord_i_g1       = geomspace(h_pdoping,\n                                 h_pdoping+h_intrinsic/k,\n                                 h_intrinsic/(6.1*δ),\n                                 h_intrinsic/(2.1*δ),\n                                 tol=t)\n    coord_i_g2       = geomspace(h_pdoping+h_intrinsic/k,\n                                 h_pdoping+h_intrinsic,\n                                 h_intrinsic/(2.1*δ),\n                                 h_intrinsic/(6.1*δ),\n                                 tol=t)\n    coord_n_g        = geomspace(h_pdoping+h_intrinsic,\n                                 h_pdoping+h_intrinsic+h_ndoping/2,\n                                 h_ndoping/(3.0*δ),\n                                 h_ndoping/(1.0*δ),\n                                 tol=t)\n    coord_n_u        = collect(range(h_pdoping+h_intrinsic+h_ndoping/2, h_pdoping+h_intrinsic+h_ndoping, step=h_pdoping/(0.8*δ)))\n\n    coord            = glue(coord_p_u,coord_p_g,  tol=10*t)\n    coord            = glue(coord,    coord_i_g1, tol=10*t)\n    coord            = glue(coord,    coord_i_g2, tol=10*t)\n    coord            = glue(coord,    coord_n_g,  tol=10*t)\n    coord            = glue(coord,    coord_n_u,  tol=10*t)\n    grid             = ExtendableGrids.simplexgrid(coord)\n\n    # cellmask! for defining the subregions and assigning region number (doping profiles do not intersect)\n    cellmask!(grid, [0.0 * μm],                 [h_pdoping],                           regionAcceptor, tol = 1.0e-18)   # p-doped region   = 1\n    cellmask!(grid, [h_pdoping],                [h_pdoping + h_intrinsic],             regionIntrinsic, tol = 1.0e-18)  # intrinsic region = 2\n    cellmask!(grid, [h_pdoping + h_intrinsic],  [h_pdoping + h_intrinsic + h_ndoping], regionDonor, tol = 1.0e-18)      # n-doped region   = 3\n\n    # bfacemask! for ``active'' boundary regions, i.e. internal interfaces. On the outer boundary regions, the\n    # conditions will be formulated later\n    bfacemask!(grid, [h_pdoping],               [h_pdoping],                           bregionJunction1)  # first  inner interface\n    bfacemask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic],             bregionJunction2)  # second inner interface\n\n    if plotting\n        GridVisualize.gridplot(grid, Plotter = Plotter)\n        Plotter.title(\"Grid\")\n        Plotter.figure()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    iphin            = 1 # electron quasi Fermi potential\n    iphip            = 2 # hole quasi Fermi potential\n    iphia            = 3 # anion vacancy quasi Fermi potential\n    numberOfCarriers = 3\n\n    # temperature\n    T                =  300.0                *  K\n\n    # band edge energies\n    Ec_a             = -3.0                  *  eV\n    Ev_a             = -5.1                  *  eV\n\n    Ec_i             = -3.8                  *  eV\n    Ev_i             = -5.4                  *  eV\n\n    Ec_d             = -3.8                  *  eV\n    Ev_d             = -6.2                  *  eV\n\n    EC               = [Ec_a, Ec_i, Ec_d]\n    EV               = [Ev_a, Ev_i, Ev_d]\n\n    # effective densities of state\n    Nc_a             = 1.0e20                / (cm^3)\n    Nv_a             = 1.0e20                / (cm^3)\n\n    Nc_i             = 1.0e19                / (cm^3)\n    Nv_i             = 1.0e19                / (cm^3)\n\n    # ###################### adjust Na, Ea here #####################\n    Nanion           = 1.21e22               / (cm^3)\n    Ea_i             = -5.175                *  eV\n\n    # for the labels in the figures\n    textEa           = Ea_i                 ./  eV\n    textNa           = Nanion               .* (cm^3)\n    # ###################### adjust Na, Ea here #####################\n\n    EA               = [0.0,  Ea_i,  0.0]\n\n    Nc_d             = 1.0e19                / (cm^3)\n    Nv_d             = 1.0e19                / (cm^3)\n\n    NC               = [Nc_a, Nc_i, Nc_d]\n    NV               = [Nv_a, Nv_i, Nv_d]\n    NAnion           = [0.0,  Nanion, 0.0]\n\n    # mobilities\n    μn_a             = 0.1                   * (cm^2) / (V * s)\n    μp_a             = 0.1                   * (cm^2) / (V * s)\n\n    μn_i             = 2.00e1                * (cm^2) / (V * s)\n    μp_i             = 2.00e1                * (cm^2) / (V * s)\n    μa_i             = 1.00e-10              * (cm^2) / (V * s)\n\n    μn_d             = 1.0e-3                * (cm^2) / (V * s)\n    μp_d             = 1.0e-3                * (cm^2) / (V * s)\n\n    μn               = [μn_a, μn_i, μn_d]\n    μp               = [μp_a, μp_i, μp_d]\n    μa               = [0.0,  μa_i, 0.0 ]\n\n    # relative dielectric permittivity\n    ε_a              = 4.0                   *  1.0\n    ε_i              = 23.0                  *  1.0\n    ε_d              = 3.0                   *  1.0\n\n    ε                = [ε_a, ε_i, ε_d]\n\n    # radiative recombination\n    r0_a             = 6.3e-11               * cm^3 / s\n    r0_i             = 3.6e-12               * cm^3 / s\n    r0_d             = 6.8e-11               * cm^3 / s\n\n    r0               = [r0_a, r0_i, r0_d]\n\n    # life times and trap densities\n    τn_a             = 1.0e-6                * s\n    τp_a             = 1.0e-6                * s\n\n    τn_i             = 1.0e-7                * s\n    τp_i             = 1.0e-7                * s\n    τn_d             = τn_a\n    τp_d             = τp_a\n\n    τn               = [τn_a, τn_i, τn_d]\n    τp               = [τp_a, τp_i, τp_d]\n\n    # SRH trap energies (needed for calculation of trap_density! (SRH))\n    Ei_a             = -4.05                 * eV\n    Ei_i             = -4.60                 * eV\n    Ei_d             = -5.00                 * eV\n\n    EI               = [Ei_a, Ei_i, Ei_d]\n\n    # doping\n    Nd               = 2.089649130192123e17  / (cm^3)\n    Na               = 4.529587947185444e18  / (cm^3)\n    C0               = 1.0e18                / (cm^3)\n\n    # contact voltage\n    voltageAcceptor  = 1.2                   * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in data\n    data                                = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                      = Transient\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F                              = [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n\n    data.bulkRecombination              = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = false,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceModelNone,\n    # InterfaceModelSurfaceReco (inner boundary).\n    data.boundaryType[bregionAcceptor]  = OhmicContact\n    data.boundaryType[bregionJunction1] = InterfaceModelSurfaceReco\n    data.boundaryType[bregionJunction2] = InterfaceModelSurfaceReco\n    data.boundaryType[bregionDonor]     = OhmicContact\n\n    # Present ionic vacancies in perovskite layer\n    data.enableIonicCarriers            = enable_ionic_carriers(ionic_carriers = [iphia], regions = [regionIntrinsic])\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation              = ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                                       = Params(grid, numberOfCarriers)\n\n    params.temperature                                           = T\n    params.UT                                                    = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                                  = -1\n    params.chargeNumbers[iphip]                                  =  1\n    params.chargeNumbers[iphia]                                  =  1\n\n    for ireg in 1:numberOfRegions ## interior region data\n\n        params.dielectricConstant[ireg]                          = ε[ireg]\n\n        # effective dos, band edge energy and mobilities\n        params.densityOfStates[iphin, ireg]                      = NC[ireg]\n        params.densityOfStates[iphip, ireg]                      = NV[ireg]\n        params.densityOfStates[iphia, ireg]                      = NAnion[ireg]\n\n        params.bandEdgeEnergy[iphin, ireg]                       = EC[ireg]\n        params.bandEdgeEnergy[iphip, ireg]                       = EV[ireg]\n        params.bandEdgeEnergy[iphia, ireg]                       = EA[ireg]\n\n        params.mobility[iphin, ireg]                             = μn[ireg]\n        params.mobility[iphip, ireg]                             = μp[ireg]\n        params.mobility[iphia, ireg]                             = μa[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]                      = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]             = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]             = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg]          = trap_density!(iphin, ireg, data, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg]          = trap_density!(iphip, ireg, data, EI[ireg])\n    end\n\n    # outer boundary region data\n    params.bDensityOfStates[iphin, bregionAcceptor]              = Nc_a\n    params.bDensityOfStates[iphip, bregionAcceptor]              = Nv_a\n\n    params.bDensityOfStates[iphin, bregionDonor]                 = Nc_d\n    params.bDensityOfStates[iphip, bregionDonor]                 = Nv_d\n\n    params.bBandEdgeEnergy[iphin, bregionAcceptor]               = Ec_a\n    params.bBandEdgeEnergy[iphip, bregionAcceptor]               = Ev_a\n\n    params.bBandEdgeEnergy[iphin, bregionDonor]                  = Ec_d\n    params.bBandEdgeEnergy[iphip, bregionDonor]                  = Ev_d\n\n    ##############################################################\n    # inner boundary region data\n    params.bDensityOfStates[iphin, bregionJunction1]             = Nc_i\n    params.bDensityOfStates[iphip, bregionJunction1]             = Nv_i\n\n    params.bDensityOfStates[iphin, bregionJunction2]             = Nc_i\n    params.bDensityOfStates[iphip, bregionJunction2]             = Nv_i\n\n    params.bBandEdgeEnergy[iphin, bregionJunction1]              = Ec_i\n    params.bBandEdgeEnergy[iphip, bregionJunction1]              = Ev_i\n\n    params.bBandEdgeEnergy[iphin, bregionJunction2]              = Ec_i\n    params.bBandEdgeEnergy[iphip, bregionJunction2]              = Ev_i\n\n    # for surface recombination\n    params.recombinationSRHvelocity[iphin, bregionJunction1]     = 1.0e1  * cm / s\n    params.recombinationSRHvelocity[iphip, bregionJunction1]     = 1.0e5  * cm / s\n\n    params.recombinationSRHvelocity[iphin, bregionJunction2]     = 1.0e7  * cm / s\n    params.recombinationSRHvelocity[iphip, bregionJunction2]     = 1.0e1  * cm / s\n\n    params.bRecombinationSRHTrapDensity[iphin, bregionJunction1] = params.recombinationSRHTrapDensity[iphin, regionIntrinsic]\n    params.bRecombinationSRHTrapDensity[iphip, bregionJunction1] = params.recombinationSRHTrapDensity[iphip, regionIntrinsic]\n\n    params.bRecombinationSRHTrapDensity[iphin, bregionJunction2] = params.recombinationSRHTrapDensity[iphin, regionIntrinsic]\n    params.bRecombinationSRHTrapDensity[iphip, bregionJunction2] = params.recombinationSRHTrapDensity[iphip, regionIntrinsic]\n\n    ##############################################################\n\n    # interior doping\n    params.doping[iphin,  regionDonor]                           = Nd\n    params.doping[iphip,  regionAcceptor]                        = Na\n    params.doping[iphia,  regionIntrinsic]                       = C0\n    # boundary doping\n    params.bDoping[iphin, bregionDonor]                          = Nd\n    params.bDoping[iphip, bregionAcceptor]                       = Na\n\n    data.params                                                  = params\n    ctsys                                                        = System(grid, data, unknown_storage=unknown_storage)\n\n    # print all params stored in ctsys.data.params\n    if test == false\n        show_params(ctsys)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define outer boundary conditions\")\n    end\n    ################################################################################\n\n    # set zero voltage ohmic contacts for electrons and holes at all outer boundaries.\n    set_contact!(ctsys, bregionAcceptor, Δu = 0.0)\n    set_contact!(ctsys, bregionDonor,    Δu = 0.0)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Newton solver\")\n    end\n    ################################################################################\n\n    control                   = VoronoiFVM.NewtonControl()\n    control.verbose           = verbose\n    control.max_iterations    = 300\n    control.tol_absolute      = 1.0e-10\n    control.tol_relative      = 1.0e-10\n    control.handle_exceptions = true\n    control.tol_round         = 1.0e-10\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    control.damp_initial = 0.05\n    control.damp_growth  = 1.21 # >= 1\n    control.max_round    = 5\n\n    # initialize solution and starting vectors\n    initialGuess         = unknowns(ctsys)\n    solution             = unknowns(ctsys)\n\n    solution             = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)\n\n    initialGuess        .= solution\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"I-V Measurement Loop\")\n    end\n    ################################################################################\n\n    # set calculationType to OutOfEquilibrium for starting with respective simulation.\n    data.calculationType = OutOfEquilibrium\n\n    control.damp_initial = 0.5\n    control.damp_growth  = 1.21\n    control.max_round    = 5\n\n    # there are different ways to control time stepping. Here we assume these primary data\n    scanrate             = 1.0 * V/s\n    ntsteps              = 31\n    vend                 = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    tend                 = vend/scanrate\n\n    # with fixed timestep sizes we can calculate the times a priori\n    tvalues              = range(0, stop = tend, length = ntsteps)\n\n    # for saving I-V data\n    IV                   = zeros(0) # for IV values\n    biasValues           = zeros(0) # for bias values\n\n    for istep = 2:ntsteps\n\n        t  = tvalues[istep]       # Actual time\n        Δu = t * scanrate         # Applied voltage\n        Δt = t - tvalues[istep-1] # Time step size\n\n        # Apply new voltage (set non-equilibrium values)\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: Δt = $(t)\")\n        end\n\n        solve!(solution, initialGuess, ctsys, control = control, tstep = Δt)\n\n        initialGuess .= solution\n\n        # get I-V data\n        current = get_current_val(ctsys, solution, initialGuess, Δt)\n\n        push!(IV, current)\n        push!(biasValues, Δu)\n\n        if plotting\n            label_solution = Array{String, 1}(undef, numberOfCarriers)\n            label_solution[iphin]  = \"\\$ \\\\varphi_n\\$\"; label_solution[iphip]  = \"\\$ \\\\varphi_p\\$\"; label_solution[iphia]  = \"\\$ \\\\varphi_a\\$\"\n\n            plot_solution(Plotter, grid, data, solution, \"bias \\$\\\\Delta u\\$ = $(Δu); \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_solution)\n        end\n\n    end # time loop\n\n    ##res = [biasValues, IV]\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = VoronoiFVM.norm(ctsys.fvmsys, solution, 2)\n    return testval\n\n\nend # main\n\nfunction test()\n    testval = 50.60818868398909\n    main(test = true, unknown_storage=:dense) ≈ testval #&& main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex110_PSC_surface_recombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"","category":"page"},{"location":"examples/Ex110_PSC_surface_recombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"GaAs/#van-Roosbroeck-system","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"In both of the following examples, we solve the van Roosbroeck equations, a system of partial differential equations which describe current flow in a bipolar multi layer device:","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"beginaligned\n\t- nabla cdot (varepsilon_s nabla psi) = q Big( (p(psi varphi_p) - N_A ) - (n(psi varphi_n) - N_D) Big)\n\tq partial_t n(psi varphi_n) -nabla cdot mathbfj_n = -qR(np) \n\tq partial_t p(psi varphi_p) + nabla cdot mathbfj_p = -qR(np)\nendaligned","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Ohmic contacts will be used as boundary conditions. We will proceed as follows","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Step 1: Initialize grid","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Step 2: Initialize physical model","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Step 3: Solve the problem in equilibrium","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Step 4: Solve the problem for an applied bias","category":"page"},{"location":"GaAs/#Example-1:-Stationary-1D-problem-(region-doping)","page":"van Roosbroeck system","title":"Example 1: Stationary 1D problem (region doping)","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"We consider a three-layer GaAs p-i-n device in one dimension. We will explain the PIN example in greater detail.","category":"page"},{"location":"GaAs/#Step-1:-Initialize-grid","page":"van Roosbroeck system","title":"Step 1: Initialize grid","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"We have three layers and two external boundaries. We would like to solve the van Roosbroeck system on a uniform mesh with local grid refinement. We declare subregions and external boundaries.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"# region numbers\nregionAcceptor          = 1          # p doped region\nregionIntrinsic         = 2          # intrinsic region\nregionDonor             = 3          # n doped region\nregions                 = [regionAcceptor, regionIntrinsic, regionDonor]\nnumberOfRegions         = length(regions)\n\n# boundary region numbers\nbregionAcceptor         = 1\nbregionDonor            = 2\nbregions                = [bregionAcceptor, bregionDonor]\nnumberOfBoundaryRegions = length(bregions)\n\n# grid\nrefinementfactor        = 2^(n-1)\nh_pdoping               = 2 * μm\nh_intrinsic             = 2 * μm\nh_ndoping               = 2 * μm\ncoord                   = initialize_pin_grid(refinementfactor,\n                                             h_pdoping,\n                                             h_intrinsic,\n                                             h_ndoping)\n\ngrid                    = simplexgrid(coord)\n\n# ExtendableGrids.cellmask! assigns region numbers\ncellmask!(grid, [0.0 * μm],[h_pdoping], regionAcceptor)\ncellmask!(grid, [h_pdoping],[h_pdoping + h_intrinsic], regionIntrinsic)\ncellmask!(grid, [h_pdoping + h_intrinsic],[h_pdoping + h_intrinsic + h_ndoping], regionDonor)","category":"page"},{"location":"GaAs/#Step-2:-Initialize-physical-model","page":"van Roosbroeck system","title":"Step 2: Initialize physical model","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Next, we choose relevant physical models such as the underlying statistics function or the recombination model. Additional options are stated in the comments. Furthermore, we define the charge carrier indices. The index for the electrostatic potential is set automatically to numberOfCarriers + 1.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"# Set indices for the quasi Fermi potentials\niphin                  = 1    # electrons\niphip                  = 2    # holes\nnumberOfCarriers       = 2\n\n# Initialize Data instance\ndata                   = Data(grid, numberOfCarriers)\n\n# Solve the stationary problem instead of the transient one\ndata.modelType         = Stationary\n\n# Choose statistical relation between density and qF potential\n# options: Boltzmann, FermiDiracOneHalfBednarczyk,\n#          FermiDiracOneHalfTeSCA FermiDiracMinusOne, Blakemore\ndata.F                .= Boltzmann\n\n# Enable/Disable recombination processes, the default is stationary SRH recombination.\ndata.bulkRecombination = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                 bulk_recomb_Auger = true,\n                                                 bulk_recomb_radiative = true,\n                                                 bulk_recomb_SRH = true)\n\n# choose boundary models\n# exterior boundaries: OhmicContact and SchottkyContact\n# interior boundaries: InterfaceModelNone, InterfaceModelSurfaceReco.\ndata.boundaryType[bregionAcceptor] = OhmicContact\ndata.boundaryType[bregionDonor]    = OhmicContact\n\n# choose flux discretization scheme: ScharfetterGummel ScharfetterGummelGraded,\n# ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\ndata.fluxApproximation             = ExcessChemicalPotential","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Next, we fill in pre-defined or externally read in parameter values.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"# params contains all necessary physical parameters\nparams                                              = Params(grid, numberOfCarriers)\nparams.temperature                                  = T\nparams.UT                                           = (kB * params.temperature) / q\nparams.chargeNumbers[iphin]                         = -1\nparams.chargeNumbers[iphip]                         =  1\n\nfor ibreg in 1:numberOfBoundaryRegions   # boundary region data\n\n    params.bDensityOfStates[iphin, ibreg]           = Nc\n    params.bDensityOfStates[iphip, ibreg]           = Nv\n    params.bBandEdgeEnergy[iphin, ibreg]            = Ec\n    params.bBandEdgeEnergy[iphip, ibreg]            = Ev\nend\n\nfor ireg in 1:numberOfRegions           # interior region data\n\n    params.dielectricConstant[ireg]                 = εr\n\n    # effective DOS, band-edge energy and mobilities\n    params.densityOfStates[iphin, ireg]             = Nc\n    params.densityOfStates[iphip, ireg]             = Nv\n    params.bandEdgeEnergy[iphin, ireg]              = Ec\n    params.bandEdgeEnergy[iphip, ireg]              = Ev\n    params.mobility[iphin, ireg]                    = mun\n    params.mobility[iphip, ireg]                    = mup\n\n    # recombination parameters\n    params.recombinationRadiative[ireg]             = Radiative\n    params.recombinationSRHLifetime[iphin, ireg]    = SRH_LifeTime\n    params.recombinationSRHLifetime[iphip, ireg]    = SRH_LifeTime\n    params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity\n    params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity\n    params.recombinationAuger[iphin, ireg]          = Auger\n    params.recombinationAuger[iphip, ireg]          = Auger\n\nend\n\n# interior doping\nparams.doping[iphin, regionDonor]                   = Nd\nparams.doping[iphin, regionIntrinsic]               = ni\nparams.doping[iphip, regionIntrinsic]               = 0.0\nparams.doping[iphip, regionAcceptor]                = Na\n\n# boundary doping\nparams.bDoping[iphin, bregionDonor]                 = Nd\nparams.bDoping[iphip, bregionAcceptor]              = Na\n\n# Initialize a ChargeTransport struct\ndata.params   = params\nctsys         = System(grid, data, unknown_storage=unknown_storage)","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"We use ohmic contacts and set the applied voltage to zero in equilibrium.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"set_contact!(ctsys, bregionAcceptor, Δu = 0.0)\nset_contact!(ctsys, bregionDonor,    Δu = 0.0)","category":"page"},{"location":"GaAs/#Step-3:-Solve-the-problem-in-equilibrium","page":"van Roosbroeck system","title":"Step 3: Solve the problem in equilibrium","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Solve the equilibrium. Note that control refers to the Newton control parameters given in VoronoiFVM.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"solution      = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)\ninitialGuess .= solution","category":"page"},{"location":"GaAs/#Step-4:-Solve-the-problem-for-an-applied-bias","page":"van Roosbroeck system","title":"Step 4: Solve the problem for an applied bias","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Starting from the equilibrium solution, we increase the applied voltage. Note that it is important to set OutOfEqulibrium.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"data.calculationType = OutOfEquilibrium\nmaxBias              = voltageAcceptor # bias at acceptor boundary\nbiasValues           = range(0, stop = maxBias, length = 32)\n\nfor Δu in biasValues\n    set_contact!(ctsys, bregionAcceptor, Δu = Δu) # non equilibrium bc\n    solve!(solution, initialGuess, ctsys, control = control, tstep = Inf)\n    initialGuess .= solution\nend","category":"page"},{"location":"GaAs/#Step-5:-Postprocessing","page":"van Roosbroeck system","title":"Step 5: Postprocessing","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"By adding the following line to the previous loop","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"current = get_current_val(ctsys, solution)","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"we have the possibility to calculate the total current.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Moreover, there are several different plotting routines, see ct_plotting.jl.","category":"page"},{"location":"GaAs/#Example-2:-Stationary-1D-problem-(nodal-doping)","page":"van Roosbroeck system","title":"Example 2: Stationary 1D problem (nodal doping)","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Now, instead of using regionwise doping it is possible to apply a nodal doping. (This is indeed also possible for other physical parameters, see the description of ParamsNodal.) For this, go to previous Step 2, where you build your parameter set and adjust the doping initialization (code snippet is from this example)","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"paramsnodal = ParamsNodal(grid, numberOfCarriers)\n\n# initialize the space dependent doping\nNDoping = 1.0e17  / cm^3; κ = 500.0\nfor icoord = 1:numberOfNodes\n    t1 = tanh( (0.1 - coord[icoord]/μm) *κ )\n    t2 = 1.0 + tanh( (coord[icoord]/μm - 0.2) * κ )\n    paramsnodal.doping[icoord] = NDoping * 0.5 * ( 1.0  +  t1  - t2 )\nend\n\ndata.paramsnodal  = paramsnodal","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/#PSC-device-with-graded-interfaces-and-Ohmic-contacts-(1D).","page":"PSC device with graded interfaces & Ohmic contacts (1D).","title":"PSC device with graded interfaces & Ohmic contacts (1D).","text":"","category":"section"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"PSC device with graded interfaces & Ohmic contacts (1D).","title":"PSC device with graded interfaces & Ohmic contacts (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"PSC device with graded interfaces & Ohmic contacts (1D).","title":"PSC device with graded interfaces & Ohmic contacts (1D).","text":"Simulating a three layer PSC device SiO2| MAPI | SiO2 without mobile ions. The simulations are performed out of equilibrium, stationary and with two junctions between perovskite layer and transport layers, to which we refer as graded interfaces. Hence, a graded flux discretization with space dependent band-edge energies and density of states is tested here. The difference here is that we adjusted the order of indexing the quasi Fermi potentials.","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"PSC device with graded interfaces & Ohmic contacts (1D).","title":"PSC device with graded interfaces & Ohmic contacts (1D).","text":"The parameters can be found in Table S.13, https://arxiv.org/abs/2009.04384. Or here: https://github.com/barnesgroupICL/Driftfusion/blob/Methods-IonMonger-Comparison/Inputfiles/IonMongerdefault_bulk.csv","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"PSC device with graded interfaces & Ohmic contacts (1D).","title":"PSC device with graded interfaces & Ohmic contacts (1D).","text":"module Ex105_PSC_gradedFlux\n\nusing VoronoiFVM\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing PyPlot\n\n# function for grading the physical parameters\nfunction grading_parameter!(physicalParameter, coord, regionTransportLayers, regionJunctions, h, heightLayers, lengthLayers, values)\n    for ireg in regionTransportLayers\n\n        xcoord                     = lengthLayers[ireg]:lengthLayers[ireg+1]\n        physicalParameter[xcoord] .= values[ireg]\n\n    end\n\n    for ireg in regionJunctions\n\n        xcoord   = lengthLayers[ireg]:lengthLayers[ireg+1]\n        left     = lengthLayers[ireg]-3\n        junction = h[ireg]\n        right    = lengthLayers[ireg+2]-3\n\n        gradient = ( physicalParameter[right] - physicalParameter[left] ) / junction\n\n        for index in xcoord\n            physicalParameter[index] = physicalParameter[left] + (coord[index] - heightLayers[ireg-1]) * gradient\n        end\n\n    end\n\n    return physicalParameter\nend\n\nfunction main(;n = 2, Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage=:sparse)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionDonor           = 1          # n doped region\n    regionJunction1       = 2\n    regionIntrinsic       = 3          # intrinsic region\n    regionJunction2       = 4\n    regionAcceptor        = 5          # p doped region\n    regions               = [regionDonor, regionJunction1, regionIntrinsic, regionJunction2, regionAcceptor]\n    regionTransportLayers = [regionDonor, regionIntrinsic, regionAcceptor]\n    regionJunctions       = [regionJunction1, regionJunction2]\n    numberOfRegions       = length(regions)\n\n    # boundary region numbers\n    bregionDonor          = 1\n    bregionAcceptor       = 2\n\n    # grid\n    h_ndoping             = 9.90e-6 * cm\n    h_junction1           = 1.0e-7  * cm\n    h_intrinsic           = 4.00e-5 * cm\n    h_junction2           = 1.0e-7  * cm\n    h_pdoping             = 1.99e-5 * cm\n    h                     = [h_ndoping, h_junction1, h_intrinsic, h_junction2, h_pdoping]\n    heightLayers          = [h_ndoping,\n                             h_ndoping + h_junction1,\n                             h_ndoping + h_junction1 + h_intrinsic,\n                             h_ndoping + h_junction1 + h_intrinsic + h_junction2,\n                             h_ndoping + h_junction1 + h_intrinsic + h_junction2 + h_pdoping]\n    refinementfactor      = 2^(n-1)\n\n    coord_ndoping         = collect(range(0.0, stop = h_ndoping, length = 4 * refinementfactor))\n    length_n              = length(coord_ndoping)\n    coord_junction1       = collect(range(h_ndoping,\n                                         stop = h_ndoping + h_junction1,\n                                         length = 3 * refinementfactor))\n    coord_intrinsic       = collect(range(h_ndoping + h_junction1,\n                                         stop = (h_ndoping + h_junction1 + h_intrinsic),\n                                         length = 10 * refinementfactor))\n    coord_junction2       = collect(range(h_ndoping + h_junction1 + h_intrinsic,\n                                         stop = (h_ndoping + h_junction1 + h_intrinsic + h_junction2),\n                                         length = 3 * refinementfactor))\n    coord_pdoping         = collect(range((h_ndoping + h_junction1 + h_intrinsic + h_junction2),\n                                          stop = (h_ndoping + h_junction1 + h_intrinsic + h_junction2 + h_pdoping),\n                                          length = 4 * refinementfactor))\n\n    coord                 = glue(coord_ndoping, coord_junction1)\n    length_j1             = length(coord)\n    coord                 = glue(coord, coord_intrinsic)\n    length_i              = length(coord)\n    coord                 = glue(coord, coord_junction2)\n    length_j2             = length(coord)\n    coord                 = glue(coord, coord_pdoping)\n\n    grid                  = simplexgrid(coord)\n    numberOfNodes         = length(coord)\n    lengthLayers          = [1, length_n, length_j1, length_i, length_j2, numberOfNodes]\n\n    # set different regions in grid, doping profiles do not intersect\n    cellmask!(grid, [0.0 * μm],        [heightLayers[1]], regionDonor)      # n-doped region   = 1\n    cellmask!(grid, [heightLayers[1]], [heightLayers[2]], regionJunction1)  # first junction   = 2\n    cellmask!(grid, [heightLayers[2]], [heightLayers[3]], regionIntrinsic)  # intrinsic region = 3\n    cellmask!(grid, [heightLayers[3]], [heightLayers[4]], regionJunction2)  # sec. junction    = 4\n    cellmask!(grid, [heightLayers[4]], [heightLayers[5]], regionAcceptor)   # p-doped region   = 5\n\n    if plotting\n        gridplot(grid, Plotter = Plotter)\n        Plotter.title(\"Grid\")\n        Plotter.figure()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin            = 2 # electron quasi Fermi potential\n    iphip            = 1 # hole quasi Fermi potential\n    numberOfCarriers = 2\n\n    # temperature\n    T                = 300.0                 *  K\n\n    # band edge energies\n    Ec_d             = -4.0                  *  eV\n    Ev_d             = -6.0                  *  eV\n\n    Ec_i             = -3.7                  *  eV\n    Ev_i             = -5.4                  *  eV\n\n    Ec_a             = -3.1                  *  eV\n    Ev_a             = -5.1                  *  eV\n\n    # these parameters at the junctions for E_\\alpha and N_\\alpha will be overwritten.\n    Ec_j1            = Ec_d;     Ec_j2     = Ec_i\n    Ev_j1            = Ev_d;     Ev_j2     = Ev_i\n\n    EC               = [Ec_d, Ec_j1, Ec_i, Ec_j2, Ec_a]\n    EV               = [Ev_d, Ev_j1, Ev_i, Ev_j2, Ev_a]\n\n    # effective densities of state\n    Nc_d             = 5.0e19                / (cm^3)\n    Nv_d             = 5.0e19                / (cm^3)\n\n    Nc_i             = 8.1e18                / (cm^3)\n    Nv_i             = 5.8e18                / (cm^3)\n\n    Nc_a             = 5.0e19                / (cm^3)\n    Nv_a             = 5.0e19                / (cm^3)\n\n    Nc_j1            = Nc_d;     Nc_j2      = Nc_i\n    Nv_j1            = Nv_d;     Nv_j2      = Nv_i\n\n    NC               = [Nc_d, Nc_j1, Nc_i, Nc_j2, Nc_a]\n    NV               = [Nv_d, Nv_j1, Nv_i, Nv_j2, Nv_a]\n\n    # mobilities\n    μn_d             = 3.89                  * (cm^2) / (V * s)\n    μp_d             = 3.89                  * (cm^2) / (V * s)\n\n    μn_i             = 6.62e1                * (cm^2) / (V * s)\n    μp_i             = 6.62e1                * (cm^2) / (V * s)\n\n    μn_a             = 3.89e-1               * (cm^2) / (V * s)\n    μp_a             = 3.89e-1               * (cm^2) / (V * s)\n\n    μn_j1            = μn_d;     μn_j2      = μn_i\n    μp_j1            = μp_d;     μp_j2      = μp_i\n\n    μn               = [μn_d, μn_j1, μn_i, μn_j2, μn_a]\n    μp               = [μp_d, μp_j1, μp_i, μp_j2, μp_a]\n\n    # relative dielectric permittivity\n    ε_d              = 10.0                  *  1.0\n    ε_i              = 24.1                  *  1.0\n    ε_a              = 3.0                   *  1.0\n\n    ε_j1             = ε_d;       ε_j2      = ε_a\n\n    ε                = [ε_d, ε_j1, ε_i, ε_j2, ε_a]\n\n    # radiative recombination\n    r0_d             = 0.0e+0               * cm^3 / s\n    r0_i             = 1.0e-12              * cm^3 / s\n    r0_a             = 0.0e+0               * cm^3 / s\n\n    r0_j1            = r0_i;      r0_j2     = r0_i\n\n    r0               = [r0_d, r0_j1, r0_i, r0_j2, r0_a]\n\n    # life times and trap densities\n    τn_d             = 1.0e100              * s\n    τp_d             = 1.0e100              * s\n\n    τn_i             = 3.0e-10              * s\n    τp_i             = 3.0e-8               * s\n    τn_a             = τn_d\n    τp_a             = τp_d\n\n    τn_j1            = τn_i;     τn_j2      = τn_a\n    τp_j1            = τp_i;     τp_j2      = τp_a\n\n    τn               = [τn_d, τn_j1, τn_i, τn_j2, τn_a]\n    τp               = [τp_d, τp_j1, τp_i, τp_j2, τp_a]\n\n    # SRH trap energies (needed for calculation of trap_density! (SRH))\n    Ei_d             = -5.0                 * eV\n    Ei_i             = -4.55                * eV\n    Ei_a             = -4.1                 * eV\n\n    Ei_j1            = Ei_i;      Ei_j2     = Ei_a\n\n    EI               = [Ei_d, Ei_j1, Ei_i, Ei_j2, Ei_a]\n\n    # Auger recombination\n    Auger            = 0.0\n\n    # doping (doping values are from Driftfusion)\n    Nd               = 1.03e18             / (cm^3)\n    Na               = 1.03e18             / (cm^3)\n    Ni_acceptor      = 8.32e7              / (cm^3)\n\n    # contact voltage\n    voltageAcceptor  = 1.2                 * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Stationary\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F                            .= Boltzmann\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = false,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceModelNone,\n    # InterfaceModelSurfaceReco (inner boundary).\n    data.boundaryType[bregionDonor]    = OhmicContact\n    data.boundaryType[bregionAcceptor] = OhmicContact\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation             = ScharfetterGummelGraded\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    # for region dependent parameters\n    params                                = Params(grid, numberOfCarriers)\n    # for space dependent parameters\n    paramsnodal                           = ParamsNodal(grid, numberOfCarriers)\n\n    params.temperature                    = T\n    params.UT                             = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]           = -1\n    params.chargeNumbers[iphip]           =  1\n\n    # nodal band-edge energies\n    paramsnodal.bandEdgeEnergy[iphin, :]  = grading_parameter!(paramsnodal.bandEdgeEnergy[iphin, :],\n                                                              coord, regionTransportLayers, regionJunctions, h,\n                                                              heightLayers, lengthLayers, EC)\n    paramsnodal.bandEdgeEnergy[iphip, :]  = grading_parameter!(paramsnodal.bandEdgeEnergy[iphip, :],\n                                                              coord, regionTransportLayers, regionJunctions, h,\n                                                              heightLayers, lengthLayers, EV)\n    # nodal effective density of states\n    paramsnodal.densityOfStates[iphin, :] = grading_parameter!(paramsnodal.densityOfStates[iphin, :],\n                                                              coord, regionTransportLayers, regionJunctions, h,\n                                                              heightLayers, lengthLayers, NC)\n    paramsnodal.densityOfStates[iphip, :] = grading_parameter!(paramsnodal.densityOfStates[iphip, :],\n                                                              coord, regionTransportLayers, regionJunctions, h,\n                                                              heightLayers, lengthLayers, NV)\n    # region dependent data\n    for ireg in 1:numberOfRegions\n\n        # mobility\n        params.mobility[iphin, ireg]                    = μn[ireg]\n        params.mobility[iphip, ireg]                    = μp[ireg]\n\n        params.dielectricConstant[ireg]                 = ε[ireg]\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]    = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = trap_density!(iphin, ireg, data, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg] = trap_density!(iphip, ireg, data, EI[ireg])\n        params.recombinationAuger[iphin, ireg]          = Auger\n        params.recombinationAuger[iphip, ireg]          = Auger\n\n    end\n\n    # interior doping\n    params.doping[iphin, regionDonor]      = Nd\n    params.doping[iphip, regionIntrinsic]  = Ni_acceptor\n    params.doping[iphip, regionAcceptor]   = Na\n\n    # boundary doping\n    params.bDoping[iphip, bregionAcceptor] = Na\n    params.bDoping[iphin, bregionDonor]    = Nd\n\n    data.params                            = params\n    data.paramsnodal                       = paramsnodal\n    ctsys                                  = System(grid, data, unknown_storage=unknown_storage)\n\n    # print data\n    if test == false\n        show_params(ctsys)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define outer boundary conditions\")\n    end\n    ################################################################################\n\n    # set zero voltage ohmic contacts for each charge carrier at all outer boundaries.\n    set_contact!(ctsys, bregionDonor,    Δu = 0.0)\n    set_contact!(ctsys, bregionAcceptor, Δu = 0.0)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Newton solver\")\n    end\n    ################################################################################\n\n    control                   = NewtonControl()\n    control.verbose           = verbose\n    control.max_iterations    = 300\n    control.tol_absolute      = 1.0e-13\n    control.tol_relative      = 1.0e-13\n    control.handle_exceptions = true\n    control.tol_round         = 1.0e-13\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    control.damp_initial = 0.5\n    control.damp_growth  = 1.61 # >= 1\n    control.max_round    = 5\n\n    initialGuess         = unknowns(ctsys)\n    solution             = unknowns(ctsys)\n\n    solution             = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)\n\n    initialGuess        .= solution\n\n    if plotting\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        plot_energies(Plotter,  grid, data, solution, \"Equilibrium\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution, \"Equilibrium\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter,  grid, data, solution, \"Equilibrium\", label_solution)\n        Plotter.figure()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################\n\n    data.calculationType = OutOfEquilibrium\n\n    control.damp_initial = 0.9\n    control.damp_growth  = 1.61 # >= 1\n    control.max_round    = 7\n\n    maxBias    = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    biasValues = range(0, stop = maxBias, length = 13)\n\n    for Δu in biasValues\n        if test == false\n            println(\"Bias value: Δu = $(Δu)\")\n        end\n\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        solve!(solution, initialGuess, ctsys, control  = control, tstep = Inf)\n\n        initialGuess .= solution\n\n    end # bias loop\n\n    # plotting\n    if plotting\n        plot_energies(Plotter, grid, data, solution, \"Applied voltage Δu = $maxBias\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution, \"Applied voltage Δu = $maxBias\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, grid, data, solution, \"Applied voltage Δu = $maxBias\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = solution[data.index_psi, 20]\n    return testval\n\nend #  main\n\nfunction test()\n    testval=-3.9827484795022645\n    main(test = true, unknown_storage=:dense) ≈ testval && main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"PSC device with graded interfaces & Ohmic contacts (1D).","title":"PSC device with graded interfaces & Ohmic contacts (1D).","text":"","category":"page"},{"location":"examples/Ex105_PSC_gradedFlux/","page":"PSC device with graded interfaces & Ohmic contacts (1D).","title":"PSC device with graded interfaces & Ohmic contacts (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Ex103_PSC/#PSC-device-without-mobile-ions-(1D).","page":"PSC device without mobile ions (1D).","title":"PSC device without mobile ions (1D).","text":"","category":"section"},{"location":"examples/Ex103_PSC/","page":"PSC device without mobile ions (1D).","title":"PSC device without mobile ions (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex103_PSC/","page":"PSC device without mobile ions (1D).","title":"PSC device without mobile ions (1D).","text":"Simulating a three layer PSC device SiO2| MAPI | SiO2 without mobile ions and in stationary state. We consider heterojunctions. The simulations are performed out of equilibrium and with abrupt interfaces. For simplicity, the generation is off.","category":"page"},{"location":"examples/Ex103_PSC/","page":"PSC device without mobile ions (1D).","title":"PSC device without mobile ions (1D).","text":"This simulation coincides with the one made in Section 4.3 of Calado et al. (https://arxiv.org/abs/2009.04384) with the parameters in Table S.13. Or here: https://github.com/barnesgroupICL/Driftfusion/blob/Methods-IonMonger-Comparison/Inputfiles/IonMongerdefault_bulk.csv","category":"page"},{"location":"examples/Ex103_PSC/","page":"PSC device without mobile ions (1D).","title":"PSC device without mobile ions (1D).","text":"module Ex103_PSC\n\nusing VoronoiFVM\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing PyPlot\n\nfunction main(;n = 3, Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage=:sparse)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionDonor     = 1                           # n doped region\n    regionIntrinsic = 2                           # intrinsic region\n    regionAcceptor  = 3                           # p doped region\n    regions         = [regionDonor, regionIntrinsic, regionAcceptor]\n    numberOfRegions = length(regions)\n\n    # boundary region numbers\n    bregionDonor    = 1\n    bregionAcceptor = 2\n\n    h_ndoping       = 9.90e-6 * cm\n    h_intrinsic     = 4.00e-5 * cm + 2.0e-7 * cm # add 2.e-7 cm to this layer for agreement with grid of Driftfusion\n    h_pdoping       = 1.99e-5 * cm\n\n    x0              = 0.0 * cm\n    δ               = 2*n        # the larger, the finer the mesh\n    t               = 0.5*(cm)/δ # tolerance for geomspace and glue (with factor 10)\n    k               = 1.5        # the closer to 1, the closer to the boundary geomspace works\n\n    coord_n_u       = collect(range(x0, h_ndoping/2, step=h_ndoping/(0.8*δ)))\n    coord_n_g       = geomspace(h_ndoping/2,\n                                h_ndoping,\n                                h_ndoping/(1.0*δ),\n                                h_ndoping/(1.0*δ),\n                                tol=t)\n    coord_i_g1      = geomspace(h_ndoping,\n                                h_ndoping+h_intrinsic/k,\n                                h_intrinsic/(2.8*δ),\n                                h_intrinsic/(2.0*δ),\n                                tol=t)\n    coord_i_g2      = geomspace(h_ndoping+h_intrinsic/k,\n                                h_ndoping+h_intrinsic,\n                                h_intrinsic/(2.0*δ),\n                                h_intrinsic/(2.8*δ),\n                                tol=t)\n    coord_p_g       = geomspace(h_ndoping+h_intrinsic,\n                                h_ndoping+h_intrinsic+h_pdoping/2,\n                                h_pdoping/(1.6*δ),\n                                h_pdoping/(1.6*δ),\n                                tol=t)\n    coord_p_u       = collect(range(h_ndoping+h_intrinsic+h_pdoping/2, h_ndoping+h_intrinsic+h_pdoping, step=h_pdoping/(1.3*δ)))\n\n    coord           = glue(coord_n_u, coord_n_g,  tol=10*t)\n    coord           = glue(coord,     coord_i_g1, tol=10*t)\n    coord           = glue(coord,     coord_i_g2, tol=10*t)\n    coord           = glue(coord,     coord_p_g,  tol=10*t)\n    coord           = glue(coord,     coord_p_u,  tol=10*t)\n    grid            = simplexgrid(coord)\n\n\n    # set different regions in grid, doping profiles do not intersect\n    cellmask!(grid, [0.0 * μm],                [h_ndoping],                           regionDonor)     # n-doped region   = 1\n    cellmask!(grid, [h_ndoping],               [h_ndoping + h_intrinsic],             regionIntrinsic) # intrinsic region = 2\n    cellmask!(grid, [h_ndoping + h_intrinsic], [h_ndoping + h_intrinsic + h_pdoping], regionAcceptor)  # p-doped region   = 3\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend=:lt)\n        Plotter.title(\"Grid\")\n        Plotter.figure()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin            = 2 # electron quasi Fermi potential\n    iphip            = 1 # hole quasi Fermi potential\n    numberOfCarriers = 2","category":"page"},{"location":"examples/Ex103_PSC/","page":"PSC device without mobile ions (1D).","title":"PSC device without mobile ions (1D).","text":"Define the physical data.","category":"page"},{"location":"examples/Ex103_PSC/","page":"PSC device without mobile ions (1D).","title":"PSC device without mobile ions (1D).","text":"    # temperature\n    T                = 300.0                 *  K\n\n    # band edge energies\n    Ec_d             = -4.0                  *  eV\n    Ev_d             = -6.0                  *  eV\n\n    Ec_i             = -3.7                  *  eV\n    Ev_i             = -5.4                  *  eV\n\n    Ec_a             = -3.1                  *  eV\n    Ev_a             = -5.1                  *  eV\n\n    EC               = [Ec_d, Ec_i, Ec_a]\n    EV               = [Ev_d, Ev_i, Ev_a]\n\n    # effective densities of state\n    Nc_d             = 5.0e19                / (cm^3)\n    Nv_d             = 5.0e19                / (cm^3)\n\n    Nc_i             = 8.1e18                / (cm^3)\n    Nv_i             = 5.8e18                / (cm^3)\n\n    Nc_a             = 5.0e19                / (cm^3)\n    Nv_a             = 5.0e19                / (cm^3)\n\n    NC               = [Nc_d, Nc_i, Nc_a]\n    NV               = [Nv_d, Nv_i, Nv_a]\n\n    # mobilities\n    μn_d             = 3.89                  * (cm^2) / (V * s)\n    μp_d             = 3.89                  * (cm^2) / (V * s)\n\n    μn_i             = 6.62e1                * (cm^2) / (V * s)\n    μp_i             = 6.62e1                * (cm^2) / (V * s)\n\n    μn_a             = 3.89e-1               * (cm^2) / (V * s)\n    μp_a             = 3.89e-1               * (cm^2) / (V * s)\n\n    μn               = [μn_d, μn_i, μn_a]\n    μp               = [μp_d, μp_i, μp_a]\n\n    # relative dielectric permittivity\n\n    ε_d              = 10.0                  *  1.0\n    ε_i              = 24.1                  *  1.0\n    ε_a              = 3.0                   *  1.0\n\n    ε                = [ε_d, ε_i, ε_a]\n\n    # radiative recombination\n    r0_d             = 0.0e+0               * cm^3 / s\n    r0_i             = 1.0e-12              * cm^3 / s\n    r0_a             = 0.0e+0               * cm^3 / s\n\n    r0               = [r0_d, r0_i, r0_a]\n\n    # life times and trap densities\n    τn_d             = 1.0e100              * s\n    τp_d             = 1.0e100              * s\n\n    τn_i             = 3.0e-10              * s\n    τp_i             = 3.0e-8               * s\n    τn_a             = τn_d\n    τp_a             = τp_d\n\n    τn               = [τn_d, τn_i, τn_a]\n    τp               = [τp_d, τp_i, τp_a]\n\n    # SRH trap energies (needed for calculation of trap_density! (SRH))\n    Ei_d             = -5.0                 * eV\n    Ei_i             = -4.55                * eV\n    Ei_a             = -4.1                 * eV\n\n    EI               = [Ei_d, Ei_i, Ei_a]\n\n    # Auger recombination\n    Auger            = 0.0\n\n    # doping\n    Nd               =   1.03e18             / (cm^3)\n    Na               =   1.03e18             / (cm^3)\n    Ni_acceptor      =   8.32e7              / (cm^3)\n\n    # contact voltage: we impose an applied voltage only on one boundary.\n    # At the other boundary the applied voltage is zero.\n    voltageAcceptor  =  1.2                  * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################","category":"page"},{"location":"examples/Ex103_PSC/","page":"PSC device without mobile ions (1D).","title":"PSC device without mobile ions (1D).","text":"We initialize the Data instance and fill in predefined data.","category":"page"},{"location":"examples/Ex103_PSC/","page":"PSC device without mobile ions (1D).","title":"PSC device without mobile ions (1D).","text":"    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Stationary\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk,\n    # FermiDiracOneHalfTeSCA, FermiDiracMinusOne, Blakemore\n    data.F                            .= FermiDiracOneHalfTeSCA\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = true,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = false)\n\n    # Possible choices: OhmicContact, SchottkyContact(outer boundary) and InterfaceModelNone,\n    # InterfaceModelSurfaceReco (inner boundary).\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation             = ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                          = Params(grid, numberOfCarriers)\n\n    params.temperature                              = T\n    params.UT                                       = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                     = -1\n    params.chargeNumbers[iphip]                     =  1\n\n    # boundary region data\n    params.bDensityOfStates[iphin, bregionDonor]    = Nc_d\n    params.bDensityOfStates[iphip, bregionDonor]    = Nv_d\n\n    params.bDensityOfStates[iphin, bregionAcceptor] = Nc_a\n    params.bDensityOfStates[iphip, bregionAcceptor] = Nv_a\n\n    params.bBandEdgeEnergy[iphin, bregionDonor]     = Ec_d\n    params.bBandEdgeEnergy[iphip, bregionDonor]     = Ev_d\n\n    params.bBandEdgeEnergy[iphin, bregionAcceptor]  = Ec_a\n    params.bBandEdgeEnergy[iphip, bregionAcceptor]  = Ev_a\n\n    # interior region data\n    for ireg in 1:numberOfRegions\n\n        params.dielectricConstant[ireg]                 = ε[ireg]\n\n        # effective DOS, band edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = NC[ireg]\n        params.densityOfStates[iphip, ireg]             = NV[ireg]\n\n        params.bandEdgeEnergy[iphin, ireg]              = EC[ireg]\n        params.bandEdgeEnergy[iphip, ireg]              = EV[ireg]\n\n        params.mobility[iphin, ireg]                    = μn[ireg]\n        params.mobility[iphip, ireg]                    = μp[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]    = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = trap_density!(iphin, ireg, data, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg] = trap_density!(iphip, ireg, data, EI[ireg])\n        params.recombinationAuger[iphin, ireg]          = Auger\n        params.recombinationAuger[iphip, ireg]          = Auger\n    end\n\n    # interior doping\n    params.doping[iphin, regionDonor]               = Nd\n    params.doping[iphip, regionIntrinsic]           = Ni_acceptor\n    params.doping[iphip, regionAcceptor]            = Na\n\n    # boundary doping\n    params.bDoping[iphip, bregionAcceptor]          = Na        # data.bDoping  = [Na  0.0;\n    params.bDoping[iphin, bregionDonor]             = Nd        #                  0.0  Nd]\n\n    data.params                                     = params\n    ctsys                                           = System(grid, data, unknown_storage=unknown_storage)\n\n    # print data\n    if test == false\n        show_params(ctsys)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define outer boundary conditions\")\n    end\n    ################################################################################\n\n    # We set zero voltage ohmic contacts for each charge carrier at all outer boundaries\n    # for the equilibrium calculations.\n    set_contact!(ctsys, bregionAcceptor, Δu = 0.0)\n    set_contact!(ctsys, bregionDonor,    Δu = 0.0)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Newton solver\")\n    end\n    ################################################################################\n\n    control                   = NewtonControl()\n    control.verbose           = verbose\n    control.max_iterations    = 300\n    control.tol_absolute      = 1.0e-13\n    control.tol_relative      = 1.0e-13\n    control.handle_exceptions = true\n    control.tol_round         = 1.0e-13\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    control.damp_initial  = 0.8\n    control.damp_growth   = 1.61 # >= 1\n    control.max_round     = 5\n\n    # initialize solution and starting vectors\n    initialGuess          = unknowns(ctsys)\n    solution              = unknowns(ctsys)\n\n    solution              = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)\n\n    initialGuess         .= solution\n\n    if plotting\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        plot_energies(Plotter,  grid, data, solution, \"Equilibrium\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution, \"Equilibrium\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter,  grid, data, solution, \"Equilibrium\", label_solution)\n        Plotter.figure()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################\n\n    data.calculationType = OutOfEquilibrium\n\n    control.damp_initial = 0.6\n    control.damp_growth  = 1.21 # >= 1\n    control.max_round    = 7\n\n    maxBias    = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    biasValues = range(0, stop = maxBias, length = 13)\n\n    for Δu in biasValues\n        if test == false\n            println(\"Bias value: Δu = $(Δu)\")\n        end\n\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        solve!(solution, initialGuess, ctsys, control  = control, tstep = Inf)\n\n        initialGuess .= solution\n\n    end # bias loop\n\n    # plotting\n    if plotting\n        plot_energies(Plotter,  grid, data, solution, \"Applied voltage Δu = $maxBias\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution, \"Applied voltage Δu = $maxBias\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter,  grid, data, solution, \"Applied voltage Δu = $maxBias\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = VoronoiFVM.norm(ctsys.fvmsys, solution, 2)\n    return testval\n\nend #  main\n\nfunction test()\n    testval = 22.166685901417342\n    main(test = true, unknown_storage=:dense) ≈ testval && main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex103_PSC/","page":"PSC device without mobile ions (1D).","title":"PSC device without mobile ions (1D).","text":"","category":"page"},{"location":"examples/Ex103_PSC/","page":"PSC device without mobile ions (1D).","title":"PSC device without mobile ions (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"general/#ChargeTransport.jl-–-Simulating-charge-transport-in-semiconductors","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"","category":"section"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"(Image: Build status) (Image: ) (Image: )","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"ChargeTransport.jl simulates charge transport in semiconductors. To this end, it discretizes the semiconductor drift-diffusion equations via the Voronoi finite volume method as implemented in VoronoiFVM.jl.","category":"page"},{"location":"general/#Special-features","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"Special features","text":"","category":"section"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"heterostructures\n1D, 2D and 3D simulations\nstationary and transient simulations\nIV curves and scan protocols\nan arbitrary amount of charge carriers (electrons, heavy holes, light holes, ions, ...)\nthermodynamically consistent, physics preserving numerical methods\ndifferent charge carrier statistics per species (Boltzmann, Blakemore, Fermi-Dirac)\nAuger, radiative, Shockley-Read-Hall recombination including transient traps\nuniform and Beer-Lambert generation","category":"page"},{"location":"general/#Installation-and-first-steps","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"Installation and first steps","text":"","category":"section"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"The installation can easily be done via the Julia REPL with the following commands","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"julia> using Pkg\njulia> Pkg.add(\"ChargeTransport\")","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"The following packages need to be loaded","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"julia> using ChargeTransport\njulia> using VoronoiFVM      # nonlinear PDE solver\njulia> using ExtendableGrids # grid package","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"We recommend to have a look at the example files:","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"Pages = [\n    \"GaAs.md\",\n    \"PSC.md\",\n    ]\nDepth = 2","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"You can load an example as follows","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"julia> include(\"Ex103_PSC.jl\")\njulia> Ex103_PSC.main()\njulia> Ex103_PSC.main(plotting = true) # show plots","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"Since the examples are encapsulated into modules, you can load as many examples as you wish. If you would like to modify one of the examples, consider using Revise.jl and includet.","category":"page"},{"location":"general/#Literature","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"Literature","text":"","category":"section"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"The simulations in the following papers are based on ChargeTransport.jl:","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"[1] D. Abdel, P. Farrell and J. Fuhrmann. Assessing the quality of the excess chemical potential flux scheme for degenerate semiconductor device simulation. Optical and Quantum Electronics 53 (163) (2021).","category":"page"},{"location":"general/","page":"ChargeTransport.jl – Simulating charge transport in semiconductors","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"[2] D. Abdel, P. Vágner, J. Fuhrmann and P. Farrell. Modelling charge transport in perovskite solar cells: Potential-based and limiting ion depletion. Electrochimica Acta 390 (2021).","category":"page"},{"location":"examples/Ex107_PSC_withIons_sinusoidalVoltage/#PSC-device-with-sinusoidal-applied-voltage-(1D).","page":"PSC device with sinusoidal applied voltage (1D).","title":"PSC device with sinusoidal applied voltage (1D).","text":"","category":"section"},{"location":"examples/Ex107_PSC_withIons_sinusoidalVoltage/","page":"PSC device with sinusoidal applied voltage (1D).","title":"PSC device with sinusoidal applied voltage (1D).","text":"(source code)","category":"page"},{"location":"examples/Ex107_PSC_withIons_sinusoidalVoltage/","page":"PSC device with sinusoidal applied voltage (1D).","title":"PSC device with sinusoidal applied voltage (1D).","text":"Simulating a three layer PSC device Pedot| MAPI | PCBM. The simulations are performed out of equilibrium, time-dependent and with abrupt interfaces. A sinusoidal I-V measurement protocol is included and the corresponding solution vectors after the scan can be depicted.","category":"page"},{"location":"examples/Ex107_PSC_withIons_sinusoidalVoltage/","page":"PSC device with sinusoidal applied voltage (1D).","title":"PSC device with sinusoidal applied voltage (1D).","text":"The paramters are from Calado et al.: https://github.com/barnesgroupICL/Driftfusion/blob/master/Inputfiles/pedotpssmapi_pcbm.csv. (with adjustments on layer lengths)","category":"page"},{"location":"examples/Ex107_PSC_withIons_sinusoidalVoltage/","page":"PSC device with sinusoidal applied voltage (1D).","title":"PSC device with sinusoidal applied voltage (1D).","text":"module Ex107_PSC_withIons_sinusoidalVoltage\n\nusing VoronoiFVM\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing PyPlot\n\nfunction main(;n = 2, Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage=:dense)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionAcceptor  = 1                           # p doped region\n    regionIntrinsic = 2                           # intrinsic region\n    regionDonor     = 3                           # n doped region\n    regions         = [regionAcceptor, regionIntrinsic, regionDonor]\n    numberOfRegions = length(regions)\n\n    # boundary region numbers\n    bregionAcceptor = 1\n    bregionDonor    = 2\n\n    # grid\n    h_pdoping       = 3.00e-6 * cm + 1.0e-7 *cm # add 1.e-7 cm to this layer for agreement with grid of Driftfusion\n    h_intrinsic     = 3.00e-5 * cm\n    h_ndoping       = 8.50e-6 * cm + 1.0e-7 *cm # add 1.e-7 cm to this layer for agreement with grid of Driftfusion\n\n    x0              = 0.0 * cm\n    δ               = 4*n        # the larger, the finer the mesh\n    t               = 0.5*(cm)/δ # tolerance for geomspace and glue (with factor 10)\n    k               = 1.5        # the closer to 1, the closer to the boundary geomspace works\n\n    coord_p_u       = collect(range(x0, h_pdoping/2, step=h_pdoping/(0.6*δ)))\n    coord_p_g       = geomspace(h_pdoping/2,\n                                h_pdoping,\n                                h_pdoping/(0.8*δ),\n                                h_pdoping/(0.6*δ),\n                                tol=t)\n    coord_i_g1      = geomspace(h_pdoping,\n                                h_pdoping+h_intrinsic/k,\n                                h_intrinsic/(6.1*δ),\n                                h_intrinsic/(2.1*δ),\n                                tol=t)\n    coord_i_g2      = geomspace(h_pdoping+h_intrinsic/k,\n                                h_pdoping+h_intrinsic,\n                                h_intrinsic/(2.1*δ),\n                                h_intrinsic/(6.1*δ),\n                                tol=t)\n    coord_n_g       = geomspace(h_pdoping+h_intrinsic,\n                                h_pdoping+h_intrinsic+h_ndoping/2,\n                                h_ndoping/(1.5*δ),\n                                h_ndoping/(0.9*δ),\n                                tol=t)\n    coord_n_u       = collect(range(h_pdoping+h_intrinsic+h_ndoping/2, h_pdoping+h_intrinsic+h_ndoping, step=h_pdoping/(0.5*δ)))\n\n    coord           = glue(coord_p_u, coord_p_g,  tol=10*t)\n    coord           = glue(coord,     coord_i_g1, tol=10*t)\n    coord           = glue(coord,     coord_i_g2, tol=10*t)\n    coord           = glue(coord,     coord_n_g,  tol=10*t)\n    coord           = glue(coord,     coord_n_u,  tol=10*t)\n    grid            = simplexgrid(coord)\n\n    # set different regions in grid, doping profiles do not intersect\n    cellmask!(grid, [0.0 * μm],                [h_pdoping],                           regionAcceptor, tol = 1.0e-18)  # n-doped region   = 1\n    cellmask!(grid, [h_pdoping],               [h_pdoping + h_intrinsic],             regionIntrinsic, tol = 1.0e-18) # intrinsic region = 2\n    cellmask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic + h_ndoping], regionDonor, tol = 1.0e-18)     # p-doped region   = 3\n\n    if plotting\n        gridplot(grid, Plotter = Plotter)\n        Plotter.title(\"Grid\")\n        Plotter.figure()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin            = 1 # electron quasi Fermi potential\n    iphip            = 2 # hole quasi Fermi potential\n    iphia            = 3 # anion vacancy quasi Fermi potential\n    numberOfCarriers = 3 # electrons, holes and anion vacancies\n\n    # temperature\n    T                = 300.0                 *  K\n\n    # band edge energies\n    Ec_a             = -3.0                  *  eV\n    Ev_a             = -5.1                  *  eV\n\n    Ec_i             = -3.8                  *  eV\n    Ev_i             = -5.4                  *  eV\n\n    Ec_d             = -3.8                  *  eV\n    Ev_d             = -6.2                  *  eV\n\n    EC               = [Ec_a, Ec_i, Ec_d]\n    EV               = [Ev_a, Ev_i, Ev_d]\n\n    # effective densities of state\n    Nc_a             = 1.0e20                / (cm^3)\n    Nv_a             = 1.0e20                / (cm^3)\n\n    Nc_i             = 1.0e19                / (cm^3)\n    Nv_i             = 1.0e19                / (cm^3)\n\n    # ############ adjust Na, Ea for anion vacancies here ###########\n    Nanion           = 1.21e22               / (cm^3)\n    Ea_i             = -5.175                *  eV\n    # for the labels in the figures\n    textEa           = Ea_i./eV\n    textNa           = Nanion.*cm^3\n    # ############ adjust Na, Ea for anion vacancies here ###########\n\n    EA               = [0.0,  Ea_i,  0.0]\n\n    Nc_d             = 1.0e19                / (cm^3)\n    Nv_d             = 1.0e19                / (cm^3)\n\n    NC               = [Nc_a, Nc_i, Nc_d]\n    NV               = [Nv_a, Nv_i, Nv_d]\n    NAnion           = [0.0,  Nanion, 0.0]\n\n    # mobilities\n    μn_a             = 0.1                   * (cm^2) / (V * s)\n    μp_a             = 0.1                   * (cm^2) / (V * s)\n\n    μn_i             = 2.00e1                * (cm^2) / (V * s)\n    μp_i             = 2.00e1                * (cm^2) / (V * s)\n    μa_i             = 1.00e-10              * (cm^2) / (V * s)\n\n    μn_d             = 1.0e-3                * (cm^2) / (V * s)\n    μp_d             = 1.0e-3                * (cm^2) / (V * s)\n\n    μn               = [μn_a, μn_i, μn_d]\n    μp               = [μp_a, μp_i, μp_d]\n    μa               = [0.0,  μa_i, 0.0 ]\n\n    # relative dielectric permittivity\n    ε_a              = 4.0                   *  1.0\n    ε_i              = 23.0                  *  1.0\n    ε_d              = 3.0                   *  1.0\n\n    ε                = [ε_a, ε_i, ε_d]\n\n    # radiative recombination\n    r0_a             = 6.3e-11               * cm^3 / s\n    r0_i             = 3.6e-12               * cm^3 / s\n    r0_d             = 6.8e-11               * cm^3 / s\n\n    r0               = [r0_a, r0_i, r0_d]\n\n    # life times and trap densities\n    τn_a             = 1.0e-6                * s\n    τp_a             = 1.0e-6                * s\n\n    τn_i             = 1.0e-7                * s\n    τp_i             = 1.0e-7                * s\n    τn_d             = τn_a\n    τp_d             = τp_a\n\n    τn               = [τn_a, τn_i, τn_d]\n    τp               = [τp_a, τp_i, τp_d]\n\n    # SRH trap energies (needed for calculation of recombinationSRHTrapDensity)\n    Ei_a             = -4.05                * eV\n    Ei_i             = -4.60                * eV\n    Ei_d             = -5.00                * eV\n\n    EI               = [Ei_a, Ei_i, Ei_d]\n\n    # Auger recombination\n    Auger            = 0.0\n\n    # doping\n    Nd               = 2.089649130192123e17 / (cm^3)\n    Na               = 4.529587947185444e18 / (cm^3)\n    C0               = 1.0e18               / (cm^3)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    data                               = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType                     = Transient\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F                             = [Boltzmann, Boltzmann, FermiDiracMinusOne]\n\n    data.bulkRecombination             = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                                 bulk_recomb_Auger = true,\n                                                                 bulk_recomb_radiative = true,\n                                                                 bulk_recomb_SRH = true)\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceModelNone,\n    # InterfaceModelSurfaceReco (inner boundary).\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor]    = OhmicContact\n\n    # Present ionic vacancies in perovskite layer\n    data.enableIonicCarriers           = enable_ionic_carriers(ionic_carriers = [iphia], regions = [regionIntrinsic])\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation             = ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params                                              = Params(grid, numberOfCarriers)\n\n    params.temperature                                  = T\n    params.UT                                           = (kB * params.temperature) / q\n    params.chargeNumbers[iphin]                         = -1\n    params.chargeNumbers[iphip]                         =  1\n    params.chargeNumbers[iphia]                         =  1\n\n    # boundary region data\n    params.bDensityOfStates[iphin, bregionDonor]        = Nc_d\n    params.bDensityOfStates[iphip, bregionDonor]        = Nv_d\n\n    params.bDensityOfStates[iphin, bregionAcceptor]     = Nc_a\n    params.bDensityOfStates[iphip, bregionAcceptor]     = Nv_a\n\n    params.bBandEdgeEnergy[iphin, bregionDonor]         = Ec_d\n    params.bBandEdgeEnergy[iphip, bregionDonor]         = Ev_d\n\n    params.bBandEdgeEnergy[iphin, bregionAcceptor]      = Ec_a\n    params.bBandEdgeEnergy[iphip, bregionAcceptor]      = Ev_a\n\n\n    for ireg in 1:numberOfRegions # interior region data\n\n        params.dielectricConstant[ireg]                 = ε[ireg]\n\n        # effective DOS, band edge energy and mobilities\n        params.densityOfStates[iphin, ireg]             = NC[ireg]\n        params.densityOfStates[iphip, ireg]             = NV[ireg]\n        params.densityOfStates[iphia, ireg]             = NAnion[ireg]\n\n        params.bandEdgeEnergy[iphin, ireg]              = EC[ireg]\n        params.bandEdgeEnergy[iphip, ireg]              = EV[ireg]\n        params.bandEdgeEnergy[iphia, ireg]              = EA[ireg]\n\n        params.mobility[iphin, ireg]                    = μn[ireg]\n        params.mobility[iphip, ireg]                    = μp[ireg]\n        params.mobility[iphia, ireg]                    = μa[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg]             = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg]    = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg]    = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = trap_density!(iphin, ireg, data, EI[ireg])\n        params.recombinationSRHTrapDensity[iphip, ireg] = trap_density!(iphip, ireg, data, EI[ireg])\n        params.recombinationAuger[iphin, ireg]          = Auger\n        params.recombinationAuger[iphip, ireg]          = Auger\n\n    end\n\n    # interior doping\n    params.doping[iphin, regionDonor]                   = Nd\n    params.doping[iphia, regionIntrinsic]               = C0\n    params.doping[iphip, regionAcceptor]                = Na\n\n    # boundary doping\n    params.bDoping[iphip, bregionAcceptor]              = Na\n    params.bDoping[iphin, bregionDonor]                 = Nd\n\n    data.params                                         = params\n    ctsys                                               = System(grid, data, unknown_storage=unknown_storage)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define outer boundary conditions\")\n    end\n    ################################################################################\n\n    # set zero voltage ohmic contacts for electrons and holes at all outer boundaries.\n    set_contact!(ctsys, bregionAcceptor, Δu = 0.0)\n    set_contact!(ctsys, bregionDonor,    Δu = 0.0)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Newton solver\")\n    end\n    ################################################################################\n\n    control                   = VoronoiFVM.NewtonControl()\n    control.verbose           = verbose\n    control.max_iterations    = 300\n    control.tol_absolute      = 1.0e-10\n    control.tol_relative      = 1.0e-10\n    control.handle_exceptions = true\n    control.tol_round         = 1.0e-10\n    control.max_round         = 5\n    control.damp_initial      = 0.5\n    control.damp_growth       = 1.21 # >= 1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium for Boltzmann\")\n    end\n    ################################################################################\n\n    # initialize solution and starting vectors\n    initialGuess  = unknowns(ctsys)\n    solution      = unknowns(ctsys)\n\n    solution      = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 20)\n\n    initialGuess .= solution\n\n    if plotting\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        # add labels for anion vacancy\n        label_energy[1, iphia] = \"\\$E_a-q\\\\psi\\$\"; label_energy[2, iphia] = \"\\$ - q \\\\varphi_a\\$\"\n        label_density[iphia]   = \"a\";              label_solution[iphia]  = \"\\$ \\\\varphi_a\\$\"\n\n        plot_energies(Plotter, grid, data, solution, \"Equilibrium; \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution,\"Equilibrium; \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, grid, data, solution, \"Equilibrium; \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n     if test == false\n        println(\"IV Measurement loop\")\n    end\n    ################################################################################\n\n    data.calculationType = OutOfEquilibrium\n\n    control.damp_initial = 0.5\n    control.damp_growth  = 1.61 # >= 1\n    control.max_round    = 7\n\n    # time mesh\n    number_tsteps        = 50\n    endTime              = 1.0e-4 * s\n    tvalues              = range(0, stop = endTime, length = number_tsteps)\n\n    # sinusoidal applied voltage\n    frequence            = 0.11 * Hz\n    amplitude            = 10.0 * V\n    biasValues           = Float64[amplitude * sin(2.0 * pi * frequence * tvalues[i]) for i=1:number_tsteps]\n\n    # for saving I-V data\n    IV                   = zeros(0) # for IV values\n\n    for istep = 2:number_tsteps\n\n        t  = tvalues[istep]       # Actual time\n        Δu = biasValues[istep]    # Applied voltage\n        Δt = t - tvalues[istep-1] # Time step size\n\n        # Apply new voltage (set non equilibrium boundary conditions)\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: t = $(t)\")\n        end\n\n        # Solve time step problems with timestep Δt\n        solve!(solution, initialGuess, ctsys, control  = control, tstep = Δt)\n\n        # get I-V data\n        current = get_current_val(ctsys, solution, initialGuess, Δt)\n\n        push!(IV, current)\n\n        initialGuess .= solution\n\n    end # time loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    # here in res the biasValues and the corresponding current are stored.\n    # res = [biasValues IV];\n\n    if plotting\n        plot_energies(Plotter, grid, data, solution, \"Final time \\$ t \\$ = $(endTime); \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, grid, data, solution,\"Final time \\$ t \\$ = $(endTime); \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, grid, data, solution, \"Final time \\$ t \\$ = $(endTime); \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", label_solution)\n        Plotter.figure()\n        plot_IV(Plotter, biasValues,IV, \"Final time \\$ t \\$ = $(endTime); \\$E_a\\$ =$(textEa)eV; \\$N_a\\$ =$textNa\\$\\\\mathrm{cm}^{⁻3} \\$\", plotGridpoints = true)\n    end\n\n    testval = VoronoiFVM.norm(ctsys.fvmsys, solution, 2)\n    return testval\n\nend #  main\n\nfunction test()\n    testval = 31.906313312098675\n    main(test = true, unknown_storage=:dense) ≈ testval #&& main(test = true, unknown_storage=:sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"examples/Ex107_PSC_withIons_sinusoidalVoltage/","page":"PSC device with sinusoidal applied voltage (1D).","title":"PSC device with sinusoidal applied voltage (1D).","text":"","category":"page"},{"location":"examples/Ex107_PSC_withIons_sinusoidalVoltage/","page":"PSC device with sinusoidal applied voltage (1D).","title":"PSC device with sinusoidal applied voltage (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"}]
}
