<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CIGS: stationary with traps and Schottky contacts. · ChargeTransport.jl</title><meta name="title" content="CIGS: stationary with traps and Schottky contacts. · ChargeTransport.jl"/><meta property="og:title" content="CIGS: stationary with traps and Schottky contacts. · ChargeTransport.jl"/><meta property="twitter:title" content="CIGS: stationary with traps and Schottky contacts. · ChargeTransport.jl"/><meta name="description" content="Documentation for ChargeTransport.jl."/><meta property="og:description" content="Documentation for ChargeTransport.jl."/><meta property="twitter:description" content="Documentation for ChargeTransport.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../general/">ChargeTransport.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../general/">ChargeTransport.jl – Simulating charge transport in semiconductors</a></li><li><a class="tocitem" href="../../backgroundinfo/">Mathematical drift-diffusion models</a></li><li><span class="tocitem">How to get started</span><ul><li><a class="tocitem" href="../../GeneralInformation/">Code overview</a></li><li><a class="tocitem" href="../../GaAs/">van Roosbroeck system</a></li><li><a class="tocitem" href="../../PSC/">Perovskite solar cell</a></li></ul></li><li><a class="tocitem" href="../../allindex/">Types, Constructors and Methods</a></li><li><span class="tocitem">Pluto Notebooks</span><ul><li><a class="tocitem" href="../../nbhtml/PSC_example/">PSC example</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../Ex101_PIN/">GaAs diode (1D).</a></li><li><a class="tocitem" href="../Ex102_PIN_nodal_doping/">GaAs diode with spatially varying doping (1D).</a></li><li><a class="tocitem" href="../Ex103_PSC_IVMeasurement/">PSC device with ions and different I-V scan protocols (1D).</a></li><li><a class="tocitem" href="../Ex104_PSC_Photogeneration/">PSC device with photogeneration rate (1D).</a></li><li><a class="tocitem" href="../Ex105_PSC_gradedFlux/">Three-layer PSC device with graded interfaces &amp; Ohmic contacts (1D).</a></li><li><a class="tocitem" href="../Ex106_PSC_SurfaceRecombination/">PSC device with surface recombination (1D).</a></li><li><a class="tocitem" href="../Ex107_MoS2_withIons_BarrierLowering/">MoS2 with moving defects and Schottky Barrier Lowering.</a></li><li class="is-active"><a class="tocitem" href>CIGS: stationary with traps and Schottky contacts.</a></li><li><a class="tocitem" href="../Ex109_Traps/">GaAs diode: transient with traps (1D).</a></li><li><a class="tocitem" href="../Ex201_PSC_tensorGrid/">PSC device on 2D domain (Tensor grid).</a></li><li><a class="tocitem" href="../Grid_3D/">Example code for a 3D grid.</a></li><li><a class="tocitem" href="../Non_RectangularGrid_2D/">Example code for a 2D non rectangular grid.</a></li><li><a class="tocitem" href="../PSC_2D_unstructuredGrid/">PSC device on 2D domain (unstructured grid).</a></li><li><a class="tocitem" href="../PSC_3D/">Illustrative example of a three dimensional simulation.</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>CIGS: stationary with traps and Schottky contacts.</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CIGS: stationary with traps and Schottky contacts.</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/PatricioFarrell/ChargeTransport.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CIGS:-stationary-with-traps-and-Schottky-contacts."><a class="docs-heading-anchor" href="#CIGS:-stationary-with-traps-and-Schottky-contacts.">CIGS: stationary with traps and Schottky contacts.</a><a id="CIGS:-stationary-with-traps-and-Schottky-contacts.-1"></a><a class="docs-heading-anchor-permalink" href="#CIGS:-stationary-with-traps-and-Schottky-contacts." title="Permalink"></a></h1><p>(<a href="https://github.com/PatricioFarrell/ChargeTransport.jl/tree/master/examples/Ex108_CIGS_WithTraps.jl">source code</a>)</p><p>Simulating stationary charge transport for CIGS with hole traps and mixed Schottky/Ohmic contact conditions. Assume that SRH recombination only happens within a small regime.</p><pre><code class="language-julia hljs">module Ex108_CIGS_WithTraps

using ChargeTransport
using ExtendableGrids
using PyPlot

# function to initialize the grid for a possble extension to other p-i-n devices.
function initialize_pin_grid(refinementfactor, h_ndoping, h_pdoping_left, h_pdoping_trap, h_pdoing_right)
    coord_ndoping    = collect(range(0.0, stop = h_ndoping, length = 2 * refinementfactor))
    coord_pdoping_left  = collect(range(h_ndoping, stop = (h_ndoping + h_pdoping_left), length = 3 * refinementfactor))
    coord_pdoping_plus  = collect(range((h_ndoping + h_pdoping_left),
                                        stop = (h_ndoping + h_pdoping_left + h_pdoping_trap),
                                        length =  refinementfactor))
    coord_pdoping_right = collect(range((h_ndoping + h_pdoping_left + h_pdoping_trap),
                                        stop = (h_ndoping + h_pdoping_left + h_pdoping_trap + h_pdoing_right),
                                        length = 3 * refinementfactor))
    coord            = glue(coord_ndoping, coord_pdoping_left)
    coord            = glue(coord, coord_pdoping_plus)
    coord            = glue(coord, coord_pdoping_right)

    return coord
end</code></pre><p>you can also use other Plotters, if you add them to the example file</p><pre><code class="language-julia hljs">function main(;n = 3, Plotter = PyPlot, plotting = false, verbose = false, test = false, AdditionalTrapSpecies = false)

    if plotting
        Plotter.close(&quot;all&quot;)
    end
    ################################################################################
    if test == false
        println(&quot;Set up grid and regions&quot;)
    end
    ################################################################################

    # region numbers
    regionDonor          = 1                           # n doped region
    regionAcceptorLeft   = 2                           # p doped region
    regionAcceptorTrap   = 3                           # p doped region with trap
    regionAcceptorRight  = 4                           # p doped region
    regions              = [regionDonor, regionAcceptorLeft, regionAcceptorTrap, regionAcceptorRight]
    numberOfRegions      = length(regions)

    # boundary region numbers
    bregionDonor         = 1
    bregionAcceptor      = 2
    bregionDALeft        = 3
    bregionALeftATrap    = 4
    bregionATrapARight   = 5

    # grid
    refinementfactor     = 2^(n-1)
    h_ndoping            = 0.5    * μm
    h_pdoping_left       = 1.0    * μm
    h_pdoping_trap       = 0.1    * μm
    h_pdoing_right       = 1.0    * μm
    w_device             = 0.5    * μm  # width of device
    z_device             = 1.0e-4 * cm  # depth of device
    h_total              = h_ndoping + h_pdoping_left + h_pdoping_trap + h_pdoing_right
    coord                = initialize_pin_grid(refinementfactor,
                                               h_ndoping,
                                               h_pdoping_left,
                                               h_pdoping_trap,
                                               h_pdoing_right)

    grid                 = simplexgrid(coord)

    # set different regions in grid
    cellmask!(grid, [0.0 * μm], [h_ndoping], regionDonor) # n doped
    cellmask!(grid, [h_ndoping], [h_ndoping + h_pdoping_left], regionAcceptorLeft) # p doped
    cellmask!(grid, [h_ndoping + h_pdoping_left], [h_ndoping + h_pdoping_left + h_pdoping_trap], regionAcceptorTrap) # p doped with traps
    cellmask!(grid, [h_ndoping + h_pdoping_left + h_pdoping_trap], [h_total], regionAcceptorRight) # p doped

    bfacemask!(grid, [h_ndoping], [h_ndoping], bregionDALeft, tol = 1.0e-18)
    bfacemask!(grid, [h_ndoping + h_pdoping_left], [h_ndoping + h_pdoping_left], bregionALeftATrap, tol = 1.0e-18)
    bfacemask!(grid, [h_ndoping + h_pdoping_left + h_pdoping_trap], [h_ndoping + h_pdoping_left + h_pdoping_trap], bregionATrapARight, tol = 1.0e-18)

    if plotting
        gridplot(grid, Plotter = Plotter, legend=:lt)
        Plotter.title(&quot;Grid&quot;)
    end

    if test == false
        println(&quot;*** done\n&quot;)
    end

    ################################################################################
    if test == false
        println(&quot;Define physical parameters and model&quot;)
    end
    ################################################################################

    iphin                = 1 # index electron quasi Fermi potential
    iphip                = 2 # index hole quasi Fermi potential
    if AdditionalTrapSpecies
        iphit            = 3 # index trap quasi Fermi potential
        numberOfCarriers = 3 # electrons, holes and traps
    else
        numberOfCarriers = 2 # electrons and holes
    end

    # physical data
    T                 = 300.0                *  K

    # band edge energies
    Ec_ZnO            = 3.4                  *  eV
    Ev_ZnO            = 0.0                  *  eV

    Ec_CIGS           = 3.4                  *  eV
    Ev_CIGS           = 2.3                  *  eV

    EC                = [Ec_ZnO, Ec_CIGS, Ec_CIGS, Ec_CIGS]
    EV                = [Ev_ZnO, Ev_CIGS, Ev_CIGS, Ev_CIGS]

    # effective densities of states
    Nc                = 4.351959895879690e17 / (cm^3)
    Nv                = 9.139615903601645e18 / (cm^3)

    NC                = [Nc, Nc, Nc, Nc]
    NV                = [Nv, Nv, Nv, Nv]

    # mobilities
    mun_ZnO           = 100                  * (cm^2) / (V * s)
    mup_ZnO           = 25                   * (cm^2) / (V * s)
    mun_CIGS          = 100.0                * (cm^2) / (V * s)
    mup_CIGS          = 25                   * (cm^2) / (V * s)

    μn                = [mun_ZnO, mun_CIGS, mun_CIGS, mun_CIGS]
    μp                = [mup_ZnO, mup_CIGS, mup_CIGS, mup_CIGS]

    # relative dielectric permittivity
    εr_ZnO            = 9                    *  1.0
    εr_CIGS           = 13.6                 *  1.0

    ε                 = [εr_ZnO, εr_CIGS, εr_CIGS, εr_CIGS]

    # trap information
    zt                = 1 # hole traps
    Et                = 2.8                  *  eV
    ET                = [0.0, 0.0, Et, 0.0]
    Nt                = 1.0e18               / (cm^3)
    NT                = [0, 0, Nt, 0]

    mu_t              = 0                    * (cm^2) / (V * s)
    μt                = [0.0, 0.0, mu_t, 0.0]

    # recombination information parameters
    ni_ZnO            = sqrt(Nc * Nv) * exp(-(Ec_ZnO - Ev_ZnO) / (2 * kB * T))   # intrinsic concentration
    n0_ZnO            = Nc * Boltzmann( (Et-Ec_ZnO) / (kB*T) )                   # Boltzmann equilibrium concentration
    p0_ZnO            = ni_ZnO^2 / n0_ZnO                                        # Boltzmann equilibrium concentration
    ni_CIGS           = sqrt(Nc * Nv) * exp(-(Ec_CIGS - Ev_CIGS) / (2 * kB * T)) # intrinsic concentration
    n0_CIGS           = Nc * Boltzmann( (Et-Ec_CIGS) / (kB*T) )                  # Boltzmann equilibrium concentration
    p0_CIGS           = ni_CIGS^2 / n0_CIGS                                      # Boltzmann equilibrium concentration

    p0                = [p0_ZnO, p0_CIGS, p0_CIGS, p0_CIGS]
    n0                = [n0_ZnO, n0_CIGS, n0_CIGS, n0_CIGS]</code></pre><p>set the lifetime value high in all other regions, such that SRH recombination can be neglected there</p><pre><code class="language-julia hljs">    SRH_LifeTime      = [1.0e100, 1.0e100, 1.0e-3*ns, 1.0e100]

    Auger             = 1.0e-29  * cm^6 / s
    Radiative         = 1.0e-10  * cm^3 / s

    # Schottky contact information
    An                = 4 * pi * q * mₑ * kB^2 / Planck_constant^3
    Ap                = 4 * pi * q * mₑ * kB^2 / Planck_constant^3
    vn                = An * T^2 / (q*Nc)
    vp                = Ap * T^2 / (q*Nv)
    barrier           = 0.7 * eV

    # doping information
    Nd                = 1.0e18 / (cm^3)
    Na                = 5.5e15 / (cm^3)

    # we will impose this applied voltage on one boundary
    voltageAcceptor   = 1.0 * V

    if test == false
        println(&quot;*** done\n&quot;)
    end
    ################################################################################
    if test == false
        println(&quot;Define System and fill in information about model&quot;)
    end
    ################################################################################

    # initialize Data instance and fill in data
    data                                = Data(grid, numberOfCarriers)
    data.modelType                      = Stationary # R = Rn = Rp, since the model type is stationary
    if AdditionalTrapSpecies
        data.F                          = [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]
    else
        data.F                         .= FermiDiracOneHalfTeSCA
    end

    data.bulkRecombination              = set_bulk_recombination(;iphin = iphin, iphip = iphip,
                                                                 bulk_recomb_Auger = true,
                                                                 bulk_recomb_radiative = true,
                                                                 bulk_recomb_SRH = true)

    data.boundaryType[bregionAcceptor]  = SchottkyContact
    data.boundaryType[bregionDonor]     = OhmicContact
    data.fluxApproximation             .= ExcessChemicalPotential

    if AdditionalTrapSpecies
        # Here, we enable the traps and parse the respective index and the regions where the trap is defined.
        enable_trap_carrier!(;data = data, trapCarrier = iphit, regions = [regionAcceptorTrap])
    else
        # pass trap data in stationary setting since there is no separate trap species
        add_trap_density_Poisson!(data = data, zt = zt, Nt = NT)
    end

    if test == false
        println(&quot;*** done\n&quot;)
    end

    ################################################################################
    if test == false
        println(&quot;Define Params and fill in physical parameters&quot;)
    end
    ################################################################################

    # physical parameters
    params                                              = Params(grid, numberOfCarriers)
    params.temperature                                  = T
    params.UT                                           = (kB * params.temperature) / q
    params.chargeNumbers[iphin]                         = -1
    params.chargeNumbers[iphip]                         =  1
    if AdditionalTrapSpecies
        params.chargeNumbers[iphit]                     =  zt
    end

    for ireg in 1:numberOfRegions           # interior region data

        params.dielectricConstant[ireg]                 = ε[ireg] * ε0

        # effective DOS, band-edge energy and mobilities
        params.densityOfStates[iphin, ireg]             = NC[ireg]
        params.densityOfStates[iphip, ireg]             = NV[ireg]
        params.bandEdgeEnergy[iphin, ireg]              = EC[ireg]
        params.bandEdgeEnergy[iphip, ireg]              = EV[ireg]
        params.mobility[iphin, ireg]                    = μn[ireg]
        params.mobility[iphip, ireg]                    = μp[ireg]

        if AdditionalTrapSpecies
            params.densityOfStates[iphit, ireg]         = NT[ireg]
            params.bandEdgeEnergy[iphit, ireg]          = ET[ireg]
            params.mobility[iphit, ireg]                = μt[ireg]
        end

        # recombination parameters
        params.recombinationRadiative[ireg]             = Radiative
        params.recombinationSRHLifetime[iphin, ireg]    = SRH_LifeTime[ireg]
        params.recombinationSRHLifetime[iphip, ireg]    = SRH_LifeTime[ireg]
        params.recombinationSRHTrapDensity[iphin, ireg] = n0[ireg]
        params.recombinationSRHTrapDensity[iphip, ireg] = p0[ireg]
        params.recombinationAuger[iphin, ireg]          = Auger
        params.recombinationAuger[iphip, ireg]          = Auger

    end

    # doping -- since we do not set any doping for the traps it is automatically zero
    params.doping[iphin, regionDonor]                   = Nd
    params.doping[iphip, regionAcceptorLeft]            = Na
    params.doping[iphip, regionAcceptorTrap]            = Na
    params.doping[iphip, regionAcceptorRight]           = Na

    # values for the schottky contacts
    params.SchottkyBarrier[bregionAcceptor]             = barrier
    params.bVelocity[iphin, bregionAcceptor]            = vn
    params.bVelocity[iphip, bregionAcceptor]            = vp

    data.params                                         = params
    ctsys                                               = System(grid, data, unknown_storage=:sparse)

    if test == false
        show_params(ctsys)
        println(&quot;*** done\n&quot;)
    end

    ################################################################################
    if test == false
        println(&quot;Define control parameters for Solver&quot;)
    end
    ################################################################################

    control              = SolverControl()
    control.verbose      = verbose
    control.tol_round    = 1.0e-7
    control.damp_initial = 0.5
    control.damp_growth  = 1.2
    control.maxiters     = 30
    control.max_round    = 3

    if test == false
        println(&quot;*** done\n&quot;)
    end

    ################################################################################
    if test == false
        println(&quot;Compute solution in thermodynamic equilibrium&quot;)
    end
    ################################################################################

    # solve thermodynamic equilibrium and update initial guess
    solution = equilibrium_solve!(ctsys, control = control)
    inival   = solution

    if plotting
        label_solution, label_density, label_energy = set_plotting_labels(data)

        if AdditionalTrapSpecies
            # add labels for traps
            label_energy[1, iphit] = &quot;\$E_{\\tau}-q\\psi\$&quot;; label_energy[2, iphit] = &quot;\$ - q \\varphi_{\\tau}\$&quot;
            label_density[iphit]   = &quot;\$n_{\\tau}\$&quot;;        label_solution[iphit]  = &quot;\$ \\varphi_{\\tau}\$&quot;
        end

        # ##### set legend for plotting routines #####
        Plotter.figure()
        plot_energies(Plotter, ctsys, solution, &quot;Equilibrium&quot;, label_energy)
        Plotter.figure()
        plot_densities(Plotter, ctsys, solution,&quot;Equilibrium&quot;, label_density)
        Plotter.figure()
        plot_solution(Plotter, ctsys, solution, &quot;Equilibrium&quot;, label_solution)
    end

    if test == false
        println(&quot;*** done\n&quot;)
    end

    ################################################################################
    if test == false
        println(&quot;Stationary bias loop&quot;)
    end
    ################################################################################

    endVoltage      = voltageAcceptor       # final bias value
    biasValues      = collect(range(0, stop = endVoltage, length = 52))

    IV              = zeros(0)
    chargeDensities = zeros(0)

    for i in eachindex(biasValues)

        Δu = biasValues[i] # bias

        # Apply new voltage: set non equilibrium boundary conditions
        set_contact!(ctsys, bregionAcceptor, Δu = Δu)

        if test == false
            println(&quot;bias: Δu = $(Δu) V&quot;)
        end

        # solve time step problems with timestep Δt
        solution = solve(ctsys, inival = inival, control = control)
        inival   = solution

        # save IV data
        current = get_current_val(ctsys, solution)
        push!(IV, w_device * z_device * current)

        # store charge density in donor region (ZnO)
        push!(chargeDensities, charge_density(ctsys, solution)[regionDonor])


    end # bias loop

    # compute static capacitance: check this is correctly computed
    staticCapacitance = diff(chargeDensities) ./ diff(biasValues)

    # plot solution and IV curve
    if plotting
        Plotter.figure()
        plot_energies(Plotter, ctsys, solution, &quot;bias \$\\Delta u\$ = $(endVoltage) V&quot;, label_energy)
        Plotter.figure()
        plot_densities(Plotter, ctsys, solution,&quot;bias \$\\Delta u\$ = $(endVoltage) V&quot;, label_density)
        Plotter.figure()
        plot_solution(Plotter, ctsys, solution, &quot;bias \$\\Delta u\$ = $(endVoltage) V&quot;, label_solution)
        Plotter.figure()
        plot_IV(Plotter, biasValues,IV, &quot;bias \$\\Delta u\$ = $(biasValues[end]) V&quot;, plotGridpoints = true)
        Plotter.figure()
        plot_IV(Plotter, biasValues,chargeDensities, &quot;bias \$\\Delta u\$ = $(biasValues[end]) V&quot;, plotGridpoints = true)
        Plotter.title(&quot;Charge density in donor region&quot;)
        Plotter.ylabel(&quot;Charge density [C]&quot;)
        Plotter.figure()
        plot_IV(Plotter, biasValues, staticCapacitance, &quot;bias \$\\Delta u\$ = $(biasValues[end]) V&quot;, plotGridpoints = true)
        Plotter.title(&quot;Static capacitance in donor region&quot;)
        Plotter.ylabel(&quot;Static capacitance [C/V]&quot;)

    end

    if test == false
        println(&quot;*** done\n&quot;)
    end

    testval = sum(filter(!isnan, solution))/length(solution) # when using sparse storage, we get NaN values in solution
    return testval

end #  main

function test()
    testval                  = 1.484831264268335
    testvalAdditionalSpecies = 1.1334257649339574

    main(test = true, AdditionalTrapSpecies = false) ≈ testval &amp;&amp; main(test = true, AdditionalTrapSpecies = true) ≈ testvalAdditionalSpecies
end

if test == false
    println(&quot;This message should show when this module has successfully recompiled.&quot;)
end


end # module</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Ex107_MoS2_withIons_BarrierLowering/">« MoS2 with moving defects and Schottky Barrier Lowering.</a><a class="docs-footer-nextpage" href="../Ex109_Traps/">GaAs diode: transient with traps (1D). »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 26 September 2024 12:43">Thursday 26 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
