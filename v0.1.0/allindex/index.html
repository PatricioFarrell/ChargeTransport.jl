<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types, Constructors and Methods · ChargeTransport.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../general/">ChargeTransport.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../general/">ChargeTransport.jl – Simulating charge transport in semiconductors</a></li><li><a class="tocitem" href="../backgroundinfo/">Mathematical drift-diffusion models</a></li><li><span class="tocitem">How to get started</span><ul><li><a class="tocitem" href="../GeneralInformation/">Code overview</a></li><li><a class="tocitem" href="../GaAs/">van Roosbroeck system</a></li><li><a class="tocitem" href="../PSC/">Perovskite solar cell</a></li></ul></li><li class="is-active"><a class="tocitem" href>Types, Constructors and Methods</a><ul class="internal"><li><a class="tocitem" href="#Constants,-Types-and-Constructors"><span>Constants, Types and Constructors</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li><li class="toplevel"><a class="tocitem" href="#Description-of-Constant,-Types,-Constructors-and-Methods"><span>Description of Constant, Types, Constructors and Methods</span></a></li><li><a class="tocitem" href="#Constants,-Types-and-Constructors-2"><span>Constants, Types and Constructors</span></a></li><li><a class="tocitem" href="#Methods-2"><span>Methods</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/Ex101_PIN/">GaAs diode (1D).</a></li><li><a class="tocitem" href="../examples/Ex102_PIN_nodal_doping/">GaAs diode with spatially varying doping (1D).</a></li><li><a class="tocitem" href="../examples/Ex103_PSC/">PSC device without mobile ions (1D).</a></li><li><a class="tocitem" href="../examples/Ex104_PSC_gradedFlux_Schottky_contacts/">PSC device with graded interfaces &amp; Schottky contacts (1D).</a></li><li><a class="tocitem" href="../examples/Ex105_PSC_gradedFlux/">PSC device with graded interfaces &amp; Ohmic contacts (1D).</a></li><li><a class="tocitem" href="../examples/Ex106_PSC_withIons_IVMeasurement/">PSC device with ions and linear I-V scan protocol (1D).</a></li><li><a class="tocitem" href="../examples/Ex107_PSC_withIons_sinusoidalVoltage/">PSC device with sinusoidal applied voltage (1D).</a></li><li><a class="tocitem" href="../examples/Ex108_PSC_uniform_Generation/">PSC device with uniform generation rate (1D).</a></li><li><a class="tocitem" href="../examples/Ex109_Traps/">GaAs diode: transient with traps (1D).</a></li><li><a class="tocitem" href="../examples/Ex110_PSC_surface_recombination/">PSC device with surface recombination (1D).</a></li><li><a class="tocitem" href="../examples/Ex201_PSC_tensorGrid/">PSC device on 2D domain (Tensor grid).</a></li><li><a class="tocitem" href="../examples/Grid_3D/">Example code for a 3D grid.</a></li><li><a class="tocitem" href="../examples/Non_RectangularGrid_2D/">Example code for a 2D non rectangular grid.</a></li><li><a class="tocitem" href="../examples/PSC_2D_unstructuredGrid/">PSC device on 2D domain (unstructured grid).</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Types, Constructors and Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types, Constructors and Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PatricioFarrell/ChargeTransport.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Overview-–-Constants,-Types,-Constructors-and-Methods"><a class="docs-heading-anchor" href="#Overview-–-Constants,-Types,-Constructors-and-Methods">Overview – Constants, Types, Constructors and Methods</a><a id="Overview-–-Constants,-Types,-Constructors-and-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-–-Constants,-Types,-Constructors-and-Methods" title="Permalink"></a></h1><h2 id="Constants,-Types-and-Constructors"><a class="docs-heading-anchor" href="#Constants,-Types-and-Constructors">Constants, Types and Constructors</a><a id="Constants,-Types-and-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constants,-Types-and-Constructors" title="Permalink"></a></h2><ul><li><a href="#ChargeTransport.BoundaryModelType"><code>ChargeTransport.BoundaryModelType</code></a></li><li><a href="#ChargeTransport.BulkRecombination"><code>ChargeTransport.BulkRecombination</code></a></li><li><a href="#ChargeTransport.CalculationType"><code>ChargeTransport.CalculationType</code></a></li><li><a href="#ChargeTransport.Data"><code>ChargeTransport.Data</code></a></li><li><a href="#ChargeTransport.Data-Union{Tuple{TFuncs}, Tuple{Any, Any}} where TFuncs"><code>ChargeTransport.Data</code></a></li><li><a href="#ChargeTransport.DiffusionEnhanced"><code>ChargeTransport.DiffusionEnhanced</code></a></li><li><a href="#ChargeTransport.ExcessChemicalPotential"><code>ChargeTransport.ExcessChemicalPotential</code></a></li><li><a href="#ChargeTransport.ExcessChemicalPotentialGraded"><code>ChargeTransport.ExcessChemicalPotentialGraded</code></a></li><li><a href="#ChargeTransport.FluxApproximationType"><code>ChargeTransport.FluxApproximationType</code></a></li><li><a href="#ChargeTransport.GeneralizedSG"><code>ChargeTransport.GeneralizedSG</code></a></li><li><a href="#ChargeTransport.GenerationBeerLambert"><code>ChargeTransport.GenerationBeerLambert</code></a></li><li><a href="#ChargeTransport.GenerationModelType"><code>ChargeTransport.GenerationModelType</code></a></li><li><a href="#ChargeTransport.GenerationNone"><code>ChargeTransport.GenerationNone</code></a></li><li><a href="#ChargeTransport.GenerationUniform"><code>ChargeTransport.GenerationUniform</code></a></li><li><a href="#ChargeTransport.InEquilibrium"><code>ChargeTransport.InEquilibrium</code></a></li><li><a href="#ChargeTransport.InterfaceModelNone"><code>ChargeTransport.InterfaceModelNone</code></a></li><li><a href="#ChargeTransport.InterfaceModelSurfaceReco"><code>ChargeTransport.InterfaceModelSurfaceReco</code></a></li><li><a href="#ChargeTransport.InterfaceModelType"><code>ChargeTransport.InterfaceModelType</code></a></li><li><a href="#ChargeTransport.IonicChargeCarriers"><code>ChargeTransport.IonicChargeCarriers</code></a></li><li><a href="#ChargeTransport.ModelType"><code>ChargeTransport.ModelType</code></a></li><li><a href="#ChargeTransport.OhmicContact"><code>ChargeTransport.OhmicContact</code></a></li><li><a href="#ChargeTransport.OutOfEquilibrium"><code>ChargeTransport.OutOfEquilibrium</code></a></li><li><a href="#ChargeTransport.OuterBoundaryModelType"><code>ChargeTransport.OuterBoundaryModelType</code></a></li><li><a href="#ChargeTransport.Params"><code>ChargeTransport.Params</code></a></li><li><a href="#ChargeTransport.Params-Tuple{Any, Any}"><code>ChargeTransport.Params</code></a></li><li><a href="#ChargeTransport.ParamsNodal-Tuple{Any, Any}"><code>ChargeTransport.ParamsNodal</code></a></li><li><a href="#ChargeTransport.ParamsNodal"><code>ChargeTransport.ParamsNodal</code></a></li><li><a href="#ChargeTransport.QType"><code>ChargeTransport.QType</code></a></li><li><a href="#ChargeTransport.SRHWithTrapsType"><code>ChargeTransport.SRHWithTrapsType</code></a></li><li><a href="#ChargeTransport.SRHWithoutTrapsType"><code>ChargeTransport.SRHWithoutTrapsType</code></a></li><li><a href="#ChargeTransport.ScharfetterGummel"><code>ChargeTransport.ScharfetterGummel</code></a></li><li><a href="#ChargeTransport.ScharfetterGummelGraded"><code>ChargeTransport.ScharfetterGummelGraded</code></a></li><li><a href="#ChargeTransport.SchottkyContact"><code>ChargeTransport.SchottkyContact</code></a></li><li><a href="#ChargeTransport.StandardFuncSet"><code>ChargeTransport.StandardFuncSet</code></a></li><li><a href="#ChargeTransport.Stationary"><code>ChargeTransport.Stationary</code></a></li><li><a href="#ChargeTransport.System"><code>ChargeTransport.System</code></a></li><li><a href="#ChargeTransport.System-Tuple{Any, Any}"><code>ChargeTransport.System</code></a></li><li><a href="#ChargeTransport.Transient"><code>ChargeTransport.Transient</code></a></li><li><a href="#ChargeTransport.Traps"><code>ChargeTransport.Traps</code></a></li></ul><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><ul><li><a href="#ChargeTransport.Blakemore-Tuple{Real, Real}"><code>ChargeTransport.Blakemore</code></a></li><li><a href="#ChargeTransport.Boltzmann-Tuple{Real}"><code>ChargeTransport.Boltzmann</code></a></li><li><a href="#ChargeTransport.FermiDiracMinusOne-Tuple{Real}"><code>ChargeTransport.FermiDiracMinusOne</code></a></li><li><a href="#ChargeTransport.FermiDiracOneHalfBednarczyk-Tuple{Real}"><code>ChargeTransport.FermiDiracOneHalfBednarczyk</code></a></li><li><a href="#ChargeTransport.FermiDiracOneHalfTeSCA-Tuple{Real}"><code>ChargeTransport.FermiDiracOneHalfTeSCA</code></a></li><li><a href="#ChargeTransport.RHSContinuityEquations!-NTuple{4, Any}"><code>ChargeTransport.RHSContinuityEquations!</code></a></li><li><a href="#ChargeTransport.RHSPoisson!-NTuple{4, Any}"><code>ChargeTransport.RHSPoisson!</code></a></li><li><a href="#ChargeTransport.bflux!-NTuple{4, Any}"><code>ChargeTransport.bflux!</code></a></li><li><a href="#ChargeTransport.breaction!-NTuple{4, Any}"><code>ChargeTransport.breaction!</code></a></li><li><a href="#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{SchottkyContact}}"><code>ChargeTransport.breaction!</code></a></li><li><a href="#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{OhmicContact}}"><code>ChargeTransport.breaction!</code></a></li><li><a href="#ChargeTransport.bstorage!-NTuple{4, Any}"><code>ChargeTransport.bstorage!</code></a></li><li><a href="#ChargeTransport.charge_density-Tuple{Any, Any}"><code>ChargeTransport.charge_density</code></a></li><li><a href="#ChargeTransport.charge_density-NTuple{8, Any}"><code>ChargeTransport.charge_density</code></a></li><li><a href="#ChargeTransport.compute_densities!-Tuple{Any, Any, Any, Any, Any, Bool}"><code>ChargeTransport.compute_densities!</code></a></li><li><a href="#ChargeTransport.compute_densities!-Tuple{Any, Any, Any}"><code>ChargeTransport.compute_densities!</code></a></li><li><a href="#ChargeTransport.compute_energies!-Tuple{Any, Any, Any}"><code>ChargeTransport.compute_energies!</code></a></li><li><a href="#ChargeTransport.degenerateLimit-Tuple{Any}"><code>ChargeTransport.degenerateLimit</code></a></li><li><a href="#ChargeTransport.electroNeutralSolution!-Tuple{Any, Any}"><code>ChargeTransport.electroNeutralSolution!</code></a></li><li><a href="#ChargeTransport.electrochemicalReaction-NTuple{10, Any}"><code>ChargeTransport.electrochemicalReaction</code></a></li><li><a href="#ChargeTransport.enable_ionic_carriers-Tuple{}"><code>ChargeTransport.enable_ionic_carriers</code></a></li><li><a href="#ChargeTransport.enable_traps!-Tuple{}"><code>ChargeTransport.enable_traps!</code></a></li><li><a href="#ChargeTransport.etaFunction-Tuple{Any, VoronoiFVM.BNode, Any, Any}"><code>ChargeTransport.etaFunction</code></a></li><li><a href="#ChargeTransport.etaFunction-NTuple{5, Any}"><code>ChargeTransport.etaFunction</code></a></li><li><a href="#ChargeTransport.etaFunction-Tuple{Any, VoronoiFVM.Node, Any, Any}"><code>ChargeTransport.etaFunction</code></a></li><li><a href="#ChargeTransport.etaFunction-Tuple{Any, Any, Any, Any, Any, Bool}"><code>ChargeTransport.etaFunction</code></a></li><li><a href="#ChargeTransport.flux!-NTuple{4, Any}"><code>ChargeTransport.flux!</code></a></li><li><a href="#ChargeTransport.get_BEE!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}, VoronoiFVM.Node, Any}"><code>ChargeTransport.get_BEE!</code></a></li><li><a href="#ChargeTransport.get_DOS!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}, VoronoiFVM.Node, Any}"><code>ChargeTransport.get_DOS!</code></a></li><li><a href="#ChargeTransport.get_current_val-Tuple{Any, Any}"><code>ChargeTransport.get_current_val</code></a></li><li><a href="#ChargeTransport.get_current_val-NTuple{4, Any}"><code>ChargeTransport.get_current_val</code></a></li><li><a href="#ChargeTransport.plotDiffusionEnhancements-Tuple{}"><code>ChargeTransport.plotDiffusionEnhancements</code></a></li><li><a href="#ChargeTransport.plotDistributions-Tuple{}"><code>ChargeTransport.plotDistributions</code></a></li><li><a href="#ChargeTransport.plot_IV-NTuple{4, Any}"><code>ChargeTransport.plot_IV</code></a></li><li><a href="#ChargeTransport.plot_densities-Tuple{Any, Any, Data, Any, Any, Any}"><code>ChargeTransport.plot_densities</code></a></li><li><a href="#ChargeTransport.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, Data, Any}"><code>ChargeTransport.plot_doping</code></a></li><li><a href="#ChargeTransport.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ParamsNodal}"><code>ChargeTransport.plot_doping</code></a></li><li><a href="#ChargeTransport.plot_electroNeutralSolutionBoltzmann-Tuple{Any, Any, Any}"><code>ChargeTransport.plot_electroNeutralSolutionBoltzmann</code></a></li><li><a href="#ChargeTransport.plot_energies-Tuple{Any, ExtendableGrids.ExtendableGrid, Data, Any}"><code>ChargeTransport.plot_energies</code></a></li><li><a href="#ChargeTransport.plot_energies-Tuple{Any, Any, Data, Any, Any, Any}"><code>ChargeTransport.plot_energies</code></a></li><li><a href="#ChargeTransport.plot_solution-Tuple{Any, Any, Data, Any, Any, Any}"><code>ChargeTransport.plot_solution</code></a></li><li><a href="#ChargeTransport.printJacobi-Tuple{Any, Any}"><code>ChargeTransport.printJacobi</code></a></li><li><a href="#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}"><code>ChargeTransport.reaction!</code></a></li><li><a href="#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{InEquilibrium}}"><code>ChargeTransport.reaction!</code></a></li><li><a href="#ChargeTransport.reaction!-NTuple{4, Any}"><code>ChargeTransport.reaction!</code></a></li><li><a href="#ChargeTransport.set_bulk_recombination-Tuple{}"><code>ChargeTransport.set_bulk_recombination</code></a></li><li><a href="#ChargeTransport.set_plotting_labels-Tuple{Any}"><code>ChargeTransport.set_plotting_labels</code></a></li><li><a href="#ChargeTransport.storage!-NTuple{4, Any}"><code>ChargeTransport.storage!</code></a></li><li><a href="#ChargeTransport.storage!-Tuple{Any, Any, Any, Any, Type{Transient}}"><code>ChargeTransport.storage!</code></a></li><li><a href="#ChargeTransport.trap_density!-NTuple{4, Any}"><code>ChargeTransport.trap_density!</code></a></li></ul><h1 id="Description-of-Constant,-Types,-Constructors-and-Methods"><a class="docs-heading-anchor" href="#Description-of-Constant,-Types,-Constructors-and-Methods">Description of Constant, Types, Constructors and Methods</a><a id="Description-of-Constant,-Types,-Constructors-and-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Description-of-Constant,-Types,-Constructors-and-Methods" title="Permalink"></a></h1><h2 id="Constants,-Types-and-Constructors-2"><a class="docs-heading-anchor" href="#Constants,-Types-and-Constructors-2">Constants, Types and Constructors</a><a class="docs-heading-anchor-permalink" href="#Constants,-Types-and-Constructors-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.BoundaryModelType" href="#ChargeTransport.BoundaryModelType"><code>ChargeTransport.BoundaryModelType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible types of boundary models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.CalculationType" href="#ChargeTransport.CalculationType"><code>ChargeTransport.CalculationType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible types for calculation type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.FluxApproximationType" href="#ChargeTransport.FluxApproximationType"><code>ChargeTransport.FluxApproximationType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible types of flux discretization schemes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.GenerationModelType" href="#ChargeTransport.GenerationModelType"><code>ChargeTransport.GenerationModelType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible types for generation model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.InterfaceModelType" href="#ChargeTransport.InterfaceModelType"><code>ChargeTransport.InterfaceModelType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible Types of interface model (interior boundary conditions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.ModelType" href="#ChargeTransport.ModelType"><code>ChargeTransport.ModelType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible types which indicate, if we consider stationary or transient problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.OuterBoundaryModelType" href="#ChargeTransport.OuterBoundaryModelType"><code>ChargeTransport.OuterBoundaryModelType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible types of outer boundary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.QType" href="#ChargeTransport.QType"><code>ChargeTransport.QType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type of charge carriers and the electric potential.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.SRHWithoutTrapsType" href="#ChargeTransport.SRHWithoutTrapsType"><code>ChargeTransport.SRHWithoutTrapsType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible type for SRH recombination without traps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.StandardFuncSet" href="#ChargeTransport.StandardFuncSet"><code>ChargeTransport.StandardFuncSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type of statistics functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.BulkRecombination" href="#ChargeTransport.BulkRecombination"><code>ChargeTransport.BulkRecombination</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct BulkRecombination</code></pre><p>A struct holding all necessary information for building bulk recombination. With help of this constructor we can read out the indices the user chooses for electron and hole quasi Fermi potentials.</p><ul><li><p><code>iphin::Int64</code></p><p>Index for FVM construction of electron quasi Fermi potential.</p></li></ul><ul><li><p><code>iphip::Int64</code></p><p>Index for FVM construction of hole quasi Fermi potential.</p></li></ul><ul><li><p><code>bulk_recomb_Auger::Bool</code></p><p>Boolean for present Auger recombination in bulk.</p></li></ul><ul><li><p><code>bulk_recomb_radiative::Bool</code></p><p>Boolean for present radiative recombination in bulk.</p></li></ul><ul><li><p><code>bulk_recomb_SRH::Union{Type{SRHOff}, Type{ChargeTransport.SRHStationary}, Type{SRHTrapsTransient}}</code></p><p>DataType for present SRH recombination in bulk. This needs to be a Type due to cases with or without mobile traps.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.Data" href="#ChargeTransport.Data"><code>ChargeTransport.Data</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Data{TFuncs&lt;:Function}</code></pre><p>A struct holding all data information including model and numerics information, but also all physical parameters for a drift-diffusion simulation of a semiconductor device.</p><ul><li><p><code>F::Vector{TFuncs} where TFuncs&lt;:Function</code></p><p>An array with the corresponding distribution function <span>$\mathcal{F}_\alpha$</span> for all carriers <span>$\alpha$</span>.</p></li></ul><ul><li><p><code>boundaryType::Vector{Union{Type{InterfaceModelDiscontqF}, Type{InterfaceModelIonCharge}, Type{InterfaceModelNone}, Type{InterfaceModelSurfaceReco}, Type{InterfaceModelSurfaceRecoAndTangentialFlux}, Type{InterfaceModelTangentialFlux}, Type{OhmicContact}, Type{SchottkyContact}}}</code></p><p>An array of DataTypes with the type of boundary model for each boundary (interior and exterior).</p></li></ul><ul><li><p><code>bulkRecombination::BulkRecombination</code></p><p>A struct containing information concerning the bulk recombination model.</p></li></ul><ul><li><p><code>enableIonicCarriers::IonicChargeCarriers</code></p><p>A struct which contains information on the regions, where ionic charge carriers (ions and/or ion vacancies) are present.</p></li></ul><ul><li><p><code>enableTraps::ChargeTransport.Traps</code></p><p>A struct which contains information on present SRH traps.</p></li></ul><ul><li><p><code>innerInterfaceModel::Union{Type{InterfaceModelDiscontqF}, Type{InterfaceModelIonCharge}, Type{InterfaceModelNone}, Type{InterfaceModelSurfaceReco}, Type{InterfaceModelSurfaceRecoAndTangentialFlux}, Type{InterfaceModelTangentialFlux}}</code></p><p>DataType which stores information about which inner interface model is chosen by user. This quantity cannot be seen by the user and is needed for the core of the package.</p></li></ul><ul><li><p><code>fluxApproximation::Union{Type{DiffusionEnhanced}, Type{ExcessChemicalPotential}, Type{ExcessChemicalPotentialGraded}, Type{GeneralizedSG}, Type{ScharfetterGummel}, Type{ScharfetterGummelGraded}}</code></p><p>A DataType for the flux discretization method.</p></li></ul><ul><li><p><code>calculationType::Union{Type{InEquilibrium}, Type{OutOfEquilibrium}}</code></p><p>A DataType for equilibrium or out of equilibrium calculations.</p></li></ul><ul><li><p><code>modelType::Union{Type{Stationary}, Type{Transient}}</code></p><p>A DataType for transient or stationary calculations.</p></li></ul><ul><li><p><code>generationModel::Union{Type{GenerationBeerLambert}, Type{GenerationNone}, Type{GenerationUniform}}</code></p><p>A DataType for for generation model.</p></li></ul><ul><li><p><code>λ1::Float64</code></p><p>An embedding parameter used to solve the nonlinear Poisson problem, where for λ1 = 0 the right hand-side is set to zero whereas for for λ1 = 1 we have a full space charge density.</p></li></ul><ul><li><p><code>λ2::Float64</code></p><p>An embedding parameter for the generation rate.</p></li></ul><ul><li><p><code>λ3::Float64</code></p><p>An embedding parameter for an electrochemical reaction.</p></li></ul><ul><li><p><code>tempBEE1::Vector{Float64}</code></p><p>Within this template informations concerning the band-edge energy of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.</p></li></ul><ul><li><p><code>tempBEE2::Vector{Float64}</code></p><p>See the description of tempBEE1.</p></li></ul><ul><li><p><code>tempDOS1::Vector{Float64}</code></p><p>Within this template informations concerning the effective DOS of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.</p></li></ul><ul><li><p><code>tempDOS2::Vector{Float64}</code></p><p>See the desciption of tempDOS2.</p></li></ul><ul><li><p><code>isContinuous::Vector{Bool}</code></p><p>An array containing information on whether charge carriers are continuous or discontinuous. This is needed for building the AbstractQuantities which handle the indices of charge carriers on different regions.</p></li></ul><ul><li><p><code>chargeCarrierList::Vector{Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}}</code></p><p>This list stores all charge carriers. Based on the user choice we have with this new type the opportunity to simulate discontinuous unknowns.</p></li></ul><ul><li><p><code>index_psi::Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}</code></p><p>This variable stores the index of the electric potential. Based on the user choice we have with this new type the opportunity to simulate discontinuous unknowns.</p></li></ul><ul><li><p><code>params::Params</code></p><p>A struct holding all region dependent parameter information. For more information see struct Params.</p></li></ul><ul><li><p><code>paramsnodal::ParamsNodal</code></p><p>A struct holding all space dependent parameter information. For more information see struct ParamsNodal.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.Data-Union{Tuple{TFuncs}, Tuple{Any, Any}} where TFuncs" href="#ChargeTransport.Data-Union{Tuple{TFuncs}, Tuple{Any, Any}} where TFuncs"><code>ChargeTransport.Data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Data(grid, numberOfCarriers; statfunctions) -&gt; Data{StandardFuncSet}
</code></pre><p>Simplified constructor for Data which only takes the grid and the numberOfCarriers as argument. Here, all necessary information including the physical parameters, but also some numerical information are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.DiffusionEnhanced" href="#ChargeTransport.DiffusionEnhanced"><code>ChargeTransport.DiffusionEnhanced</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type DiffusionEnhanced</code></pre><p>Abstract type for diffusion enhanced flux discretization, check M. Bessemoulin-Chatard, “A finite volume scheme for convection–diffusion equations with nonlinear diffusion derived from the Scharfetter–Gummel scheme”, Numerische Mathematik, vol. 121, pp. 637–670, 2012.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.ExcessChemicalPotential" href="#ChargeTransport.ExcessChemicalPotential"><code>ChargeTransport.ExcessChemicalPotential</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ExcessChemicalPotential</code></pre><p>Abstract type for excess chemical potential flux discretization, check  Z. Yu, and R. Dutton, “SEDAN III – A one-dimensional device simulator”, http://www-tcad.stanford.edu/tcad/programs/sedan3.html, 1988.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.ExcessChemicalPotentialGraded" href="#ChargeTransport.ExcessChemicalPotentialGraded"><code>ChargeTransport.ExcessChemicalPotentialGraded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ExcessChemicalPotentialGraded</code></pre><p>Abstract type for excess chemical potential flux discretization for graded effective density of states and/or graded band-edge energies. This means, use this flux when at least one of these parameters is assumed to be space-dependent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.GeneralizedSG" href="#ChargeTransport.GeneralizedSG"><code>ChargeTransport.GeneralizedSG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GeneralizedSG</code></pre><p>Abstract type for generalized Scharfetter-Gummel flux discretization. This flux approximation results in an implicit equation which needs to be solved and is exact for all Blakemore type statistics functions with abritary γ, check T. Koprucki and K. Gärtner. “Discretization scheme for drift-diffusion equations with strong diffusion enhancement”. In: 12th International Conference on Numerical Simulation of Optoelectronic Devices (NUSOD). 2012, pp. 103–104.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.GenerationBeerLambert" href="#ChargeTransport.GenerationBeerLambert"><code>ChargeTransport.GenerationBeerLambert</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GenerationBeerLambert</code></pre><p>Abstract type for Beer-Lambert generation. Note that this type is implemented, but not well tested yet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.GenerationNone" href="#ChargeTransport.GenerationNone"><code>ChargeTransport.GenerationNone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GenerationNone</code></pre><p>Abstract type for no generation model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.GenerationUniform" href="#ChargeTransport.GenerationUniform"><code>ChargeTransport.GenerationUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GenerationUniform</code></pre><p>Abstract type for uniform generation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.InEquilibrium" href="#ChargeTransport.InEquilibrium"><code>ChargeTransport.InEquilibrium</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type InEquilibrium</code></pre><p>Abstract type for equilibrium calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.InterfaceModelNone" href="#ChargeTransport.InterfaceModelNone"><code>ChargeTransport.InterfaceModelNone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type InterfaceModelNone</code></pre><p>Abstract type for no interface model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.InterfaceModelSurfaceReco" href="#ChargeTransport.InterfaceModelSurfaceReco"><code>ChargeTransport.InterfaceModelSurfaceReco</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type InterfaceModelSurfaceReco</code></pre><p>Abstract type for surface recombination mechanisms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.IonicChargeCarriers" href="#ChargeTransport.IonicChargeCarriers"><code>ChargeTransport.IonicChargeCarriers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct IonicChargeCarriers</code></pre><p>A struct holding all information necessary on the ionic charge carriers. With help of this constructor we can read out the indices the user chooses for ionic charge carrier quasi Fermi potentials and the respective regions in which they are defined. Note that it is possible to use ions as well as ion vacancies.</p><ul><li><p><code>ionic_carriers::Vector{Int64}</code></p><p>Array with the indices of ionic charge carriers.</p></li></ul><ul><li><p><code>regions::Vector{Int64}</code></p><p>Corresponding regions where ionic charge carriers are assumed to be present.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.OhmicContact" href="#ChargeTransport.OhmicContact"><code>ChargeTransport.OhmicContact</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for ohmic contacts as outer boundary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.OutOfEquilibrium" href="#ChargeTransport.OutOfEquilibrium"><code>ChargeTransport.OutOfEquilibrium</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type OutOfEquilibrium</code></pre><p>Abstract type for out of equilibrium calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.Params" href="#ChargeTransport.Params"><code>ChargeTransport.Params</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Params</code></pre><p>A struct holding the physical region dependent parameters for a drift-diffusion simulation of a semiconductor device.</p><ul><li><p><code>numberOfNodes::Int64</code></p><p>Number of nodes used for the disretization of the domain <span>$\mathbf{\Omega}$</span>.</p></li></ul><ul><li><p><code>numberOfRegions::Int64</code></p><p>Number of subregions <span>$\mathbf{\Omega}_k$</span> within the domain <span>$\mathbf{\Omega}$</span>.</p></li></ul><ul><li><p><code>numberOfBoundaryRegions::Int64</code></p><p>Number of boundary regions <span>$(\partial \mathbf{\Omega})_k$</span> such that <span>$\partial \mathbf{\Omega} = \cup_k (\partial \mathbf{\Omega})_k$</span>. Note that here are interior and outerior boundaries calculated.</p></li></ul><ul><li><p><code>numberOfCarriers::Int64</code></p><p>Number of moving charge carriers.</p></li></ul><ul><li><p><code>temperature::Float64</code></p><p>A given constant temperature.</p></li></ul><ul><li><p><code>UT::Float64</code></p><p>The thermal voltage, which reads  <span>$U_T = k_B T / q$</span>.</p></li></ul><ul><li><p><code>γ::Float64</code></p><p>The parameter of the Blakemore statistics (needed for the generalizedSG flux).</p></li></ul><ul><li><p><code>r0::Float64</code></p><p>Prefactor of electro-chemical reaction of internal boundary conditions.</p></li></ul><ul><li><p><code>prefactor_SRH::Float64</code></p><p>Prefactor for stationary SRH recombination.</p></li></ul><ul><li><p><code>SchottkyBarrier::Vector{Float64}</code></p><p>An array for the given Schottky barriers at present Schotkky contacts.</p></li></ul><ul><li><p><code>chargeNumbers::Vector{Float64}</code></p><p>An array with the corresponding charge numbers <span>$z_\alpha$</span> for all carriers <span>$\alpha$</span>.</p></li></ul><ul><li><p><code>bBandEdgeEnergy::Matrix{Float64}</code></p><p>An array with the corresponding boundary band-edge energy values <span>$E_\alpha$</span> in each region for each carrier <span>$\alpha$</span>.</p></li></ul><ul><li><p><code>bDensityOfStates::Matrix{Float64}</code></p><p>An array with the corresponding boundary effective density of states values <span>$N_\alpha$</span> for each carrier <span>$\alpha$</span>.</p></li></ul><ul><li><p><code>bMobility::Matrix{Float64}</code></p><p>A 2D array with the corresponding boundary mobility values <span>$\mu_\alpha$</span> in each boundary region for each carrier <span>$\alpha$</span>.</p></li></ul><ul><li><p><code>bDoping::Matrix{Float64}</code></p><p>A 2D array with the corresponding boundary doping values for each carrier <span>$\alpha$</span>.</p></li></ul><ul><li><p><code>bVelocity::Matrix{Float64}</code></p><p>A 2D array with the corresponding boundary velocity values for each carrier <span>$\alpha$</span>, when assuming Schottky contacts.</p></li></ul><ul><li><p><code>recombinationSRHvelocity::Matrix{Float64}</code></p><p>A 2D array with the corresponding recombination surface boundary velocity values for electrons and holes.</p></li></ul><ul><li><p><code>bRecombinationSRHTrapDensity::Matrix{Float64}</code></p><p>A 2D array with the corresponding recombination surface boundary density values for electrons and holes.</p></li></ul><ul><li><p><code>doping::Matrix{Float64}</code></p><p>A 2D array with the corresponding doping values for each carrier <span>$\alpha$</span> on each region.</p></li></ul><ul><li><p><code>densityOfStates::Matrix{Float64}</code></p><p>A 2D array with the corresponding effective density of states values <span>$N_\alpha$</span> for each carrier <span>$\alpha$</span> on each region.</p></li></ul><ul><li><p><code>bandEdgeEnergy::Matrix{Float64}</code></p><p>A 2D array with the corresponding band-edge energy values <span>$E_\alpha$</span> for each carrier <span>$\alpha$</span> on each region.</p></li></ul><ul><li><p><code>mobility::Matrix{Float64}</code></p><p>A 2D array with the corresponding mobility values <span>$\mu_\alpha$</span> for each carrier <span>$\alpha$</span> on each region.</p></li></ul><ul><li><p><code>recombinationSRHLifetime::Matrix{Float64}</code></p><p>A 2D array with the corresponding SRH lifetimes <span>$\tau_n, \tau_p$</span> for electrons and holes.</p></li></ul><ul><li><p><code>recombinationSRHTrapDensity::Matrix{Float64}</code></p><p>A 2D array with the corresponding time-independent SRH trap densities <span>$n_{\tau}, p_{\tau}$</span> for electrons and holes.</p></li></ul><ul><li><p><code>recombinationAuger::Matrix{Float64}</code></p><p>A 2D array with the corresponding Auger coefficients for electrons and holes.</p></li></ul><ul><li><p><code>dielectricConstant::Vector{Float64}</code></p><p>A region dependent dielectric constant.</p></li></ul><ul><li><p><code>generationIncidentPhotonFlux::Vector{Float64}</code></p><p>A region dependent array for the prefactor in the generation process which is the incident photon flux.</p></li></ul><ul><li><p><code>generationUniform::Vector{Float64}</code></p><p>A region dependent array for an uniform generation rate.</p></li></ul><ul><li><p><code>generationAbsorption::Vector{Float64}</code></p><p>A region dependent array for the absorption coefficient in the generation process.</p></li></ul><ul><li><p><code>recombinationRadiative::Vector{Float64}</code></p><p>A region dependent array for the radiative recombination rate.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.Params-Tuple{Any, Any}" href="#ChargeTransport.Params-Tuple{Any, Any}"><code>ChargeTransport.Params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Params(grid, numberOfCarriers) -&gt; Params
</code></pre><p>Simplified constructor for Params which only takes the grid and the numberOfCarriers as argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.ParamsNodal" href="#ChargeTransport.ParamsNodal"><code>ChargeTransport.ParamsNodal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ParamsNodal</code></pre><p>A struct holding the physical nodal, i.e. space-dependent parameters for a drift-diffusion simulation of a semiconductor device.</p><ul><li><p><code>dielectricConstant::Vector{Float64}</code></p><p>A node dependent dielectric constant.</p></li></ul><ul><li><p><code>doping::Vector{Float64}</code></p><p>A 1D array with the corresponding doping values on each node.</p></li></ul><ul><li><p><code>mobility::Matrix{Float64}</code></p><p>A 2D array with the corresponding mobility values <span>$\mu_\alpha$</span> for each carrier <span>$\alpha$</span> on each node.</p></li></ul><ul><li><p><code>densityOfStates::Matrix{Float64}</code></p><p>A 2D array with the corresponding effective density of states values <span>$N_\alpha$</span> for each carrier <span>$\alpha$</span> on each node.</p></li></ul><ul><li><p><code>bandEdgeEnergy::Matrix{Float64}</code></p><p>A 2D array with the corresponding band-edge energy values <span>$E_\alpha$</span> for each carrier <span>$\alpha$</span> on each node.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.ParamsNodal-Tuple{Any, Any}" href="#ChargeTransport.ParamsNodal-Tuple{Any, Any}"><code>ChargeTransport.ParamsNodal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ParamsNodal(grid, numberOfCarriers) -&gt; ParamsNodal
</code></pre><p>Simplified constructor for ParamsNodal which only takes the grid and the numberOfCarriers as argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.SRHWithTrapsType" href="#ChargeTransport.SRHWithTrapsType"><code>ChargeTransport.SRHWithTrapsType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible types for SRH recombination without traps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.ScharfetterGummel" href="#ChargeTransport.ScharfetterGummel"><code>ChargeTransport.ScharfetterGummel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ScharfetterGummel</code></pre><p>Abstract type for Scharfetter-Gummel flux discretization. Choose this one, when the Boltzmann statistics function is chosen as statistics, check D. Scharfetter and H. Gummel, “Large-signal analysis of a silicon Read diode oscillator”, IEEE Trans. Electr. Dev., vol. 16, pp. 64–77, 1969.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.ScharfetterGummelGraded" href="#ChargeTransport.ScharfetterGummelGraded"><code>ChargeTransport.ScharfetterGummelGraded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ScharfetterGummelGraded</code></pre><p>Abstract type for Scharfetter-Gummel flux discretization for graded effective density of states and/or graded band-edge energies. This means, use this flux when at least one of these parameters is assumed to be space-dependent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.SchottkyContact" href="#ChargeTransport.SchottkyContact"><code>ChargeTransport.SchottkyContact</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for schottky contacts as boundary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.Stationary" href="#ChargeTransport.Stationary"><code>ChargeTransport.Stationary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Stationary</code></pre><p>Abstract type for stationary simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.System" href="#ChargeTransport.System"><code>ChargeTransport.System</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct System</code></pre><p>A struct holding all information necessary for a drift-diffusion type system.</p><ul><li><p><code>data::Data</code></p><p>A struct holding all data information, see Data</p></li></ul><ul><li><p><code>fvmsys::VoronoiFVM.AbstractSystem</code></p><p>A struct holding system information for the finite volume system.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.System-Tuple{Any, Any}" href="#ChargeTransport.System-Tuple{Any, Any}"><code>ChargeTransport.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(grid, data; unknown_storage)
</code></pre><p>System constructor which builds all necessary information needed based on the input parameters with special regard to interface models. This is the main struct in which all information on the input data, but also on the solving system, are stored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.Transient" href="#ChargeTransport.Transient"><code>ChargeTransport.Transient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Transient</code></pre><p>Abstract type for transient simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.Traps" href="#ChargeTransport.Traps"><code>ChargeTransport.Traps</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Traps</code></pre><p>A struct holding all information necessary for enabling traps in the SRH recombination. With help of this constructor we can read out the index the user chooses for trap quasi Fermi potentials and the respective regions in which they are defined.</p><ul><li><p><code>traps::Int64</code></p><p>Array with the index of traps.</p></li></ul><ul><li><p><code>regions::Vector{Int64}</code></p><p>Corresponding regions where traps are assumed to be present.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><h2 id="Methods-2"><a class="docs-heading-anchor" href="#Methods-2">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.Blakemore-Tuple{Real, Real}" href="#ChargeTransport.Blakemore-Tuple{Real, Real}"><code>ChargeTransport.Blakemore</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Blakemore(x::Real, γ::Real) -&gt; Any
</code></pre><p>The Blakemore approximation <span>$1/(\exp(-x) + γ)$</span> with variable real scalar <span>$γ$</span>, see J. S. Blakemore. “The Parameters of Partially Degenerate Semiconductors”. In: Proceedings of the Physical Society. Section A 65 (1952), pp. 460–461.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.Boltzmann-Tuple{Real}" href="#ChargeTransport.Boltzmann-Tuple{Real}"><code>ChargeTransport.Boltzmann</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Boltzmann(x::Real) -&gt; Any
</code></pre><p>The Boltzmann statistics function <span>$\exp(x)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.FermiDiracMinusOne-Tuple{Real}" href="#ChargeTransport.FermiDiracMinusOne-Tuple{Real}"><code>ChargeTransport.FermiDiracMinusOne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FermiDiracMinusOne(x::Real) -&gt; Any
</code></pre><p>The Fermi-Dirac integral of order <span>$-1$</span> which reads <span>$1/(\exp(-x) + 1)$</span>, see J.S. Blakemore, Approximations for Fermi-Dirac integrals, especially the function <span>$F_{1/2} (\eta)$</span> used to describe electron density in a semiconductor, Solid-State Electronics 25 (11) (1982) 1067 – 1076.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.FermiDiracOneHalfBednarczyk-Tuple{Real}" href="#ChargeTransport.FermiDiracOneHalfBednarczyk-Tuple{Real}"><code>ChargeTransport.FermiDiracOneHalfBednarczyk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FermiDiracOneHalfBednarczyk(x::Real) -&gt; Any
</code></pre><p>The incomplete Fermi-Dirac integral of order 1/2, implemented according to [Bednarczyk1978, &quot;The Approximation of the Fermi-Dirac integral <span>$F_{1/2}(\eta)$</span>&quot;].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.FermiDiracOneHalfTeSCA-Tuple{Real}" href="#ChargeTransport.FermiDiracOneHalfTeSCA-Tuple{Real}"><code>ChargeTransport.FermiDiracOneHalfTeSCA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FermiDiracOneHalfTeSCA(x::Real) -&gt; Any
</code></pre><p>The incomplete Fermi-Dirac integral of order 1/2, implemented according to the software package TeSCA, see https://wias-berlin.de/software/index.jsp?lang=1&amp;id=TeSCA.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.RHSContinuityEquations!-NTuple{4, Any}" href="#ChargeTransport.RHSContinuityEquations!-NTuple{4, Any}"><code>ChargeTransport.RHSContinuityEquations!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RHSContinuityEquations!(f, u, node, data)
</code></pre><p>Function which builds right-hand side of electric charge carriers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.RHSPoisson!-NTuple{4, Any}" href="#ChargeTransport.RHSPoisson!-NTuple{4, Any}"><code>ChargeTransport.RHSPoisson!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RHSPoisson!(f, u, node, data) -&gt; Any
</code></pre><p>Function which builds right-hand side of Poisson equation, i.e. which builds the space charge density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.bflux!-NTuple{4, Any}" href="#ChargeTransport.bflux!-NTuple{4, Any}"><code>ChargeTransport.bflux!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bflux!(f, u, bedge, data) -&gt; Any
</code></pre><p>Master bflux! function. This is the function which enters VoronoiFVM and hands over for each boundary the flux within the boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.breaction!-NTuple{4, Any}" href="#ChargeTransport.breaction!-NTuple{4, Any}"><code>ChargeTransport.breaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">breaction!(f, u, bnode, data) -&gt; Any
</code></pre><p>Master breaction! function. This is the function which enters VoronoiFVM and hands over for each boundary the chosen boundary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{OhmicContact}}" href="#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{OhmicContact}}"><code>ChargeTransport.breaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">breaction!(f, u, bnode, data, _::Type{OhmicContact}) -&gt; Any
</code></pre><p>Creates ohmic boundary conditions via a penalty approach with penalty parameter <span>$\delta$</span>. For example, the right-hand side for the electrostatic potential <span>$\psi$</span> is implemented as</p><p><span>$f[\psi]  = -q/\delta   ( (p - N_a) - (n - N_d) )$</span>,</p><p>assuming a bipolar semiconductor. In general, we have for some given charge number <span>$z_\alpha$</span></p><p><span>$f[\psi] =  -q/\delta  \sum_\alpha{ z_\alpha  (n_\alpha - C_\alpha) },$</span></p><p>where <span>$C_\alpha$</span> corresponds to some doping w.r.t. the species <span>$\alpha$</span>.</p><p>The boundary conditions for the charge carriers are set in the main file. Hence,</p><p><span>$f[n_\alpha] = 0$</span>`</p><p>for all charge carriers <span>$\alpha$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{SchottkyContact}}" href="#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{SchottkyContact}}"><code>ChargeTransport.breaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">breaction!(f, u, bnode, data, _::Type{SchottkyContact})
</code></pre><p>Creates Schottky boundary conditions in a first attempt. For the electrostatic potential we assume</p><p><span>$\psi = \phi_S/q + U,$</span></p><p>where  <span>$\phi_S$</span> corresponds to a given value (Schottky barrier) and <span>$U$</span> to the applied voltage. For now, the quantitity <span>$\phi_S$</span> needs to be specified in the main file. For the charge carriers we assume the following</p><p><span>$f[n_\alpha]  =  z_\alpha q v_\alpha (n_\alpha - n_{\alpha, 0})$</span>,</p><p>where <span>$v_{\alpha}$</span> can be treated as a surface recombination mechanism and is given. The parameter <span>$n_{\alpha, 0}$</span> is a given value, calculated by the statistical relation, when assuming no electrical field and a quasi Fermi level equal to the Schottky barrier <span>$\phi_S$</span>, i.e.</p><p><span>$n_{\alpha, 0}= z_\alpha/ U_T (E_\alpha - \phi_S) / q.$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.bstorage!-NTuple{4, Any}" href="#ChargeTransport.bstorage!-NTuple{4, Any}"><code>ChargeTransport.bstorage!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bstorage!(f, u, bnode, data) -&gt; Any
</code></pre><p>Master bstorage! function. This is the function which enters VoronoiFVM and hands over for each boundary the time-dependent part of the chosen boundary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.charge_density-NTuple{8, Any}" href="#ChargeTransport.charge_density-NTuple{8, Any}"><code>ChargeTransport.charge_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">charge_density(psi0, phi, UT, EVector, chargeNumbers, dopingVector, dosVector, FVector) -&gt; Any
</code></pre><p>Compute the charge density, i.e. the right-hand side of Poisson&#39;s equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.charge_density-Tuple{Any, Any}" href="#ChargeTransport.charge_density-Tuple{Any, Any}"><code>ChargeTransport.charge_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">charge_density(ctsys, sol) -&gt; Any
</code></pre><p>Compute the charge density for each region separately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.compute_densities!-Tuple{Any, Any, Any, Any, Any, Bool}" href="#ChargeTransport.compute_densities!-Tuple{Any, Any, Any, Any, Any, Bool}"><code>ChargeTransport.compute_densities!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_densities!(u, data, inode, region, icc, in_region::Bool) -&gt; Any
</code></pre><p>For given potentials, compute corresponding densities. This function is needed for the method, plotting the densities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.compute_densities!-Tuple{Any, Any, Any}" href="#ChargeTransport.compute_densities!-Tuple{Any, Any, Any}"><code>ChargeTransport.compute_densities!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_densities!(grid, data, sol) -&gt; Matrix{Real}
</code></pre><p>For given potentials in vector form, compute corresponding vectorized densities. [Caution: this was not tested for multidimensions.]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.compute_energies!-Tuple{Any, Any, Any}" href="#ChargeTransport.compute_energies!-Tuple{Any, Any, Any}"><code>ChargeTransport.compute_energies!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_energies!(grid, data, sol)
</code></pre><p>For given solution in vector form, compute corresponding vectorized band-edge energies and Fermi level. [Caution: this was not tested for multidimensions.]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.degenerateLimit-Tuple{Any}" href="#ChargeTransport.degenerateLimit-Tuple{Any}"><code>ChargeTransport.degenerateLimit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degenerateLimit(x) -&gt; Any
</code></pre><p>Degenerate limit of incomplete Fermi-Dirac integral of order 1/2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.electroNeutralSolution!-Tuple{Any, Any}" href="#ChargeTransport.electroNeutralSolution!-Tuple{Any, Any}"><code>ChargeTransport.electroNeutralSolution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">electroNeutralSolution!(grid, data; Newton) -&gt; Any
</code></pre><p>Compute the electro-neutral solution for the Boltzmann approximation. It is obtained by setting the left-hand side in the Poisson equation equal to zero and solving for <span>$\psi$</span>. The charge carriers may obey different statitics functions. Currently, this one is not well tested for the case of charge carriers beyond electrons and holes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.electrochemicalReaction-NTuple{10, Any}" href="#ChargeTransport.electrochemicalReaction-NTuple{10, Any}"><code>ChargeTransport.electrochemicalReaction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">electrochemicalReaction(data, u, iphia, ipsi, iphiaJunction, ipsiJunction, β, κ, DOS, E) -&gt; Any
</code></pre><p>Electrochemical reaction between interface and bulk ionic species. This function enters in the internal boundary reaction in case of an ion charge interface model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.enable_ionic_carriers-Tuple{}" href="#ChargeTransport.enable_ionic_carriers-Tuple{}"><code>ChargeTransport.enable_ionic_carriers</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Corresponding constructor for the present ionic charge carriers and the respective regions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.enable_traps!-Tuple{}" href="#ChargeTransport.enable_traps!-Tuple{}"><code>ChargeTransport.enable_traps!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Corresponding constructor for the present traps and the respective regions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.etaFunction-NTuple{5, Any}" href="#ChargeTransport.etaFunction-NTuple{5, Any}"><code>ChargeTransport.etaFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">etaFunction(psi, phi, UT, E, z) -&gt; Any
</code></pre><p>The argument of the distribution function for given <span>$\varphi_\alpha$</span> and <span>$\psi$</span></p><p><span>$z_\alpha / U_T  ( (\varphi_\alpha - \psi) + E_\alpha / q ).$</span></p><p>The parameters <span>$E_\alpha$</span> and <span>$z_\alpha$</span> are given as vectors. This function may be used to compute the charge density, i.e. the right-hand side of the Poisson equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.etaFunction-Tuple{Any, Any, Any, Any, Any, Bool}" href="#ChargeTransport.etaFunction-Tuple{Any, Any, Any, Any, Any, Bool}"><code>ChargeTransport.etaFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">etaFunction(u, data, node, region, icc, in_region::Bool) -&gt; Any
</code></pre><p>The argument of the distribution function for floats.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.etaFunction-Tuple{Any, VoronoiFVM.BNode, Any, Any}" href="#ChargeTransport.etaFunction-Tuple{Any, VoronoiFVM.BNode, Any, Any}"><code>ChargeTransport.etaFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">etaFunction(u, bnode::VoronoiFVM.BNode, data, icc) -&gt; Any
</code></pre><p>The argument of the distribution function for boundary nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.etaFunction-Tuple{Any, VoronoiFVM.Node, Any, Any}" href="#ChargeTransport.etaFunction-Tuple{Any, VoronoiFVM.Node, Any, Any}"><code>ChargeTransport.etaFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">etaFunction(u, node::VoronoiFVM.Node, data, icc) -&gt; Any
</code></pre><p>The argument of the distribution function for interior nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.flux!-NTuple{4, Any}" href="#ChargeTransport.flux!-NTuple{4, Any}"><code>ChargeTransport.flux!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux!(f, u, edge, data) -&gt; Any
</code></pre><p>Master flux functions which enters VoronoiFVM. Flux discretization scheme is chosen in two steps. First, we need to see, if we are in or out of equilibrium. If, InEquilibrium, then no flux is passed. If outOfEquilibrium, we choose the flux approximation which the user chose.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.get_BEE!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}, VoronoiFVM.Node, Any}" href="#ChargeTransport.get_BEE!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}, VoronoiFVM.Node, Any}"><code>ChargeTransport.get_BEE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_BEE!(icc::Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}, node::VoronoiFVM.Node, data) -&gt; Any
</code></pre><p>Defining locally the band-edge energy for interior nodes (analougesly for boundary nodes and edges).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.get_DOS!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}, VoronoiFVM.Node, Any}" href="#ChargeTransport.get_DOS!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}, VoronoiFVM.Node, Any}"><code>ChargeTransport.get_DOS!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_DOS!(icc::Union{Int64, VoronoiFVM.ContinuousQuantity{Int64}, VoronoiFVM.DiscontinuousQuantity{Int64}}, node::VoronoiFVM.Node, data) -&gt; Any
</code></pre><p>Defining locally the effective DOS for interior nodes (analogously for boundary nodes and edges).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.get_current_val-NTuple{4, Any}" href="#ChargeTransport.get_current_val-NTuple{4, Any}"><code>ChargeTransport.get_current_val</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates current for time dependent problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.get_current_val-Tuple{Any, Any}" href="#ChargeTransport.get_current_val-Tuple{Any, Any}"><code>ChargeTransport.get_current_val</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates current for stationary problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.plotDiffusionEnhancements-Tuple{}" href="#ChargeTransport.plotDiffusionEnhancements-Tuple{}"><code>ChargeTransport.plotDiffusionEnhancements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotDiffusionEnhancements()
</code></pre><p>Plot diffusion enhancements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.plotDistributions-Tuple{}" href="#ChargeTransport.plotDistributions-Tuple{}"><code>ChargeTransport.plotDistributions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotDistributions(; Plotter)
</code></pre><p>Plot different distribution integrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.plot_IV-NTuple{4, Any}" href="#ChargeTransport.plot_IV-NTuple{4, Any}"><code>ChargeTransport.plot_IV</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_IV(Plotter, biasValues, IV, title; plotGridpoints) -&gt; Any
</code></pre><p>Method for showing the total current. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.plot_densities-Tuple{Any, Any, Data, Any, Any, Any}" href="#ChargeTransport.plot_densities-Tuple{Any, Any, Data, Any, Any, Any}"><code>ChargeTransport.plot_densities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_densities(Plotter, grid, data::Data, sol, title, label_density; plotGridpoints) -&gt; Any
</code></pre><p>Plotting routine, where the charge carrier densities are depicted in dependence of space. The case of heterojunctions is tested, but yet multidimensional plottings are not included. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, Data, Any}" href="#ChargeTransport.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, Data, Any}"><code>ChargeTransport.plot_doping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_doping(Plotter, g::ExtendableGrids.ExtendableGrid, data::Data, label_density) -&gt; Any
</code></pre><p>Possibility to plot the considered doping. This is especially useful for making sure that the interior and the boundary doping agree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ParamsNodal}" href="#ChargeTransport.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ParamsNodal}"><code>ChargeTransport.plot_doping</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Plot doping for nodal dependent doping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.plot_electroNeutralSolutionBoltzmann-Tuple{Any, Any, Any}" href="#ChargeTransport.plot_electroNeutralSolutionBoltzmann-Tuple{Any, Any, Any}"><code>ChargeTransport.plot_electroNeutralSolutionBoltzmann</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_electroNeutralSolutionBoltzmann(Plotter, grid, psi0; plotGridpoints) -&gt; Any
</code></pre><p>Plotting routine for depicting the electroneutral potential. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.plot_energies-Tuple{Any, Any, Data, Any, Any, Any}" href="#ChargeTransport.plot_energies-Tuple{Any, Any, Data, Any, Any, Any}"><code>ChargeTransport.plot_energies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_energies(Plotter, grid, data::Data, sol, title, label_energy; plotGridpoints) -&gt; Any
</code></pre><p>With this method it is possible to plot the energies</p><p><span>$E_\alpha - q \psi \quad \text{w.r.t. space.}$</span></p><p>The case of heterojunctions is tested, but yet multidimensional plottings are not included.</p><p>One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.plot_energies-Tuple{Any, ExtendableGrids.ExtendableGrid, Data, Any}" href="#ChargeTransport.plot_energies-Tuple{Any, ExtendableGrids.ExtendableGrid, Data, Any}"><code>ChargeTransport.plot_energies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_energies(Plotter, grid, data, label_BEE)
</code></pre><p>With this method it is possible to depict the band-edge energies <span>$E_\alpha$</span>. This can be useful for debugging when dealing with heterojunctions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.plot_solution-Tuple{Any, Any, Data, Any, Any, Any}" href="#ChargeTransport.plot_solution-Tuple{Any, Any, Data, Any, Any, Any}"><code>ChargeTransport.plot_solution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_solution(Plotter, grid, data::Data, solution, title, label_solution; plotGridpoints) -&gt; Any
</code></pre><p>Method for plotting the solution vectors: the electrostatic potential <span>$\psi$</span> as well as the charge carriers. The case of heterojunctions is tested, but yet multidimensional plottings are not included. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.printJacobi-Tuple{Any, Any}" href="#ChargeTransport.printJacobi-Tuple{Any, Any}"><code>ChargeTransport.printJacobi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printJacobi(node, sys)
</code></pre><p>First try of debugger. Print the Jacobi matrix for a given node, i.e. the number of node in the grid and not the excact coordinate. This is only done for the one dimensional case so far.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.reaction!-NTuple{4, Any}" href="#ChargeTransport.reaction!-NTuple{4, Any}"><code>ChargeTransport.reaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reaction!(f, u, node, data)
</code></pre><p>Master reaction! function. This is the function which enters VoronoiFVM and hands over reaction terms for concrete calculation type and bulk recombination model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{InEquilibrium}}" href="#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{InEquilibrium}}"><code>ChargeTransport.reaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reaction!(f, u, node, data, _::Type{InEquilibrium})
</code></pre><p>Reaction in case of equilibrium, i.e. no generation and recombination is considered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}" href="#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}"><code>ChargeTransport.reaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reaction!(f, u, node, data, _::Type{OutOfEquilibrium})
</code></pre><p>Sets up the right-hand sides. Assuming a bipolar semiconductor the right-hand side for the electrostatic potential becomes</p><p><span>$f[ψ]  = - q ((p - N_a) - (n - N_d) ) = - q  \sum  n_\alpha  (n_\alpha - C_\alpha)$</span></p><p>for some doping <span>$C_\alpha$</span> w.r.t. to the species <span>$\alpha$</span>. The right-hand sides for the charge carriers read as</p><p><span>$f[n_\alpha] =  - z_\alpha  q (G -  R)$</span></p><p>for all charge carriers <span>$n_\alpha$</span>. The recombination includes radiative, Auger and Shockley-Read-Hall recombination. For latter recombination process the stationary simplification is implemented.</p><p>The recombination is only implemented for electron and holes and assumes that the electron index is 1 and the hole index is 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.set_bulk_recombination-Tuple{}" href="#ChargeTransport.set_bulk_recombination-Tuple{}"><code>ChargeTransport.set_bulk_recombination</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_bulk_recombination(; iphin, iphip, bulk_recomb_Auger, bulk_recomb_radiative, bulk_recomb_SRH)
</code></pre><p>Corresponding constructor for the bulk recombination model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.set_plotting_labels-Tuple{Any}" href="#ChargeTransport.set_plotting_labels-Tuple{Any}"><code>ChargeTransport.set_plotting_labels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_plotting_labels(data) -&gt; Tuple{Any, Any, Matrix{String}, Any}
</code></pre><p>Method which can be used to construct the arrays parsed to the plotting routines for labeling. The description for electrons and holes are predefined. If one wishes to extend by labels for, e.g. mobile ionic carriers or traps, this can be done within the main file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.storage!-NTuple{4, Any}" href="#ChargeTransport.storage!-NTuple{4, Any}"><code>ChargeTransport.storage!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">storage!(f, u, node, data) -&gt; Union{Nothing, Float64}
</code></pre><p>Master storage! function. This is the function which enters VoronoiFVM and hands over a storage term, if we consider transient problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.storage!-Tuple{Any, Any, Any, Any, Type{Transient}}" href="#ChargeTransport.storage!-Tuple{Any, Any, Any, Any, Type{Transient}}"><code>ChargeTransport.storage!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">storage!(f, u, node, data, _::Type{Transient}) -&gt; Float64
</code></pre><p>The storage term for time-dependent problems. Currently, for the time-dependent current densities the implicit Euler scheme is used. Hence, we have</p><p><span>$f[n_\alpha] =  z_\alpha  q ∂_t n_\alpha$</span></p><p>and for the electrostatic potential <span>$f[ψ] = 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ChargeTransport.trap_density!-NTuple{4, Any}" href="#ChargeTransport.trap_density!-NTuple{4, Any}"><code>ChargeTransport.trap_density!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trap_density!(icc, ireg, data, Et)
</code></pre><p>Compute trap densities for a given trap energy. [Currently, only done for the Boltzmann statistics and for region dependent parameters.]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../PSC/">« Perovskite solar cell</a><a class="docs-footer-nextpage" href="../examples/Ex101_PIN/">GaAs diode (1D). »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Thursday 24 February 2022 13:42">Thursday 24 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
