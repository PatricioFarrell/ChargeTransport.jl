<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types, Constructors and Methods · ChargeTransport.jl</title><meta name="title" content="Types, Constructors and Methods · ChargeTransport.jl"/><meta property="og:title" content="Types, Constructors and Methods · ChargeTransport.jl"/><meta property="twitter:title" content="Types, Constructors and Methods · ChargeTransport.jl"/><meta name="description" content="Documentation for ChargeTransport.jl."/><meta property="og:description" content="Documentation for ChargeTransport.jl."/><meta property="twitter:description" content="Documentation for ChargeTransport.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../general/">ChargeTransport.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../general/">ChargeTransport.jl – Simulating charge transport in semiconductors</a></li><li><a class="tocitem" href="../backgroundinfo/">Mathematical drift-diffusion models</a></li><li><span class="tocitem">How to get started</span><ul><li><a class="tocitem" href="../GeneralInformation/">Code overview</a></li><li><a class="tocitem" href="../GaAs/">van Roosbroeck system</a></li><li><a class="tocitem" href="../PSC/">Perovskite solar cell</a></li></ul></li><li class="is-active"><a class="tocitem" href>Types, Constructors and Methods</a><ul class="internal"><li><a class="tocitem" href="#Constants,-Types-and-Constructors"><span>Constants, Types and Constructors</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li><li class="toplevel"><a class="tocitem" href="#Description-of-Constant,-Types,-Constructors-and-Methods"><span>Description of Constant, Types, Constructors and Methods</span></a></li><li><a class="tocitem" href="#Constants,-Types-and-Constructors-2"><span>Constants, Types and Constructors</span></a></li><li><a class="tocitem" href="#Methods-2"><span>Methods</span></a></li></ul></li><li><span class="tocitem">Pluto Notebooks</span><ul><li><a class="tocitem" href="../nbhtml/PSC_example/">PSC example</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/Ex101_PIN/">GaAs diode (1D).</a></li><li><a class="tocitem" href="../examples/Ex102_PIN_nodal_doping/">GaAs diode with spatially varying doping (1D).</a></li><li><a class="tocitem" href="../examples/Ex103_PSC_IVMeasurement/">PSC device with ions and different I-V scan protocols (1D).</a></li><li><a class="tocitem" href="../examples/Ex104_PSC_Photogeneration/">PSC device with photogeneration rate (1D).</a></li><li><a class="tocitem" href="../examples/Ex105_PSC_gradedFlux/">Three-layer PSC device with graded interfaces &amp; Ohmic contacts (1D).</a></li><li><a class="tocitem" href="../examples/Ex106_PSC_SurfaceRecombination/">PSC device with surface recombination (1D).</a></li><li><a class="tocitem" href="../examples/Ex107_MoS2_withIons_BarrierLowering/">MoS2 with moving defects and Schottky Barrier Lowering.</a></li><li><a class="tocitem" href="../examples/Ex108_CIGS_WithTraps/">CIGS: stationary with traps and Schottky contacts.</a></li><li><a class="tocitem" href="../examples/Ex109_Traps/">GaAs diode: transient with traps (1D).</a></li><li><a class="tocitem" href="../examples/Ex201_PSC_tensorGrid/">PSC device on 2D domain (Tensor grid).</a></li><li><a class="tocitem" href="../examples/Grid_3D/">Example code for a 3D grid.</a></li><li><a class="tocitem" href="../examples/Non_RectangularGrid_2D/">Example code for a 2D non rectangular grid.</a></li><li><a class="tocitem" href="../examples/PSC_2D_unstructuredGrid/">PSC device on 2D domain (unstructured grid).</a></li><li><a class="tocitem" href="../examples/PSC_3D/">Illustrative example of a three dimensional simulation.</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Types, Constructors and Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types, Constructors and Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/PatricioFarrell/ChargeTransport.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Overview-–-Constants,-Types,-Constructors-and-Methods"><a class="docs-heading-anchor" href="#Overview-–-Constants,-Types,-Constructors-and-Methods">Overview – Constants, Types, Constructors and Methods</a><a id="Overview-–-Constants,-Types,-Constructors-and-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-–-Constants,-Types,-Constructors-and-Methods" title="Permalink"></a></h1><h2 id="Constants,-Types-and-Constructors"><a class="docs-heading-anchor" href="#Constants,-Types-and-Constructors">Constants, Types and Constructors</a><a id="Constants,-Types-and-Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constants,-Types-and-Constructors" title="Permalink"></a></h2><ul><li><a href="#ChargeTransport.BarrierLoweringOff"><code>ChargeTransport.BarrierLoweringOff</code></a></li><li><a href="#ChargeTransport.BarrierLoweringOn"><code>ChargeTransport.BarrierLoweringOn</code></a></li><li><a href="#ChargeTransport.BarrierLoweringType"><code>ChargeTransport.BarrierLoweringType</code></a></li><li><a href="#ChargeTransport.BoundaryModelType"><code>ChargeTransport.BoundaryModelType</code></a></li><li><a href="#ChargeTransport.BulkRecombination"><code>ChargeTransport.BulkRecombination</code></a></li><li><a href="#ChargeTransport.CalculationType"><code>ChargeTransport.CalculationType</code></a></li><li><a href="#ChargeTransport.Data"><code>ChargeTransport.Data</code></a></li><li><a href="#ChargeTransport.Data-Union{Tuple{TFuncs}, Tuple{Any, Any}} where TFuncs"><code>ChargeTransport.Data</code></a></li><li><a href="#ChargeTransport.DiffusionEnhanced"><code>ChargeTransport.DiffusionEnhanced</code></a></li><li><a href="#ChargeTransport.ExcessChemicalPotential"><code>ChargeTransport.ExcessChemicalPotential</code></a></li><li><a href="#ChargeTransport.ExcessChemicalPotentialGraded"><code>ChargeTransport.ExcessChemicalPotentialGraded</code></a></li><li><a href="#ChargeTransport.FluxApproximationType"><code>ChargeTransport.FluxApproximationType</code></a></li><li><a href="#ChargeTransport.GeneralizedSG"><code>ChargeTransport.GeneralizedSG</code></a></li><li><a href="#ChargeTransport.GenerationBeerLambert"><code>ChargeTransport.GenerationBeerLambert</code></a></li><li><a href="#ChargeTransport.GenerationModelType"><code>ChargeTransport.GenerationModelType</code></a></li><li><a href="#ChargeTransport.GenerationNone"><code>ChargeTransport.GenerationNone</code></a></li><li><a href="#ChargeTransport.GenerationUniform"><code>ChargeTransport.GenerationUniform</code></a></li><li><a href="#ChargeTransport.GenerationUserDefined"><code>ChargeTransport.GenerationUserDefined</code></a></li><li><a href="#ChargeTransport.InEquilibrium"><code>ChargeTransport.InEquilibrium</code></a></li><li><a href="#ChargeTransport.InterfaceModelType"><code>ChargeTransport.InterfaceModelType</code></a></li><li><a href="#ChargeTransport.InterfaceNone"><code>ChargeTransport.InterfaceNone</code></a></li><li><a href="#ChargeTransport.InterfaceRecombination"><code>ChargeTransport.InterfaceRecombination</code></a></li><li><a href="#ChargeTransport.MixedOhmicSchottkyContact"><code>ChargeTransport.MixedOhmicSchottkyContact</code></a></li><li><a href="#ChargeTransport.ModelType"><code>ChargeTransport.ModelType</code></a></li><li><a href="#ChargeTransport.OhmicContact"><code>ChargeTransport.OhmicContact</code></a></li><li><a href="#ChargeTransport.OhmicContactModelType"><code>ChargeTransport.OhmicContactModelType</code></a></li><li><a href="#ChargeTransport.OutOfEquilibrium"><code>ChargeTransport.OutOfEquilibrium</code></a></li><li><a href="#ChargeTransport.OuterBoundaryModelType"><code>ChargeTransport.OuterBoundaryModelType</code></a></li><li><a href="#ChargeTransport.Params-Tuple{Any, Any}"><code>ChargeTransport.Params</code></a></li><li><a href="#ChargeTransport.Params"><code>ChargeTransport.Params</code></a></li><li><a href="#ChargeTransport.ParamsNodal-Tuple{Any, Any}"><code>ChargeTransport.ParamsNodal</code></a></li><li><a href="#ChargeTransport.ParamsNodal"><code>ChargeTransport.ParamsNodal</code></a></li><li><a href="#ChargeTransport.QType"><code>ChargeTransport.QType</code></a></li><li><a href="#ChargeTransport.SRHWithTrapsType"><code>ChargeTransport.SRHWithTrapsType</code></a></li><li><a href="#ChargeTransport.SRHWithoutTrapsType"><code>ChargeTransport.SRHWithoutTrapsType</code></a></li><li><a href="#ChargeTransport.ScharfetterGummel"><code>ChargeTransport.ScharfetterGummel</code></a></li><li><a href="#ChargeTransport.ScharfetterGummelGraded"><code>ChargeTransport.ScharfetterGummelGraded</code></a></li><li><a href="#ChargeTransport.SchottkyContact"><code>ChargeTransport.SchottkyContact</code></a></li><li><a href="#ChargeTransport.StandardFuncSet"><code>ChargeTransport.StandardFuncSet</code></a></li><li><a href="#ChargeTransport.Stationary"><code>ChargeTransport.Stationary</code></a></li><li><a href="#ChargeTransport.System"><code>ChargeTransport.System</code></a></li><li><a href="#ChargeTransport.System-Tuple{Any, Any}"><code>ChargeTransport.System</code></a></li><li><a href="#ChargeTransport.Transient"><code>ChargeTransport.Transient</code></a></li><li><a href="#ChargeTransport.TrapCarrier"><code>ChargeTransport.TrapCarrier</code></a></li></ul><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><ul><li><a href="#ChargeTransport.Blakemore-Tuple{Real, Real}"><code>ChargeTransport.Blakemore</code></a></li><li><a href="#ChargeTransport.Boltzmann-Tuple{Real}"><code>ChargeTransport.Boltzmann</code></a></li><li><a href="#ChargeTransport.FermiDiracMinusOne-Tuple{Real}"><code>ChargeTransport.FermiDiracMinusOne</code></a></li><li><a href="#ChargeTransport.FermiDiracOneHalfBednarczyk-Tuple{Real}"><code>ChargeTransport.FermiDiracOneHalfBednarczyk</code></a></li><li><a href="#ChargeTransport.FermiDiracOneHalfTeSCA-Tuple{Real}"><code>ChargeTransport.FermiDiracOneHalfTeSCA</code></a></li><li><a href="#ChargeTransport.RHSContinuityEquations!-NTuple{4, Any}"><code>ChargeTransport.RHSContinuityEquations!</code></a></li><li><a href="#ChargeTransport.RHSPoisson!-NTuple{5, Any}"><code>ChargeTransport.RHSPoisson!</code></a></li><li><a href="#ChargeTransport.add_trap_density_Poisson!-Tuple{}"><code>ChargeTransport.add_trap_density_Poisson!</code></a></li><li><a href="#ChargeTransport.bflux!-NTuple{4, Any}"><code>ChargeTransport.bflux!</code></a></li><li><a href="#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{OhmicContactRobin}}"><code>ChargeTransport.breaction!</code></a></li><li><a href="#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{SchottkyBarrierLowering}}"><code>ChargeTransport.breaction!</code></a></li><li><a href="#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{OhmicContactDirichlet}}"><code>ChargeTransport.breaction!</code></a></li><li><a href="#ChargeTransport.breaction!-NTuple{4, Any}"><code>ChargeTransport.breaction!</code></a></li><li><a href="#ChargeTransport.bstorage!-NTuple{4, Any}"><code>ChargeTransport.bstorage!</code></a></li><li><a href="#ChargeTransport.build_system-Tuple{Any, Any, Type{ContQF}}"><code>ChargeTransport.build_system</code></a></li><li><a href="#ChargeTransport.build_system-Tuple{Any, Any, Type{DiscontQF}}"><code>ChargeTransport.build_system</code></a></li><li><a href="#ChargeTransport.charge_density-Tuple{Any, Any}"><code>ChargeTransport.charge_density</code></a></li><li><a href="#ChargeTransport.charge_density-NTuple{8, Any}"><code>ChargeTransport.charge_density</code></a></li><li><a href="#ChargeTransport.degenerateLimit-Tuple{Any}"><code>ChargeTransport.degenerateLimit</code></a></li><li><a href="#ChargeTransport.electroNeutralSolution-Tuple{Any}"><code>ChargeTransport.electroNeutralSolution</code></a></li><li><a href="#ChargeTransport.enable_ionic_carrier!-Tuple{Any}"><code>ChargeTransport.enable_ionic_carrier!</code></a></li><li><a href="#ChargeTransport.enable_trap_carrier!-Tuple{}"><code>ChargeTransport.enable_trap_carrier!</code></a></li><li><a href="#ChargeTransport.etaFunction-Tuple{Any, Any, Any, Any, Any, Bool}"><code>ChargeTransport.etaFunction</code></a></li><li><a href="#ChargeTransport.etaFunction-Tuple{Any, Int64, Any, Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}}"><code>ChargeTransport.etaFunction</code></a></li><li><a href="#ChargeTransport.etaFunction-NTuple{5, Any}"><code>ChargeTransport.etaFunction</code></a></li><li><a href="#ChargeTransport.etaFunction!-Tuple{Any, VoronoiFVM.BNode, Any, Any}"><code>ChargeTransport.etaFunction!</code></a></li><li><a href="#ChargeTransport.etaFunction!-Tuple{Any, VoronoiFVM.Node, Any, Any}"><code>ChargeTransport.etaFunction!</code></a></li><li><a href="#ChargeTransport.flux!-NTuple{4, Any}"><code>ChargeTransport.flux!</code></a></li><li><a href="#ChargeTransport.generic_operator!-Tuple{Any, Any, Any}"><code>ChargeTransport.generic_operator!</code></a></li><li><a href="#ChargeTransport.get_BEE!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}, VoronoiFVM.Node, Any}"><code>ChargeTransport.get_BEE!</code></a></li><li><a href="#ChargeTransport.get_DOS!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}, VoronoiFVM.Node, Any}"><code>ChargeTransport.get_DOS!</code></a></li><li><a href="#ChargeTransport.get_current_val-Tuple{Any, Any}"><code>ChargeTransport.get_current_val</code></a></li><li><a href="#ChargeTransport.get_current_val-NTuple{4, Any}"><code>ChargeTransport.get_current_val</code></a></li><li><a href="#ChargeTransport.get_density-Tuple{Any, Int64, Any, Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}}"><code>ChargeTransport.get_density</code></a></li><li><a href="#ChargeTransport.get_density-NTuple{4, Any}"><code>ChargeTransport.get_density</code></a></li><li><a href="#ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.Node, Any, Any}"><code>ChargeTransport.get_density!</code></a></li><li><a href="#ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.BNode, Any, Any}"><code>ChargeTransport.get_density!</code></a></li><li><a href="#ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.Edge, Any, Any}"><code>ChargeTransport.get_density!</code></a></li><li><a href="#ChargeTransport.plotDiffusionEnhancements-Tuple{}"><code>ChargeTransport.plotDiffusionEnhancements</code></a></li><li><a href="#ChargeTransport.plotDistributions-Tuple{}"><code>ChargeTransport.plotDistributions</code></a></li><li><a href="#ChargeTransport.plot_IV-NTuple{4, Any}"><code>ChargeTransport.plot_IV</code></a></li><li><a href="#ChargeTransport.plot_densities-NTuple{5, Any}"><code>ChargeTransport.plot_densities</code></a></li><li><a href="#ChargeTransport.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ParamsNodal}"><code>ChargeTransport.plot_doping</code></a></li><li><a href="#ChargeTransport.plot_doping-Tuple{Any, Any, Any}"><code>ChargeTransport.plot_doping</code></a></li><li><a href="#ChargeTransport.plot_electroNeutralSolutionBoltzmann-Tuple{Any, Any, Any}"><code>ChargeTransport.plot_electroNeutralSolutionBoltzmann</code></a></li><li><a href="#ChargeTransport.plot_energies-Tuple{Any, Any, Any}"><code>ChargeTransport.plot_energies</code></a></li><li><a href="#ChargeTransport.plot_energies-NTuple{5, Any}"><code>ChargeTransport.plot_energies</code></a></li><li><a href="#ChargeTransport.plot_solution-NTuple{5, Any}"><code>ChargeTransport.plot_solution</code></a></li><li><a href="#ChargeTransport.printJacobi-Tuple{Any, Any}"><code>ChargeTransport.printJacobi</code></a></li><li><a href="#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{InEquilibrium}}"><code>ChargeTransport.reaction!</code></a></li><li><a href="#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}"><code>ChargeTransport.reaction!</code></a></li><li><a href="#ChargeTransport.reaction!-NTuple{4, Any}"><code>ChargeTransport.reaction!</code></a></li><li><a href="#ChargeTransport.set_bulk_recombination-Tuple{}"><code>ChargeTransport.set_bulk_recombination</code></a></li><li><a href="#ChargeTransport.set_plotting_labels-Tuple{Any}"><code>ChargeTransport.set_plotting_labels</code></a></li><li><a href="#ChargeTransport.storage!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}"><code>ChargeTransport.storage!</code></a></li><li><a href="#ChargeTransport.storage!-NTuple{4, Any}"><code>ChargeTransport.storage!</code></a></li><li><a href="#ChargeTransport.trap_density!-NTuple{4, Any}"><code>ChargeTransport.trap_density!</code></a></li><li><a href="#ChargeTransport.zeroVoltage-Tuple{Any}"><code>ChargeTransport.zeroVoltage</code></a></li></ul><h1 id="Description-of-Constant,-Types,-Constructors-and-Methods"><a class="docs-heading-anchor" href="#Description-of-Constant,-Types,-Constructors-and-Methods">Description of Constant, Types, Constructors and Methods</a><a id="Description-of-Constant,-Types,-Constructors-and-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Description-of-Constant,-Types,-Constructors-and-Methods" title="Permalink"></a></h1><h2 id="Constants,-Types-and-Constructors-2"><a class="docs-heading-anchor" href="#Constants,-Types-and-Constructors-2">Constants, Types and Constructors</a><a class="docs-heading-anchor-permalink" href="#Constants,-Types-and-Constructors-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.BarrierLoweringType" href="#ChargeTransport.BarrierLoweringType"><code>ChargeTransport.BarrierLoweringType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible types for barrier lowering model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.BoundaryModelType" href="#ChargeTransport.BoundaryModelType"><code>ChargeTransport.BoundaryModelType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible types of boundary models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.CalculationType" href="#ChargeTransport.CalculationType"><code>ChargeTransport.CalculationType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible types for calculation type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.FluxApproximationType" href="#ChargeTransport.FluxApproximationType"><code>ChargeTransport.FluxApproximationType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible types of flux discretization schemes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.GenerationModelType" href="#ChargeTransport.GenerationModelType"><code>ChargeTransport.GenerationModelType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible types for generation model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.InterfaceModelType" href="#ChargeTransport.InterfaceModelType"><code>ChargeTransport.InterfaceModelType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible Types of interface model (interior boundary conditions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.ModelType" href="#ChargeTransport.ModelType"><code>ChargeTransport.ModelType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible types which indicate, if we consider stationary or transient problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.OhmicContactModelType" href="#ChargeTransport.OhmicContactModelType"><code>ChargeTransport.OhmicContactModelType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible mathematical types of ohmic contact boundary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.OuterBoundaryModelType" href="#ChargeTransport.OuterBoundaryModelType"><code>ChargeTransport.OuterBoundaryModelType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible types of outer boundary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.QType" href="#ChargeTransport.QType"><code>ChargeTransport.QType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type of charge carriers and the electric potential (corresponding to VoronoiFVM.jl).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.SRHWithTrapsType" href="#ChargeTransport.SRHWithTrapsType"><code>ChargeTransport.SRHWithTrapsType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible types for SRH recombination without traps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.SRHWithoutTrapsType" href="#ChargeTransport.SRHWithoutTrapsType"><code>ChargeTransport.SRHWithoutTrapsType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Possible type for SRH recombination without traps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.StandardFuncSet" href="#ChargeTransport.StandardFuncSet"><code>ChargeTransport.StandardFuncSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type of statistics functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.BarrierLoweringOff" href="#ChargeTransport.BarrierLoweringOff"><code>ChargeTransport.BarrierLoweringOff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type BarrierLoweringOff</code></pre><p>Abstract type for the neglection of Schottky barrier lowering as boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.BarrierLoweringOn" href="#ChargeTransport.BarrierLoweringOn"><code>ChargeTransport.BarrierLoweringOn</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type BarrierLoweringOn</code></pre><p>Abstract type for the choice of Schottky barrier lowering as boundary conditions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.BulkRecombination" href="#ChargeTransport.BulkRecombination"><code>ChargeTransport.BulkRecombination</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct BulkRecombination</code></pre><p>A struct holding all necessary information for building bulk recombination. With help of this constructor we can read out the indices the user chooses for electron and hole quasi Fermi potentials.</p><ul><li><code>iphin::Int64</code>: Index for FVM construction of electron quasi Fermi potential.</li></ul><ul><li><code>iphip::Int64</code>: Index for FVM construction of hole quasi Fermi potential.</li></ul><ul><li><code>bulk_recomb_Auger::Bool</code>: Boolean for present Auger recombination in bulk.</li></ul><ul><li><code>bulk_recomb_radiative::Bool</code>: Boolean for present radiative recombination in bulk.</li></ul><ul><li><code>bulk_recomb_SRH::Union{Type{SRHOff}, Type{ChargeTransport.SRHStationary}, Type{SRHTrapsStationary}, Type{SRHTrapsTransient}}</code>: DataType for present SRH recombination in bulk. This needs to be a Type due to cases with or without mobile traps.</li></ul><ul><li><code>SRH_2species_trap::Union{Type{SRH2SpeciesPresentTrapDens}, Type{SRHOff}, Type{ChargeTransport.SRHStationary}}</code>: Data type with which you can include a stationary trap density to the right-hand side of the Poisson equation. This stationary trap density corresponds to the number of unoccupied trap states.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.Data" href="#ChargeTransport.Data"><code>ChargeTransport.Data</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Data{TFuncs&lt;:Function, TVoltageFunc&lt;:Function, TGenerationData&lt;:Union{Array{Float64, 3}, Function, VecOrMat{Float64}}}</code></pre><p>A struct holding all data information including model and numerics information, but also all physical parameters for a drift-diffusion simulation of a semiconductor device.</p><ul><li><code>F::Vector{TFuncs} where TFuncs&lt;:Function</code>: An array with the corresponding distribution function <span>$\mathcal{F}_\alpha$</span> for all carriers <span>$\alpha$</span>.</li></ul><ul><li><code>qFModel::Union{Type{ContQF}, Type{DiscontQF}}</code>: An datatype containing the information, whether at least on quasi Fermi potential is assumend to be continuous or discontinuous.</li></ul><ul><li><code>boundaryType::Vector{Union{Type{InterfaceNone}, Type{InterfaceRecombination}, Type{MixedOhmicSchottkyContact}, Type{OhmicContact}, Type{SchottkyBarrierLowering}, Type{SchottkyContact}}}</code>: An array of DataTypes with the type of boundary model for each boundary (interior and exterior).</li></ul><ul><li><code>contactVoltageFunction::Vector{TVoltageFunc} where TVoltageFunc&lt;:Function</code>: An array containing predefined functions for the applied bias in dependance of time at each outer boundary.</li></ul><ul><li><code>bulkRecombination::BulkRecombination</code>: A struct containing information concerning the bulk recombination model.</li></ul><ul><li><code>generationData::Union{Array{Float64, 3}, Function, VecOrMat{Float64}}</code>: A function/Array containing the user-specific photogeneration rate. It can be a function which is specified in the user example or an array which is read in and calculatd with, e.g., an external software.</li></ul><ul><li><code>isContinuous::Vector{Bool}</code>: An array containing information on whether charge carriers are continuous or discontinuous. This is needed for building the AbstractQuantities which handle the indices of charge carriers on different regions.</li></ul><ul><li><code>chargeCarrierList::Vector{Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}}</code>: This list stores all charge carriers with the correct type needed for VoronoiFVM.</li></ul><ul><li><code>electricCarrierList::Vector{Int64}</code>: This list stores all electric carrier indices, i.e. the one of electrons and holes.</li></ul><ul><li><code>ionicCarrierList::Vector{ChargeTransport.IonicCarrier}</code>: This list contains all defined ionic carriers as a struct of Type IonicCarrier with all needed information on the ionic carriers (can be either ions or ion vacancies).</li></ul><ul><li><code>trapCarrierList::Vector{ChargeTransport.TrapCarrier}</code>: This list contains all defined trap carriers for the SRH recombination as a struct of Type TrapCarrier with all needed information on the trap carriers.</li></ul><ul><li><code>AuxTrapValues::ChargeTransport.AuxiliaryStationaryTrapValues</code>: A struct which contains auxiliary trap values for the stationary setting.</li></ul><ul><li><code>index_psi::Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}</code>: This variable stores the index of the electric potential. Based on the user choice we have with this new type the opportunity to simulate discontinuous unknowns.</li></ul><ul><li><code>barrierLoweringInfo::ChargeTransport.BarrierLoweringSpecies</code>: This is a struct containing all information necessary to simulate Schottky Barrier Lowering.</li></ul><ul><li><code>fluxApproximation::Vector{Union{Type{DiffusionEnhanced}, Type{DiffusionEnhancedModifiedDrift}, Type{ExcessChemicalPotential}, Type{ExcessChemicalPotentialGraded}, Type{GeneralizedSG}, Type{ScharfetterGummel}, Type{ScharfetterGummelGraded}}}</code>: A DataType for the flux discretization method.</li></ul><ul><li><code>calculationType::Union{Type{InEquilibrium}, Type{OutOfEquilibrium}}</code>: A DataType for equilibrium or out of equilibrium calculations.</li></ul><ul><li><code>modelType::Union{Type{Stationary}, Type{Transient}}</code>: A DataType for transient or stationary calculations.</li></ul><ul><li><code>generationModel::Union{Type{GenerationBeerLambert}, Type{GenerationNone}, Type{GenerationUniform}, Type{GenerationUserDefined}}</code>: A DataType for for generation model.</li></ul><ul><li><code>λ1::Float64</code>: An embedding parameter used to solve the nonlinear Poisson problem, where for λ1 = 0 the right hand-side is set to zero whereas for for λ1 = 1 we have a full space charge density.</li></ul><ul><li><code>λ2::Float64</code>: An embedding parameter for the generation rate.</li></ul><ul><li><code>λ3::Float64</code>: An embedding parameter for an electrochemical reaction.</li></ul><ul><li><code>ohmicContactModel::Union{Type{OhmicContactDirichlet}, Type{OhmicContactRobin}}</code>: Possibility to change the implementation of the ohmic contact boundary model for the electric potential (Dirichlet or Robin)</li></ul><ul><li><code>tempBEE1::Vector{Float64}</code>: Within this template informations concerning the band-edge energy of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.</li></ul><ul><li><code>tempBEE2::Vector{Float64}</code>: See the description of tempBEE1.</li></ul><ul><li><code>tempDOS1::Vector{Float64}</code>: Within this template informations concerning the effective DOS of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.</li></ul><ul><li><code>tempDOS2::Vector{Float64}</code>: See the desciption of tempDOS2.</li></ul><ul><li><code>params::Params</code>: A struct holding all region dependent parameter information. For more information see struct Params.</li></ul><ul><li><code>paramsnodal::ParamsNodal</code>: A struct holding all space dependent parameter information. For more information see struct ParamsNodal.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.Data-Union{Tuple{TFuncs}, Tuple{Any, Any}} where TFuncs" href="#ChargeTransport.Data-Union{Tuple{TFuncs}, Tuple{Any, Any}} where TFuncs"><code>ChargeTransport.Data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Data(
    grid,
    numberOfCarriers;
    contactVoltageFunction,
    generationData,
    statfunctions
) -&gt; Data{StandardFuncSet, T, Vector{Float64}} where T&lt;:Function
</code></pre><p>Simplified constructor for Data which only takes the grid and the numberOfCarriers as argument. Here, all necessary information including the physical parameters, but also some numerical information are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.DiffusionEnhanced" href="#ChargeTransport.DiffusionEnhanced"><code>ChargeTransport.DiffusionEnhanced</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type DiffusionEnhanced</code></pre><p>Abstract type for diffusion enhanced flux discretization, check M. Bessemoulin-Chatard, “A finite volume scheme for convection–diffusion equations with nonlinear diffusion derived from the Scharfetter–Gummel scheme”, Numerische Mathematik, vol. 121, pp. 637–670, 2012.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.ExcessChemicalPotential" href="#ChargeTransport.ExcessChemicalPotential"><code>ChargeTransport.ExcessChemicalPotential</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ExcessChemicalPotential</code></pre><p>Abstract type for excess chemical potential flux discretization, check  Z. Yu, and R. Dutton, “SEDAN III – A one-dimensional device simulator”, http://www-tcad.stanford.edu/tcad/programs/sedan3.html, 1988.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.ExcessChemicalPotentialGraded" href="#ChargeTransport.ExcessChemicalPotentialGraded"><code>ChargeTransport.ExcessChemicalPotentialGraded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ExcessChemicalPotentialGraded</code></pre><p>Abstract type for excess chemical potential flux discretization for graded effective density of states and/or graded band-edge energies. This means, use this flux when at least one of these parameters is assumed to be space-dependent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.GeneralizedSG" href="#ChargeTransport.GeneralizedSG"><code>ChargeTransport.GeneralizedSG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GeneralizedSG</code></pre><p>Abstract type for generalized Scharfetter-Gummel flux discretization. This flux approximation results in an implicit equation which needs to be solved and is exact for all Blakemore type statistics functions with abritary γ, check T. Koprucki and K. Gärtner. “Discretization scheme for drift-diffusion equations with strong diffusion enhancement”. In: 12th International Conference on Numerical Simulation of Optoelectronic Devices (NUSOD). 2012, pp. 103–104.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.GenerationBeerLambert" href="#ChargeTransport.GenerationBeerLambert"><code>ChargeTransport.GenerationBeerLambert</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GenerationBeerLambert</code></pre><p>Abstract type for Beer-Lambert generation. Note that this type is implemented, but not well tested yet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.GenerationNone" href="#ChargeTransport.GenerationNone"><code>ChargeTransport.GenerationNone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GenerationNone</code></pre><p>Abstract type for no generation model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.GenerationUniform" href="#ChargeTransport.GenerationUniform"><code>ChargeTransport.GenerationUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GenerationUniform</code></pre><p>Abstract type for uniform generation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.GenerationUserDefined" href="#ChargeTransport.GenerationUserDefined"><code>ChargeTransport.GenerationUserDefined</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type GenerationUserDefined</code></pre><p>Abstract type for user defined generation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.InEquilibrium" href="#ChargeTransport.InEquilibrium"><code>ChargeTransport.InEquilibrium</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type InEquilibrium</code></pre><p>Abstract type for equilibrium calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.InterfaceNone" href="#ChargeTransport.InterfaceNone"><code>ChargeTransport.InterfaceNone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type InterfaceNone</code></pre><p>Abstract type for no interface model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.InterfaceRecombination" href="#ChargeTransport.InterfaceRecombination"><code>ChargeTransport.InterfaceRecombination</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type InterfaceRecombination</code></pre><p>Abstract type for surface recombination mechanisms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.MixedOhmicSchottkyContact" href="#ChargeTransport.MixedOhmicSchottkyContact"><code>ChargeTransport.MixedOhmicSchottkyContact</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for a mixed Ohmic and Schottky boundary model, resulting in all Dirichlet type conditions for electrons, holes and the electric potential.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.OhmicContact" href="#ChargeTransport.OhmicContact"><code>ChargeTransport.OhmicContact</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for ohmic contacts as outer boundary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.OutOfEquilibrium" href="#ChargeTransport.OutOfEquilibrium"><code>ChargeTransport.OutOfEquilibrium</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type OutOfEquilibrium</code></pre><p>Abstract type for out of equilibrium calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.Params" href="#ChargeTransport.Params"><code>ChargeTransport.Params</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Params</code></pre><p>A struct holding the physical region dependent parameters for a drift-diffusion simulation of a semiconductor device.</p><ul><li><code>numberOfNodes::Int64</code>: Number of nodes used for the disretization of the domain <span>$\mathbf{\Omega}$</span>.</li></ul><ul><li><code>numberOfRegions::Int64</code>: Number of subregions <span>$\mathbf{\Omega}_k$</span> within the domain <span>$\mathbf{\Omega}$</span>.</li></ul><ul><li><code>numberOfBoundaryRegions::Int64</code>: Number of boundary regions <span>$(\partial \mathbf{\Omega})_k$</span> such that <span>$\partial \mathbf{\Omega} = \cup_k (\partial \mathbf{\Omega})_k$</span>. Note that here are inner and outer boundaries calculated.</li></ul><ul><li><code>numberOfCarriers::Int64</code>: Number of moving charge carriers.</li></ul><ul><li><code>invertedIllumination::Int64</code>: Parameter for the direction of illumination. If illumination is coming from the left, then set this value to 1. Otherwise, if the illumination comes from the right, set this value to -1.</li></ul><ul><li><code>temperature::Float64</code>: A given constant temperature.</li></ul><ul><li><code>UT::Float64</code>: The thermal voltage, which reads  <span>$U_T = k_B T / q$</span>.</li></ul><ul><li><code>γ::Float64</code>: The parameter of the Blakemore statistics (needed for the generalizedSG flux).</li></ul><ul><li><code>r0::Float64</code>: Prefactor of electro-chemical reaction of internal boundary conditions.</li></ul><ul><li><code>prefactor_SRH::Float64</code>: Prefactor for stationary SRH recombination.</li></ul><ul><li><code>generationPeak::Float64</code>: Parameter for the shift of generation peak of the Beer-Lambert generation profile.</li></ul><ul><li><code>SchottkyBarrier::Vector{Float64}</code>: An array for the given Schottky barriers at present Schotkky contacts.</li></ul><ul><li><code>contactVoltage::Vector{Float64}</code>: An array containing a constant value for the applied voltage.</li></ul><ul><li><code>bψEQ::Vector{Float64}</code>: An array containing a constant value for the electric potential in case of Dirichlet boundary conditions.</li></ul><ul><li><code>chargeNumbers::Vector{Float64}</code>: An array with the corresponding charge numbers <span>$z_\alpha$</span> for all carriers <span>$\alpha$</span>.</li></ul><ul><li><code>bBandEdgeEnergy::Matrix{Float64}</code>: An array with the corresponding boundary band-edge energy values <span>$E_\alpha$</span> in each region for each carrier <span>$\alpha$</span>.</li></ul><ul><li><code>bDensityOfStates::Matrix{Float64}</code>: An array with the corresponding boundary effective density of states values <span>$N_\alpha$</span> for each carrier <span>$\alpha$</span>.</li></ul><ul><li><code>bMobility::Matrix{Float64}</code>: A 2D array with the corresponding boundary mobility values <span>$\mu_\alpha$</span> in each boundary region for each carrier <span>$\alpha$</span>.</li></ul><ul><li><code>bDoping::Matrix{Float64}</code>: A 2D array with the corresponding boundary doping values for each carrier <span>$\alpha$</span>.</li></ul><ul><li><code>bVelocity::Matrix{Float64}</code>: A 2D array with the corresponding boundary velocity values for each carrier <span>$\alpha$</span>, when assuming Schottky contacts.</li></ul><ul><li><code>bReactionCoefficient::Matrix{Float64}</code>: An array to define the reaction coefficient at internal boundaries.</li></ul><ul><li><code>recombinationSRHvelocity::Matrix{Float64}</code>: A 2D array with the corresponding recombination surface boundary velocity values for electrons and holes.</li></ul><ul><li><code>bRecombinationSRHTrapDensity::Matrix{Float64}</code>: A 2D array with the corresponding recombination surface boundary density values for electrons and holes.</li></ul><ul><li><code>bRecombinationSRHLifetime::Matrix{Float64}</code>: A 2D array with the corresponding recombination surface recombination velocities.</li></ul><ul><li><code>bDensityEQ::Matrix{Float64}</code>: A 2D array containing the equilibrium density of electric charge carriers at the boundary.</li></ul><ul><li><code>doping::Matrix{Float64}</code>: A 2D array with the corresponding doping values for each carrier <span>$\alpha$</span> on each region.</li></ul><ul><li><code>densityOfStates::Matrix{Float64}</code>: A 2D array with the corresponding effective density of states values <span>$N_\alpha$</span> for each carrier <span>$\alpha$</span> on each region.</li></ul><ul><li><code>bandEdgeEnergy::Matrix{Float64}</code>: A 2D array with the corresponding band-edge energy values <span>$E_\alpha$</span> for each carrier <span>$\alpha$</span> on each region.</li></ul><ul><li><code>mobility::Matrix{Float64}</code>: A 2D array with the corresponding mobility values <span>$\mu_\alpha$</span> for each carrier <span>$\alpha$</span> on each region.</li></ul><ul><li><code>recombinationSRHLifetime::Matrix{Float64}</code>: A 2D array with the corresponding SRH lifetimes <span>$\tau_n, \tau_p$</span> for electrons and holes.</li></ul><ul><li><code>recombinationSRHTrapDensity::Matrix{Float64}</code>: A 2D array with the corresponding time-independent SRH trap densities <span>$n_{\tau}, p_{\tau}$</span> for electrons and holes.</li></ul><ul><li><code>recombinationAuger::Matrix{Float64}</code>: A 2D array with the corresponding Auger coefficients for electrons and holes.</li></ul><ul><li><code>dielectricConstant::Vector{Float64}</code>: A region dependent dielectric constant.</li></ul><ul><li><code>dielectricConstantImageForce::Vector{Float64}</code>: A region dependent image force dielectric constant.</li></ul><ul><li><code>generationIncidentPhotonFlux::Vector{Float64}</code>: A region dependent array for the prefactor in the generation process which is the incident photon flux.</li></ul><ul><li><code>generationUniform::Vector{Float64}</code>: A region dependent array for an uniform generation rate.</li></ul><ul><li><code>generationAbsorption::Vector{Float64}</code>: A region dependent array for the absorption coefficient in the generation process.</li></ul><ul><li><code>recombinationRadiative::Vector{Float64}</code>: A region dependent array for the radiative recombination rate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.Params-Tuple{Any, Any}" href="#ChargeTransport.Params-Tuple{Any, Any}"><code>ChargeTransport.Params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Params(grid, numberOfCarriers) -&gt; Params
</code></pre><p>Simplified constructor for Params which only takes the grid and the numberOfCarriers as argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.ParamsNodal" href="#ChargeTransport.ParamsNodal"><code>ChargeTransport.ParamsNodal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ParamsNodal</code></pre><p>A struct holding the physical nodal, i.e. space-dependent parameters for a drift-diffusion simulation of a semiconductor device.</p><ul><li><code>dielectricConstant::Vector{Float64}</code>: A node dependent dielectric constant.</li></ul><ul><li><code>doping::Vector{Float64}</code>: A 1D array with the corresponding doping values on each node.</li></ul><ul><li><code>mobility::Matrix{Float64}</code>: A 2D array with the corresponding mobility values <span>$\mu_\alpha$</span> for each carrier <span>$\alpha$</span> on each node.</li></ul><ul><li><code>densityOfStates::Matrix{Float64}</code>: A 2D array with the corresponding effective density of states values <span>$N_\alpha$</span> for each carrier <span>$\alpha$</span> on each node.</li></ul><ul><li><code>bandEdgeEnergy::Matrix{Float64}</code>: A 2D array with the corresponding band-edge energy values <span>$E_\alpha$</span> for each carrier <span>$\alpha$</span> on each node.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.ParamsNodal-Tuple{Any, Any}" href="#ChargeTransport.ParamsNodal-Tuple{Any, Any}"><code>ChargeTransport.ParamsNodal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ParamsNodal(grid, numberOfCarriers) -&gt; ParamsNodal
</code></pre><p>Simplified constructor for ParamsNodal which only takes the grid and the numberOfCarriers as argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.ScharfetterGummel" href="#ChargeTransport.ScharfetterGummel"><code>ChargeTransport.ScharfetterGummel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ScharfetterGummel</code></pre><p>Abstract type for Scharfetter-Gummel flux discretization. Choose this one, when the Boltzmann statistics function is chosen as statistics, check D. Scharfetter and H. Gummel, “Large-signal analysis of a silicon Read diode oscillator”, IEEE Trans. Electr. Dev., vol. 16, pp. 64–77, 1969.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.ScharfetterGummelGraded" href="#ChargeTransport.ScharfetterGummelGraded"><code>ChargeTransport.ScharfetterGummelGraded</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ScharfetterGummelGraded</code></pre><p>Abstract type for Scharfetter-Gummel flux discretization for graded effective density of states and/or graded band-edge energies. This means, use this flux when at least one of these parameters is assumed to be space-dependent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.SchottkyContact" href="#ChargeTransport.SchottkyContact"><code>ChargeTransport.SchottkyContact</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for schottky contacts as boundary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.Stationary" href="#ChargeTransport.Stationary"><code>ChargeTransport.Stationary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Stationary</code></pre><p>Abstract type for stationary simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.System" href="#ChargeTransport.System"><code>ChargeTransport.System</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct System</code></pre><p>A struct holding all information necessary for a drift-diffusion type system.</p><ul><li><code>data::Data</code>: A struct holding all data information, see Data</li></ul><ul><li><code>fvmsys::VoronoiFVM.AbstractSystem</code>: A struct holding system information for the finite volume system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.System-Tuple{Any, Any}" href="#ChargeTransport.System-Tuple{Any, Any}"><code>ChargeTransport.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">System(grid, data; kwargs...)
</code></pre><p>System constructor which builds all necessary information needed based on the input parameters with special regard to the quasi Fermi potential model. This is the main struct in which all information on the input data, but also on the solving system, are stored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.Transient" href="#ChargeTransport.Transient"><code>ChargeTransport.Transient</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Transient</code></pre><p>Abstract type for transient simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.TrapCarrier" href="#ChargeTransport.TrapCarrier"><code>ChargeTransport.TrapCarrier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct TrapCarrier</code></pre><p>A struct holding all information necessary for enabling traps in the SRH recombination. With help of this constructor we can read out the index the user chooses for trap quasi Fermi potentials and the respective regions in which they are defined.</p><ul><li><code>trapCarrier::Int64</code>: Index of trap carrier user defines.</li></ul><ul><li><code>regions::Vector{Int64}</code>: Corresponding regions where trap carrier is assumed to be present.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><h2 id="Methods-2"><a class="docs-heading-anchor" href="#Methods-2">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.Blakemore-Tuple{Real, Real}" href="#ChargeTransport.Blakemore-Tuple{Real, Real}"><code>ChargeTransport.Blakemore</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Blakemore(x::Real, γ::Real) -&gt; Any
</code></pre><p>The Blakemore approximation <span>$1/(\exp(-x) + γ)$</span> with variable real scalar <span>$γ$</span>, see J. S. Blakemore. “The Parameters of Partially Degenerate Semiconductors”. In: Proceedings of the Physical Society. Section A 65 (1952), pp. 460–461.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.Boltzmann-Tuple{Real}" href="#ChargeTransport.Boltzmann-Tuple{Real}"><code>ChargeTransport.Boltzmann</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Boltzmann(x::Real) -&gt; Any
</code></pre><p>The Boltzmann statistics function <span>$\exp(x)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.FermiDiracMinusOne-Tuple{Real}" href="#ChargeTransport.FermiDiracMinusOne-Tuple{Real}"><code>ChargeTransport.FermiDiracMinusOne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FermiDiracMinusOne(x::Real) -&gt; Any
</code></pre><p>The Fermi-Dirac integral of order <span>$-1$</span> which reads <span>$1/(\exp(-x) + 1)$</span>, see J.S. Blakemore, Approximations for Fermi-Dirac integrals, especially the function <span>$F_{1/2} (\eta)$</span> used to describe electron density in a semiconductor, Solid-State Electronics 25 (11) (1982) 1067 – 1076.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.FermiDiracOneHalfBednarczyk-Tuple{Real}" href="#ChargeTransport.FermiDiracOneHalfBednarczyk-Tuple{Real}"><code>ChargeTransport.FermiDiracOneHalfBednarczyk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FermiDiracOneHalfBednarczyk(x::Real) -&gt; Any
</code></pre><p>The incomplete Fermi-Dirac integral of order 1/2, implemented according to [Bednarczyk1978, &quot;The Approximation of the Fermi-Dirac integral <span>$F_{1/2}(\eta)$</span>&quot;].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.FermiDiracOneHalfTeSCA-Tuple{Real}" href="#ChargeTransport.FermiDiracOneHalfTeSCA-Tuple{Real}"><code>ChargeTransport.FermiDiracOneHalfTeSCA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FermiDiracOneHalfTeSCA(x::Real) -&gt; Any
</code></pre><p>The incomplete Fermi-Dirac integral of order 1/2, implemented according to the software package TeSCA, see https://wias-berlin.de/software/index.jsp?lang=1&amp;id=TeSCA.</p><p>Modified to use log1p(x)=log(1+x).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.RHSContinuityEquations!-NTuple{4, Any}" href="#ChargeTransport.RHSContinuityEquations!-NTuple{4, Any}"><code>ChargeTransport.RHSContinuityEquations!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RHSContinuityEquations!(f, u, node, data)
</code></pre><p>Function which builds right-hand side of electric charge carriers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.RHSPoisson!-NTuple{5, Any}" href="#ChargeTransport.RHSPoisson!-NTuple{5, Any}"><code>ChargeTransport.RHSPoisson!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RHSPoisson!(f, u, node, data, ipsi) -&gt; Any
</code></pre><p>Function which builds right-hand side of Poisson equation, i.e. which builds the space charge density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.add_trap_density_Poisson!-Tuple{}" href="#ChargeTransport.add_trap_density_Poisson!-Tuple{}"><code>ChargeTransport.add_trap_density_Poisson!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_trap_density_Poisson!(; data, zt, Nt)
</code></pre><p>This method includes traps for a simplified model, where the trap carriers are not considered as additional carrier with an own continuity equation. In this case the trap density is additionally added to the right-hand side of Poisson equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.bflux!-NTuple{4, Any}" href="#ChargeTransport.bflux!-NTuple{4, Any}"><code>ChargeTransport.bflux!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bflux!(f, u, bedge, data)
</code></pre><p>Master bflux! function. This is the function which enters VoronoiFVM and hands over for each boundary the flux within the boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.breaction!-NTuple{4, Any}" href="#ChargeTransport.breaction!-NTuple{4, Any}"><code>ChargeTransport.breaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">breaction!(f, u, bnode, data) -&gt; Any
</code></pre><p>Master breaction! function. This is the function which enters VoronoiFVM and hands over for each boundary the chosen boundary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{OhmicContactDirichlet}}" href="#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{OhmicContactDirichlet}}"><code>ChargeTransport.breaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">breaction!(
    f,
    u,
    bnode,
    data,
    _::Type{OhmicContactDirichlet}
)
</code></pre><p>Creates ohmic boundary conditions via Dirichlet BC for the electrostatic potential <span>$\psi$</span></p><p><span>$\psi  = \psi_0 + U$</span>,</p><p>where <span>$\psi_0$</span> contains some given value and <span>$U$</span> is an applied voltage.</p><p><span>$f[\psi] =  -q/\delta  \sum_\alpha{ z_\alpha  (n_\alpha - C_\alpha) },$</span></p><p>where <span>$C_\alpha$</span> corresponds to some doping w.r.t. the species <span>$\alpha$</span>.</p><p>The boundary conditions for electrons and holes are dirichlet conditions, where</p><p><span>$\varphi_{\alpha} = U.$</span>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{OhmicContactRobin}}" href="#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{OhmicContactRobin}}"><code>ChargeTransport.breaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">breaction!(f, u, bnode, data, _::Type{OhmicContactRobin})
</code></pre><p>Creates ohmic boundary conditions via a penalty approach with penalty parameter <span>$\delta$</span>. For example, the right-hand side for the electrostatic potential <span>$\psi$</span> is implemented as</p><p><span>$f[\psi]  = -q/\delta   ( (p - N_a) - (n - N_d) )$</span>,</p><p>assuming a bipolar semiconductor. In general, we have for some given charge number <span>$z_\alpha$</span></p><p><span>$f[\psi] =  -q/\delta  \sum_\alpha{ z_\alpha  (n_\alpha - C_\alpha) },$</span></p><p>where <span>$C_\alpha$</span> corresponds to some doping w.r.t. the species <span>$\alpha$</span>.</p><p>The boundary conditions for electrons and holes are dirichlet conditions, where</p><p><span>$\varphi_{\alpha} = U$</span>`</p><p>with <span>$U$</span> as an applied voltage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{SchottkyBarrierLowering}}" href="#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{SchottkyBarrierLowering}}"><code>ChargeTransport.breaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">breaction!(
    f,
    u,
    bnode,
    data,
    _::Type{SchottkyBarrierLowering}
) -&gt; Any
</code></pre><p>Creates Schottky boundary conditions with additional lowering which are modelled as</p><p><span>$\psi = - \phi_S/q  + \sqrt{ -\frac{ q  \nabla_{\boldsymbol{\nu}} \psi_\mathrm{R}}{4\pi \varepsilon_\mathrm{i}}} + U$</span>,</p><p>where <span>$\psi_\mathrm{R}$</span> denotes the electric potential with standard Schottky contacts and the same space charge density as <span>$\psi$</span> and where <span>$\varepsilon_\mathrm{i}}}$</span> corresponds to the image force dielectric constant.</p><p>To solve for this additional boundary conditions the projected gradient <span>$\nabla_{\boldsymbol{\nu}} \psi_\mathrm{R}$</span> is stored within a boundary species and calculated in the method generic_operator!().</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.bstorage!-NTuple{4, Any}" href="#ChargeTransport.bstorage!-NTuple{4, Any}"><code>ChargeTransport.bstorage!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bstorage!(f, u, bnode, data) -&gt; Any
</code></pre><p>Master bstorage! function. This is the function which enters VoronoiFVM and hands over for each boundary the time-dependent part of the chosen boundary model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.build_system-Tuple{Any, Any, Type{ContQF}}" href="#ChargeTransport.build_system-Tuple{Any, Any, Type{ContQF}}"><code>ChargeTransport.build_system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_system(
    grid,
    data,
    ::Type{ContQF};
    kwargs...
) -&gt; System
</code></pre><p>The core of the system constructor. Here, the system for continuous quasi Fermi potentials is build.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.build_system-Tuple{Any, Any, Type{DiscontQF}}" href="#ChargeTransport.build_system-Tuple{Any, Any, Type{DiscontQF}}"><code>ChargeTransport.build_system</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_system(
    grid,
    data,
    ::Type{DiscontQF};
    kwargs...
) -&gt; System
</code></pre><p>The core of the system constructor. Here, the system for discontinuous quasi Fermi potentials is build.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.charge_density-NTuple{8, Any}" href="#ChargeTransport.charge_density-NTuple{8, Any}"><code>ChargeTransport.charge_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">charge_density(
    psi0,
    phi,
    UT,
    EVector,
    chargeNumbers,
    dopingVector,
    dosVector,
    FVector
) -&gt; Any
</code></pre><p>Compute the charge density, i.e. the right-hand side of Poisson&#39;s equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.charge_density-Tuple{Any, Any}" href="#ChargeTransport.charge_density-Tuple{Any, Any}"><code>ChargeTransport.charge_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">charge_density(ctsys, sol) -&gt; Any
</code></pre><p>Compute the charge density for each region separately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.degenerateLimit-Tuple{Any}" href="#ChargeTransport.degenerateLimit-Tuple{Any}"><code>ChargeTransport.degenerateLimit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degenerateLimit(x) -&gt; Any
</code></pre><p>Degenerate limit of incomplete Fermi-Dirac integral of order 1/2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.electroNeutralSolution-Tuple{Any}" href="#ChargeTransport.electroNeutralSolution-Tuple{Any}"><code>ChargeTransport.electroNeutralSolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">electroNeutralSolution(ctsys) -&gt; Any
</code></pre><p>Compute the electro-neutral solution for the Boltzmann approximation. It is obtained by setting the left-hand side in the Poisson equation equal to zero and solving for <span>$\psi$</span>. The charge carriers may obey different statitics functions. Currently, this one is not well tested for the case of charge carriers beyond electrons and holes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.enable_ionic_carrier!-Tuple{Any}" href="#ChargeTransport.enable_ionic_carrier!-Tuple{Any}"><code>ChargeTransport.enable_ionic_carrier!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enable_ionic_carrier!(data; ionicCarrier, regions)
</code></pre><p>This method takes the user information concerning present ionic charge carriers, builds a struct of Type IonicCarrier and add this struct to the ionicCarrierList.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.enable_trap_carrier!-Tuple{}" href="#ChargeTransport.enable_trap_carrier!-Tuple{}"><code>ChargeTransport.enable_trap_carrier!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enable_trap_carrier!(; data, trapCarrier, regions)
</code></pre><p>This method takes the user information concerning present trap charge carriers, builds a struct of Type TrapCarrier and add this struct to the trapCarrierList.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.etaFunction!-Tuple{Any, VoronoiFVM.BNode, Any, Any}" href="#ChargeTransport.etaFunction!-Tuple{Any, VoronoiFVM.BNode, Any, Any}"><code>ChargeTransport.etaFunction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">etaFunction!(u, bnode::VoronoiFVM.BNode, data, icc) -&gt; Any
</code></pre><p>The argument of the statistics function for boundary nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.etaFunction!-Tuple{Any, VoronoiFVM.Node, Any, Any}" href="#ChargeTransport.etaFunction!-Tuple{Any, VoronoiFVM.Node, Any, Any}"><code>ChargeTransport.etaFunction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">etaFunction!(u, node::VoronoiFVM.Node, data, icc) -&gt; Any
</code></pre><p>The argument of the statistics function for interior nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.etaFunction-NTuple{5, Any}" href="#ChargeTransport.etaFunction-NTuple{5, Any}"><code>ChargeTransport.etaFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">etaFunction(psi, phi, UT, E, z) -&gt; Any
</code></pre><p>The argument of the statistics function for given <span>$\varphi_\alpha$</span> and <span>$\psi$</span></p><p><span>$z_\alpha / U_T  ( (\varphi_\alpha - \psi) + E_\alpha / q ).$</span></p><p>The parameters <span>$E_\alpha$</span> and <span>$z_\alpha$</span> are given as vectors. This function may be used to compute the charge density, i.e. the right-hand side of the Poisson equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.etaFunction-Tuple{Any, Any, Any, Any, Any, Bool}" href="#ChargeTransport.etaFunction-Tuple{Any, Any, Any, Any, Any, Bool}"><code>ChargeTransport.etaFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">etaFunction(
    u,
    data,
    node,
    region,
    icc,
    in_region::Bool
) -&gt; Any
</code></pre><p>The argument of the distribution function for floats.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.etaFunction-Tuple{Any, Int64, Any, Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}}" href="#ChargeTransport.etaFunction-Tuple{Any, Int64, Any, Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}}"><code>ChargeTransport.etaFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">etaFunction(
    sol,
    ireg::Int64,
    ctsys,
    icc::Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}
) -&gt; Any
</code></pre><p>The argument of the statistics function for a given solution on a given interior region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.flux!-NTuple{4, Any}" href="#ChargeTransport.flux!-NTuple{4, Any}"><code>ChargeTransport.flux!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flux!(f, u, edge, data) -&gt; Any
</code></pre><p>Master flux functions which enters VoronoiFVM. Flux discretization scheme is chosen in two steps. First, we need to see, if we are in or out of equilibrium. If, InEquilibrium, then no flux is passed. If outOfEquilibrium, we choose the flux approximation which the user chose for each charge carrier. For the displacement flux we use a finite difference approach.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.generic_operator!-Tuple{Any, Any, Any}" href="#ChargeTransport.generic_operator!-Tuple{Any, Any, Any}"><code>ChargeTransport.generic_operator!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generic_operator!(f, u, fvmsys) -&gt; Any
</code></pre><p>Generic operator to save the projected gradient of electric potential (for system with standard Schotty contacts). Note that this currently only working in one dimension!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.get_BEE!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}, VoronoiFVM.Node, Any}" href="#ChargeTransport.get_BEE!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}, VoronoiFVM.Node, Any}"><code>ChargeTransport.get_BEE!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_BEE!(
    icc::Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}},
    node::VoronoiFVM.Node,
    data
) -&gt; Any
</code></pre><p>Defining locally the band-edge energy for interior nodes (analougesly for boundary nodes and edges).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.get_DOS!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}, VoronoiFVM.Node, Any}" href="#ChargeTransport.get_DOS!-Tuple{Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}, VoronoiFVM.Node, Any}"><code>ChargeTransport.get_DOS!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_DOS!(
    icc::Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}},
    node::VoronoiFVM.Node,
    data
) -&gt; Any
</code></pre><p>Defining locally the effective DOS for interior nodes (analogously for boundary nodes and edges).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.get_current_val-NTuple{4, Any}" href="#ChargeTransport.get_current_val-NTuple{4, Any}"><code>ChargeTransport.get_current_val</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates current for time dependent problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.get_current_val-Tuple{Any, Any}" href="#ChargeTransport.get_current_val-Tuple{Any, Any}"><code>ChargeTransport.get_current_val</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates current for stationary problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.BNode, Any, Any}" href="#ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.BNode, Any, Any}"><code>ChargeTransport.get_density!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_density!(u, bnode::VoronoiFVM.BNode, data, icc) -&gt; Any
</code></pre><p>For given potentials, compute corresponding densities for interior nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.Edge, Any, Any}" href="#ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.Edge, Any, Any}"><code>ChargeTransport.get_density!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_density!(
    u,
    edge::VoronoiFVM.Edge,
    data,
    icc
) -&gt; Tuple{Any, Any}
</code></pre><p>For given potentials, compute corresponding densities for edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.Node, Any, Any}" href="#ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.Node, Any, Any}"><code>ChargeTransport.get_density!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_density!(u, node::VoronoiFVM.Node, data, icc) -&gt; Any
</code></pre><p>For given potentials, compute corresponding densities for interior nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.get_density-NTuple{4, Any}" href="#ChargeTransport.get_density-NTuple{4, Any}"><code>ChargeTransport.get_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_density(sol, data, icc, ireg; inode) -&gt; Any
</code></pre><p>The densities for given potentials  <span>$\varphi_\alpha$</span> and <span>$\psi$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.get_density-Tuple{Any, Int64, Any, Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}}" href="#ChargeTransport.get_density-Tuple{Any, Int64, Any, Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}}"><code>ChargeTransport.get_density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_density(
    sol,
    ireg::Int64,
    ctsys,
    icc::Union{Int64, VoronoiFVM.ContinuousQuantity{Int32}, VoronoiFVM.DiscontinuousQuantity{Int32}, VoronoiFVM.InterfaceQuantity{Int32}}
) -&gt; Any
</code></pre><p>For given potentials, compute corresponding densities for given interior region corresponding to a homogeneous set of parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.plotDiffusionEnhancements-Tuple{}" href="#ChargeTransport.plotDiffusionEnhancements-Tuple{}"><code>ChargeTransport.plotDiffusionEnhancements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotDiffusionEnhancements(; Plotter)
</code></pre><p>Plot diffusion enhancements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.plotDistributions-Tuple{}" href="#ChargeTransport.plotDistributions-Tuple{}"><code>ChargeTransport.plotDistributions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plotDistributions(; Plotter)
</code></pre><p>Plot different distribution integrals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.plot_IV-NTuple{4, Any}" href="#ChargeTransport.plot_IV-NTuple{4, Any}"><code>ChargeTransport.plot_IV</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_IV(
    Plotter,
    biasValues,
    IV,
    title;
    plotGridpoints
) -&gt; Any
</code></pre><p>Method for showing the total current. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.plot_densities-NTuple{5, Any}" href="#ChargeTransport.plot_densities-NTuple{5, Any}"><code>ChargeTransport.plot_densities</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_densities(
    Plotter,
    ctsys,
    solution,
    title,
    label_density;
    plotGridpoints
) -&gt; Any
</code></pre><p>Plotting routine, where the charge carrier densities are depicted in dependence of space. The case of heterojunctions is tested, but yet multidimensional plottings are not included. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.plot_doping-Tuple{Any, Any, Any}" href="#ChargeTransport.plot_doping-Tuple{Any, Any, Any}"><code>ChargeTransport.plot_doping</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_doping(Plotter, ctsys, label_density) -&gt; Any
</code></pre><p>Possibility to plot the considered doping. This is especially useful for making sure that the interior and the boundary doping agree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ParamsNodal}" href="#ChargeTransport.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ParamsNodal}"><code>ChargeTransport.plot_doping</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Plot doping for nodal dependent doping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.plot_electroNeutralSolutionBoltzmann-Tuple{Any, Any, Any}" href="#ChargeTransport.plot_electroNeutralSolutionBoltzmann-Tuple{Any, Any, Any}"><code>ChargeTransport.plot_electroNeutralSolutionBoltzmann</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_electroNeutralSolutionBoltzmann(
    Plotter,
    grid,
    psi0;
    plotGridpoints
) -&gt; Any
</code></pre><p>Plotting routine for depicting the electroneutral potential. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.plot_energies-NTuple{5, Any}" href="#ChargeTransport.plot_energies-NTuple{5, Any}"><code>ChargeTransport.plot_energies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_energies(
    Plotter,
    ctsys,
    solution,
    title,
    label_energy;
    plotGridpoints
) -&gt; Any
</code></pre><p>With this method it is possible to plot the energies</p><p><span>$E_\alpha - q \psi \quad \text{w.r.t. space.}$</span></p><p>The case of heterojunctions is tested, but yet multidimensional plottings are not included.</p><p>One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.plot_energies-Tuple{Any, Any, Any}" href="#ChargeTransport.plot_energies-Tuple{Any, Any, Any}"><code>ChargeTransport.plot_energies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_energies(Plotter, ctsys, label_BEE)
</code></pre><p>With this method it is possible to depict the band-edge energies <span>$E_\alpha$</span>. This can be useful for debugging when dealing with heterojunctions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.plot_solution-NTuple{5, Any}" href="#ChargeTransport.plot_solution-NTuple{5, Any}"><code>ChargeTransport.plot_solution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_solution(
    Plotter,
    ctsys,
    solution,
    title,
    label_solution;
    plotGridpoints
) -&gt; Any
</code></pre><p>Method for plotting the solution vectors: the electrostatic potential <span>$\psi$</span> as well as the charge carriers. The case of heterojunctions is tested, but yet multidimensional plottings are not included. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.printJacobi-Tuple{Any, Any}" href="#ChargeTransport.printJacobi-Tuple{Any, Any}"><code>ChargeTransport.printJacobi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printJacobi(node, sys)
</code></pre><p>First try of debugger. Print the Jacobi matrix for a given node, i.e. the number of node in the grid and not the excact coordinate. This is only done for the one dimensional case so far.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.reaction!-NTuple{4, Any}" href="#ChargeTransport.reaction!-NTuple{4, Any}"><code>ChargeTransport.reaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reaction!(f, u, node, data)
</code></pre><p>Master reaction! function. This is the function which enters VoronoiFVM and hands over reaction terms for concrete calculation type and bulk recombination model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{InEquilibrium}}" href="#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{InEquilibrium}}"><code>ChargeTransport.reaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reaction!(f, u, node, data, _::Type{InEquilibrium})
</code></pre><p>Reaction in case of equilibrium, i.e. no generation and recombination is considered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}" href="#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}"><code>ChargeTransport.reaction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reaction!(f, u, node, data, _::Type{OutOfEquilibrium})
</code></pre><p>Sets up the right-hand sides. Assuming a bipolar semiconductor the right-hand side for the electrostatic potential becomes   <span>$f[ψ]  = - q ((p - N_a) - (n - N_d) ) = - q  \sum  n_\alpha  (n_\alpha - C_\alpha)$</span> for some doping <span>$C_\alpha$</span> w.r.t. to the species <span>$\alpha$</span>. The right-hand sides for the charge carriers read as <span>$f[n_\alpha] =  - z_\alpha  q (G -  R)$</span> for all charge carriers <span>$n_\alpha$</span>. The recombination includes radiative, Auger and Shockley-Read-Hall recombination. For latter recombination process the stationary simplification is implemented. The recombination is only implemented for electron and holes and assumes that the electron index is 1 and the hole index is 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.set_bulk_recombination-Tuple{}" href="#ChargeTransport.set_bulk_recombination-Tuple{}"><code>ChargeTransport.set_bulk_recombination</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_bulk_recombination(
;
    iphin,
    iphip,
    bulk_recomb_Auger,
    bulk_recomb_radiative,
    bulk_recomb_SRH
)
</code></pre><p>Corresponding constructor for the bulk recombination model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.set_plotting_labels-Tuple{Any}" href="#ChargeTransport.set_plotting_labels-Tuple{Any}"><code>ChargeTransport.set_plotting_labels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_plotting_labels(
    data
) -&gt; Tuple{Any, Any, Matrix{String}, Any}
</code></pre><p>Method which can be used to construct the arrays parsed to the plotting routines for labeling. The description for electrons and holes are predefined. If one wishes to extend by labels for, e.g. mobile ionic carriers or traps, this can be done within the main file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.storage!-NTuple{4, Any}" href="#ChargeTransport.storage!-NTuple{4, Any}"><code>ChargeTransport.storage!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">storage!(f, u, node, data) -&gt; Any
</code></pre><p>Master storage! function. This is the function which enters VoronoiFVM and hands over a storage term, if we consider transient problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.storage!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}" href="#ChargeTransport.storage!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}"><code>ChargeTransport.storage!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">storage!(
    f,
    u,
    node,
    data,
    _::Type{OutOfEquilibrium}
) -&gt; Float64
</code></pre><p>The storage term for time-dependent problems. Currently, for the time-dependent current densities the implicit Euler scheme is used. Hence, we have <span>$f[n_\alpha] =  z_\alpha  q ∂_t n_\alpha$</span> and for the electrostatic potential <span>$f[ψ] = 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.trap_density!-NTuple{4, Any}" href="#ChargeTransport.trap_density!-NTuple{4, Any}"><code>ChargeTransport.trap_density!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trap_density!(icc, ireg, params, Et)
</code></pre><p>Compute trap densities for a given trap energy. [Currently, only done for the Boltzmann statistics and for region dependent parameters.]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ChargeTransport.zeroVoltage-Tuple{Any}" href="#ChargeTransport.zeroVoltage-Tuple{Any}"><code>ChargeTransport.zeroVoltage</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Function in case of an applied voltage equal to zero at one boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PatricioFarrell/ChargeTransport.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../PSC/">« Perovskite solar cell</a><a class="docs-footer-nextpage" href="../nbhtml/PSC_example/">PSC example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Monday 22 April 2024 16:10">Monday 22 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
